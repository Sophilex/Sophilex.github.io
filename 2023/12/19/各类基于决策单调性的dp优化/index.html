

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/jaychou.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Sophilex">
  <meta name="keywords" content="抽象代数，组合数学，算法，多项式，动态规划">
  
    <meta name="description" content="从入门到入土的知识点都在这里了:)">
<meta property="og:type" content="article">
<meta property="og:title" content="各类基于决策单调性的dp优化">
<meta property="og:url" content="https://sophilex.github.io/2023/12/19/%E5%90%84%E7%B1%BB%E5%9F%BA%E4%BA%8E%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7%E7%9A%84dp%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="Sophilex‘s Blog">
<meta property="og:description" content="从入门到入土的知识点都在这里了:)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sophilex.github.io/img/j1.png">
<meta property="article:published_time" content="2023-12-19T00:21:24.000Z">
<meta property="article:modified_time" content="2023-12-19T09:52:30.386Z">
<meta property="article:author" content="Sophilex">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="动态规划">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://sophilex.github.io/img/j1.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>各类基于决策单调性的dp优化 - Sophilex‘s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"sophilex.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loadings.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baiduAnalytics":{"enable":true,"id":"87429697bdd967e2daa65f8887e98a2b"},"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<script src="/live2d-widget/autoload.js"></script>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Sophilex&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/j1.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="各类基于决策单调性的dp优化"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Sophilex
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-12-19 08:21" pubdate>
          2023年12月19日 早上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          104 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">各类基于决策单调性的dp优化</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="基于决策单调性的dp优化">基于决策单调性的dp优化</h2>
<h3 id="对于决策单调性的一般解释">对于决策单调性的一般解释</h3>
<p>众所周知，dp中会有转移，每一个状态可能会有若干个状态转移而来。现在我们考虑一类较为特殊的dp，最优化dp，在其中每一个点只能从一个最优状态转移而来。在此基础上，如果随着dp顺序的推进，每一个点的最优转移点也是单调移动的，我们就称其具有决策单调性.</p>
<p>比如说，对于一个常见一维<span
class="math inline">\(dp:dp_i=min/max\{dp_j+w(j,i)\}\)</span>,显然每一个点的dp值只能从<span
class="math inline">\(\{j|j&lt;i\}\)</span>的<span
class="math inline">\(dp_j\)</span>转移而来，我们记每一个点<span
class="math inline">\(i\)</span>的最优决策转移点为<span
class="math inline">\(p_i\)</span>.如果我们从1-n遍历i，<span
class="math inline">\(p_i\)</span>也随之单调变化，那么这个dp就具有决策单调性了.大部分决策单调性体现在决策点单调递增，但是也有决策点单调递减的情况(都是建立在枚举的点是从小到大的情况下)</p>
<h3 id="关于决策单调性的证明">关于决策单调性的证明</h3>
<p>显然我们可以打表。只要暴力写一个dp，然后毛估估看一看转移点是否单调即可。当然还有其它更加稳妥的方式</p>
<p>该部分讲解如无特殊声明，都是建立在求<strong>最小化</strong>问题的基础上，如果要求最大化的话，要把对应不等号取反</p>
<h4 id="四边形不等式">四边形不等式</h4>
<h5 id="一维dp">一维dp</h5>
<p>对应方程形式<span class="math inline">\(F\)</span> :<span
class="math inline">\(\large
dp_i=min_{j&lt;i}\{dp_j+w(j,i)\}\)</span></p>
<p>我们考虑<span class="math inline">\(p_1\leq p_2\leq p_3\leq
p_4\)</span></p>
<p>则<strong>最小化情况</strong>下的<strong>四边形不等式</strong>表示为：<span
class="math inline">\(w(p_1,p_3)+w(p_2,p_4)\leq
w(p_1,p_4)+w(p_2,p_3)\)</span></p>
<p>特别的，如果等号永远成立，称为<strong>四边形恒等式</strong></p>
<p>一般记为：<strong>交叉<span
class="math inline">\(\leq\)</span>包含</strong></p>
<blockquote>
<p>定理1：如果对于dp式F,其w满足四边形不等式，则F满足决策单调性</p>
</blockquote>
<ul>
<li><p><span class="math inline">\(Proof:\)</span></p>
<p>反证法。记<span
class="math inline">\(dp_i\)</span>的最优决策点为<span
class="math inline">\(p_i\)</span>,假设<span
class="math inline">\(y&lt;x\)</span>且<span
class="math inline">\(p_x&lt;p_y\)</span>.根据<span
class="math inline">\(F\)</span>的定义有：<span
class="math inline">\(dp_x=dp_{p_x}+w(p_x,x)\leq
dp_{p_y}+w(p_y,x)(1)\)</span></p>
<p>不难发现<span
class="math inline">\(p_x&lt;p_y&lt;y&lt;x\)</span>,故由四边形不等式：<span
class="math inline">\(w(p_x,y)+w(p_y,x)\leq
w(p_x,x)+w(p_y,y)(2)\)</span></p>
<p><span class="math inline">\(1,2\)</span>两式相加得到:<span
class="math inline">\(dp_{p_x}+w(p_x,y)\leq
dp_{p_y}+w(p_y,y)\)</span></p>
<p>则对于<span class="math inline">\(y\)</span>来说，<span
class="math inline">\(p_x\)</span>是一个比<span
class="math inline">\(p_y\)</span>更优的决策点，与条件矛盾。</p>
<p>故<span class="math inline">\(y&lt;x\)</span>意味着<span
class="math inline">\(p_y\leq p_x\)</span>，单调性得证</p></li>
</ul>
<h5 id="区间dp">区间dp</h5>
<p>一般来说高维dp的决策单调性体现在某一个维度，相对一维dp来说也会更加难发现，但是一种区间dp具有较好的性质</p>
<p>对应方程形式<span class="math inline">\(F\)</span> <span
class="math inline">\(\large
:dp_{i,j}=min_{k=i}^{j-1}\{dp_{i,k}+dp_{k+1,j}+w(i,j)\}\)</span></p>
<p>这里先介绍一个跟四边形不等式非常像的<strong>区间包含不等式</strong>：考虑<span
class="math inline">\(p_1\leq p_2\leq p_3\leq p_4\)</span>,则<span
class="math inline">\(w(p_1,p_4)\geq w(p_2,p_3)\)</span></p>
<blockquote>
<p>引理1：如果对于dp式F，其w同时满足四边形不等式以及区间包含不等式，则F也满足四边形不等式</p>
</blockquote>
<ul>
<li><p><span class="math inline">\(Proof:\)</span></p>
<p><a
target="_blank" rel="noopener" href="https://oi-wiki.org/dp/opt/quadrangle/">我不会但是有人会</a></p></li>
</ul>
<blockquote>
<p>定理2：如果对于dp式F，其满足四边形不等式，记<span
class="math inline">\(p_{i,j}为dp_{i,j}\)</span>的最优决策点，则<span
class="math inline">\(\forall i&lt;j,p_{i,j-1}\leq p_{i,j}\leq
p_{i+1,j}\)</span></p>
</blockquote>
<ul>
<li><p><span class="math inline">\(Proof:\)</span></p>
<p><a
target="_blank" rel="noopener" href="https://oi-wiki.org/dp/opt/quadrangle/">不会+1但是有人会</a></p></li>
</ul>
<p>基于此，我们对于<span
class="math inline">\(F\)</span>就能给出一个复杂度为<span
class="math inline">\(O(n^2)\)</span>的优化。</p>
<p>如果在计算<span class="math inline">\(f_{i,j}\)</span>的同时记录<span
class="math inline">\(p_{i,j}\)</span>，则对决策点<span
class="math inline">\(K\)</span>的枚举量为<span
class="math inline">\(\sum_{1\leq i&lt;j\leq n}p_{i+1,j}-p_{i,j-1}=
\sum_{i=1}^{n}p_{i,n}-p_{1,i}\leq n^2\)</span></p>
<p>例题：</p>
<p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=3506">HDU Monkey
Party</a></p>
<p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=3516">HDU Tree
Construction</a></p>
<p>大致来说就是看到对应形式，证一下四边形不等式，包含不等式，然后套板子即可</p>
<p>这里给个Monkey Party的代码(幼年码风，不喜勿喷)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">2020</span>;<br>ll n;<br>ll mas[N];<br>ll dp[N][N];<br>ll s[N][N];<br>ll sum[N];<br><span class="hljs-function">ll <span class="hljs-title">w</span><span class="hljs-params">(ll l,ll r)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> sum[r]-sum[l<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">while</span>(cin&gt;&gt;n)<br>	&#123;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;mas[i];<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>+n;i&lt;=n+n;++i) mas[i]=mas[i-n];<br><br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+n;++i) sum[i]=sum[i<span class="hljs-number">-1</span>]+mas[i];<br>		<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dp);<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+n;++i) dp[i][i]=<span class="hljs-number">0</span>,s[i][i]=i;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">2</span>;len&lt;=n;len++)&#123;<br>	            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n-len+<span class="hljs-number">1</span>;i++)&#123;<br>	                <span class="hljs-type">int</span> j=i+len<span class="hljs-number">-1</span>;<br>	                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=s[i][j<span class="hljs-number">-1</span>];k&lt;=s[i+<span class="hljs-number">1</span>][j];k++)&#123;<br>	                    <span class="hljs-keyword">if</span>(dp[i][j]&gt;dp[i][k]+dp[k+<span class="hljs-number">1</span>][j]+sum[j]-sum[i<span class="hljs-number">-1</span>])&#123;<br>	                        dp[i][j]=dp[i][k]+dp[k+<span class="hljs-number">1</span>][j]+sum[j]-sum[i<span class="hljs-number">-1</span>];<br>	                        s[i][j]=k;<br>	                    &#125;<br>	                &#125;<br>	            &#125;<br>	        &#125;<br>		ll ans=<span class="hljs-number">1e17</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>;l&lt;=n;++l)<br>		&#123;<br>			ans=<span class="hljs-built_in">min</span>(ans,dp[l][l+n<span class="hljs-number">-1</span>]);<br>		&#125;<br>		cout&lt;&lt;ans&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>
<h5 id="一种二维dp">一种二维dp</h5>
<p>这一块存疑</p>
<p>也是一种非常常见的dp式<span class="math inline">\(f\)</span> <span
class="math inline">\(:dp_{i,j}=min_{k&lt;i}\{dp_{k,j-1}+w(k,i)\}\)</span></p>
<p>按理说它跟上一块的区间dp是不同类型的，但是仿佛只要<span
class="math inline">\(w\)</span>满足引理1，<span
class="math inline">\(F\)</span>也有同样的结论。我没看到过严格证明，OIWIKI上也没找到对应介绍，但是大家好像都默认这是正确的，而且我目前也没找到反例...并不是很懂</p>
<p>反正用定理2来优化该dp的话，时间复杂度是<span
class="math inline">\(O(n^2)\)</span>的</p>
<p>例题：</p>
<p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=3480">HDU
Division</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll int</span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">10005</span>;<br>ll t,n,m;<br>ll dp[N][<span class="hljs-number">5010</span>];<br>ll mas[N];<br><span class="hljs-function">ll <span class="hljs-title">f</span><span class="hljs-params">(ll l,ll r)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> (mas[r]-mas[l])*(mas[r]-mas[l]);<br>&#125; <br>ll d[N][<span class="hljs-number">5010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>	cin&gt;&gt;t;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s=<span class="hljs-number">1</span>;s&lt;=t;++s)<br>	&#123;<br>		cin&gt;&gt;n&gt;&gt;m;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;mas[i];<br>		<span class="hljs-built_in">sort</span>(mas+<span class="hljs-number">1</span>,mas+<span class="hljs-number">1</span>+n);<br>		<span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dp);<br>		dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>		&#123;<br>			d[n+<span class="hljs-number">1</span>][j]=n;<br>			<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i;--i)<br>			&#123;<br>				ll tmp=<span class="hljs-number">0x3f3f3f3f</span>;<br>				ll p;<br>				<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=d[i][j<span class="hljs-number">-1</span>];k&lt;=d[i+<span class="hljs-number">1</span>][j];++k)<br>				&#123;<br>					<span class="hljs-keyword">if</span>(tmp&gt;dp[k][j<span class="hljs-number">-1</span>]+<span class="hljs-built_in">f</span>(k+<span class="hljs-number">1</span>,i))<br>					&#123;<br>						tmp=dp[k][j<span class="hljs-number">-1</span>]+<span class="hljs-built_in">f</span>(k+<span class="hljs-number">1</span>,i);<br>						p=k;<br>					&#125;<br>				&#125;<br>				dp[i][j]=tmp;<br>				d[i][j]=p;<br>			&#125;<br>		&#125;<br>		cout&lt;&lt;<span class="hljs-string">&quot;Case &quot;</span>&lt;&lt;s&lt;&lt;<span class="hljs-string">&quot;: &quot;</span>&lt;&lt;dp[n][m]&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>
<h5 id="一些满足四边形不等式的函数类">一些满足四边形不等式的函数类</h5>
<ul>
<li>若<span
class="math inline">\(w_{1(i,j)},w_{2(i,j)}\)</span>均满足四边形不等式（或区间包含不等式），则<span
class="math inline">\(\forall c_1,c_2\geq 0\)</span>,<span
class="math inline">\(c_1w_{1(i,j)}+c_2w_{2(i,j)}\)</span>也对应地满足四边形不等式（或区间包含不等式）</li>
<li>若存在函数<span class="math inline">\(f,g\)</span>，使得<span
class="math inline">\(w_{l,r}=f_r-g_l\)</span>,则<span
class="math inline">\(w\)</span>满足<strong>四边形恒等式</strong>（等号永远成立）。当<span
class="math inline">\(f,g\)</span>单调增的时候，<span
class="math inline">\(w\)</span>还满足区间包含不等式</li>
<li>设<span
class="math inline">\(h_x\)</span>是一个单调增的下凸函数，若<span
class="math inline">\(w\)</span>满足四边形不等式以及区间包含不等式，则<span
class="math inline">\(h(w(x))\)</span>也满足四边形不等式以及区间包含不等式</li>
<li>设<span class="math inline">\(h_x\)</span>是一个下凸函数,若<span
class="math inline">\(w\)</span>满足<strong>四边形恒等式</strong>以及区间包含不等式，则<span
class="math inline">\(h(w(x))\)</span>满足四边形不等式</li>
</ul>
<p>具体证明详见<a
target="_blank" rel="noopener" href="https://oi-wiki.org/dp/opt/quadrangle/">OIWIKI</a></p>
<p>这里以<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1912">NOI 2009
诗人小G</a>的dp递推式来试着用这些结论证一下决策单调性</p>
<p><span class="math inline">\(dp_i=min_{0\leq
j&lt;i}\{dp_j+|s_i-s_j-1-L|^P\}\)</span>,其中<span
class="math inline">\(s_i=i+\sum_{k=1}^{i}a_k\)</span>,<span
class="math inline">\(a_k&gt;0\)</span>为常值</p>
<p>这里<span
class="math inline">\(w_{j,i}=|s_i-s_j-1-L|^P\)</span>,我们不妨记<span
class="math inline">\(m_{j,i}=s_i-s_j-1-L\)</span>,则<span
class="math inline">\(w_{j,i}=|m_{j,i}|^P\)</span></p>
<p>我们考虑利用第2条结论：记<span
class="math inline">\(f_i=s_i-1-L,g_i=s_i\)</span>,显然<span
class="math inline">\(m_{j,i}=f_i-g_j\)</span>,故<span
class="math inline">\(m_{j,i}\)</span>满足四边形不等式,又<span
class="math inline">\(f_i,g_i\)</span>显然单增，故<span
class="math inline">\(m_{j,i}\)</span>满足区间包含不等式</p>
<p>又函数<span
class="math inline">\(|x|^P\)</span>显然是一个下凸函数，故由第4条结论可知，<span
class="math inline">\(w_{j,i}=m_{j,i}\)</span>也满足四边形不等式。再由定理1，该dp式满足决策单调性。证毕。</p>
<p>可以看到如果式子能记住的话，在面对一些比较复杂的递推式的时候能够较从容地推出决策单调性，如果直接用四边形不等式的定义硬证这题的话，还是需要不少分类讨论和强大的推柿子能力的（啊...只会套公式的屑）</p>
<h4 id="与图形相结合">与图形相结合</h4>
<p>来自一位大佬的<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/solution/P1912">奇妙讨论</a>,从另一个视角帮助我们理解了决策单调性</p>
<p>这里讨论一维最优化dp，也就是<span class="math inline">\(F\)</span>
<span class="math inline">\(:dp_i=min_{j\leq
i}\{dp_j+w(j,i)\}\)</span></p>
<p>决策单调性意味着决策点是单调的，换句话说，每一个点能够作为最优决策点的范围是一段连续区间</p>
<p><img src="https://s2.loli.net/2023/12/19/Ju8HYI5Z7Ge3hcb.png" srcset="/img/loadings.gif" lazyload alt="image-20230904215014871" style="zoom:100%;" /></p>
<p>在绿色区间内的点都是被<span
class="math inline">\(dp_{j_1}\)</span>更新，在黄色区间内的点都是被<span
class="math inline">\(dp_{j_2}\)</span>更新，不会出现黄色区间内有某个点是被<span
class="math inline">\(dp_{j_1}\)</span>更新的情况，否则就违背了决策单调性的定义</p>
<p>从几何视角来看这一事实。我们考虑<span
class="math inline">\(g_j(i)\)</span>，表示<span
class="math inline">\(dp_j+w(j,i)\)</span>,则<span
class="math inline">\(dp_i\)</span>可以重新表示为<span
class="math inline">\(dp_i=min_{j\leq
i}\{g_j(i)\}\)</span>。我们可以将<span
class="math inline">\(g_j(i)\)</span>看成<span
class="math inline">\(j\)</span>为常值，<span
class="math inline">\(i\)</span>为自变量的一个函数，那么<span
class="math inline">\(dp_i\)</span>本质上就是在所有函数<span
class="math inline">\(g_j(i)\)</span>里取最小值来转移</p>
<p>还是以上图为例，绿色区间内的点对应函数<span
class="math inline">\(g_{j_1}(i)\)</span>,黄色区间内对应函数<span
class="math inline">\(g_{j_2}(i)\)</span>,我们可以得到一个结论：两个函数只能有一个交点，否则就会出现前一段是<span
class="math inline">\(g_{j_1}(i)\)</span>更小,中间是<span
class="math inline">\(g_{j_2}(i)\)</span>,后面又变成<span
class="math inline">\(g_{j_1}(i)\)</span>更小的局面，那就违背了决策单调性的定义。反过来，如果只有一个交点的话，这两段区间就满足决策单调性</p>
<p>整体来看，我们可以得到：<strong>如果所有<span
class="math inline">\(g_j(i)\)</span>两两之间都至多只有一个交点的话，<span
class="math inline">\(F\)</span>是满足决策单调性的</strong>。个人感觉该命题的逆命题并不成立，毕竟实际在转移的时候只用考虑最小值的变化，值较大的函数之间是如何纠缠的我们并不关系。所以该结论应该只适用于证明决策单调性，而不能证否决策单调性</p>
<p>接下来我们考虑，如果<span
class="math inline">\(g_j(i)\)</span>之间至多只有一个交点，需要满足什么性质</p>
<p>该大佬给出的两个条件是：</p>
<ul>
<li><span
class="math inline">\(g_j(i)\)</span>之间可以通过平移相互变换</li>
<li><span
class="math inline">\(g_j(i)\)</span>的导函数在定义域内单调增/减（凸性唯一）</li>
</ul>
<p>以下分别是不满足对应条件的反例</p>
<p><img src="https://s2.loli.net/2023/12/19/xuIRkf4nhUZlaJr.png" srcset="/img/loadings.gif" lazyload alt="image-20230904215014871" style="zoom:100%;" /></p>
<p><img src="https://s2.loli.net/2023/12/19/uT5wJd3liy2AYzs.png" srcset="/img/loadings.gif" lazyload alt="image-20230904215014871" style="zoom:100%;" /></p>
<p>这两个条件不一定充分，只是感觉上可能也够了</p>
<p>然后大佬给出的一些总结：</p>
<ul>
<li><p>如果导函数递增，求最大值，或导函数递减，求最小值
用单调栈</p></li>
<li><p>如果导函数递增，求最小值，或导函数递减，求最大值
用单调队列</p></li>
</ul>
<p>具体怎么用单调栈，单调队列，我会在后面有所涉及</p>
<h3 id="决策单调性的常见优化手段">决策单调性的常见优化手段</h3>
<h4 id="二分队列">二分队列</h4>
<p>这应该算是最常见的一种利用决策单调性来优化dp的手段了。它只能用于决策点单调增的情况。</p>
<p>考虑之前的一个结论：每一个决策点的更新范围是一段连续区间。这意味着相邻两个决策点的更新范围之间存在着一个分界线<span
class="math inline">\(K\)</span>,当<span
class="math inline">\(i&lt;=k\)</span>的时候，由前一个点<span
class="math inline">\(j_1\)</span>更新，之后就由后一个点<span
class="math inline">\(j_2\)</span>更新,并且<span
class="math inline">\(j_1\)</span>就再也没有机会了。那么我们就可以维护一个单调队列来实现每次<span
class="math inline">\(O(logn)\)</span>的更新</p>
<p>具体来说，我们的单调队列中的每一个元素是一个三元组<span
class="math inline">\(\{P,l_p,r_p\}\)</span>,分别表示当前的决策点<span
class="math inline">\(P\)</span>,它能更新区间的左界<span
class="math inline">\(l_p\)</span>,它能更新区间的右界<span
class="math inline">\(r_p\)</span>。那么当我们尝试更新<span
class="math inline">\(dp_i\)</span>的时候，</p>
<ul>
<li><p>弹出队头。因为队列里的点的对应决策区间是单调的，所以我们可以直接将<span
class="math inline">\(r_p&lt;i\)</span>的队头三元组不断弹出。</p></li>
<li><p>用队头的<span class="math inline">\(P\)</span>更新<span
class="math inline">\(dp_i\)</span></p></li>
<li><p>将三元组<span
class="math inline">\(\{i,l_i,r_i\}\)</span>放入队列尾部。那么怎么求<span
class="math inline">\(l_i,r_i\)</span>?在求<span
class="math inline">\(l_i\)</span>之前，我们要意识到一个事实：我们所求的<span
class="math inline">\(l_p,r_p\)</span>都是建立在已经遍历到的点的信息上而建立的，换句话说，随着后面新的点<span
class="math inline">\(i\)</span>加入，它的决策区间有可能会完全包含某一个点<span
class="math inline">\(P\)</span>的决策区间。这一点很好理解：原本<span
class="math inline">\(l_i,r_i\)</span>就是由<span
class="math inline">\(i\)</span>更新的，但是因为我们还没有遍历到<span
class="math inline">\(i\)</span>,所以这段区间就会先被其它点占据。所以我们在求<span
class="math inline">\(l_i\)</span>之前，要先将队尾那些完全不会比<span
class="math inline">\(i\)</span>优的点踢出。具体如何判断？我们只要看一下在<span
class="math inline">\(l_p\)</span>处<span
class="math inline">\(i\)</span>是否比<span
class="math inline">\(P\)</span>更优即可。如果是，显然<span
class="math inline">\(P\)</span>就再也没有机会比<span
class="math inline">\(i\)</span>更优了，因为<span
class="math inline">\(p&lt;i\)</span>。</p>
<p>该操作之后<span class="math inline">\(i\)</span>就不能将队尾的<span
class="math inline">\(P\)</span>的区间完全覆盖了，我们就可以利用单调性二分一下两者的决策区间的边界，作为<span
class="math inline">\(l_i\)</span>.至于<span
class="math inline">\(r_i\)</span>,我们直接设成<span
class="math inline">\(n\)</span>即可。毕竟此时后面的点还没加入，我们只能用<span
class="math inline">\(i\)</span>来更新它们。</p></li>
</ul>
<p>贴个模板</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs stata">void Optimize()<br>&#123;<br>    <span class="hljs-comment">//该模板适用于最小化问题，若求最大化，自行将对应不等号取反即可</span><br>    <span class="hljs-comment">//cal()</span><br>    hd=1,tl=0;<br>    <span class="hljs-keyword">que</span>[++tl]=0;<span class="hljs-keyword">ls</span>[0]=1,rs[0]=<span class="hljs-keyword">n</span>;<br>    <span class="hljs-keyword">for</span>(int i=1;i&lt;=<span class="hljs-keyword">n</span>;++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;rs[<span class="hljs-keyword">que</span>[hd]]&lt;i) hd++;<span class="hljs-comment">//弹出无用点</span><br>        dp[i]=cal(<span class="hljs-keyword">que</span>[hd],i);<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;cal(i,<span class="hljs-keyword">ls</span>[<span class="hljs-keyword">que</span>[tl]])&lt;=cal(<span class="hljs-keyword">que</span>[tl],<span class="hljs-keyword">ls</span>[<span class="hljs-keyword">que</span>[tl]])) tl--;<span class="hljs-comment">//弹出无用点，若要求最大这里要改方向</span><br>        ll <span class="hljs-keyword">l</span>=<span class="hljs-keyword">ls</span>[<span class="hljs-keyword">que</span>[tl]],r=<span class="hljs-keyword">n</span>+1;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">l</span>&lt;=r)<br>        &#123;<br>            ll mid=(<span class="hljs-keyword">l</span>+r)&gt;&gt;1;<br>            <span class="hljs-keyword">if</span>(cal(i,mid)&lt;=cal(<span class="hljs-keyword">que</span>[tl],mid)) r=mid-1;<span class="hljs-comment">//若要求最大这里要改方向</span><br>            <span class="hljs-comment">//二分查找i与que[tl]的转移分界点，也就是最小的满足i优于que[tl]的点</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">l</span>=mid+1;<br>        &#125;<br>        p_ans=r+1;<br>        <span class="hljs-keyword">if</span>(p_ans&gt;<span class="hljs-keyword">n</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//i并没有用</span><br>        rs[<span class="hljs-keyword">que</span>[tl]]=p_ans-1;<br>        <span class="hljs-keyword">que</span>[++tl]=i;<span class="hljs-comment">//插入队列</span><br>        <span class="hljs-keyword">ls</span>[i]=p_ans,rs[i]=<span class="hljs-keyword">n</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>Tips:二分决策区间边界的时候，右界设置为n+1,因为i有可能完全不如P优，要防一手</p>
</blockquote>
<p>如果<span class="math inline">\(w(j,i)\)</span>我们能够以<span
class="math inline">\(O(1)\)</span>的复杂度求出的话，该方法的时间复杂度式<span
class="math inline">\(O(nlog)\)</span>的</p>
<p>例题：</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1912">NOI 2009
诗人小G</a></p>
<p>dp式并不难列出，关于其决策单调性我们已经在上一块里证明过了，所以这里直接用二分队列即可</p>
<p>数据范围有点大，记得开long double</p>
<p>code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ld long double</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IL inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">100010</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">998244353</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> X=<span class="hljs-number">0</span>; <span class="hljs-type">bool</span> flag=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">0</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="hljs-number">1</span>)+(X&lt;&lt;<span class="hljs-number">3</span>)+ch-<span class="hljs-string">&#x27;0&#x27;</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> X;<br>    <span class="hljs-keyword">return</span> ~(X<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-type">int</span> n,L,P;<br><span class="hljs-type">char</span> s[N][<span class="hljs-number">50</span>];<br>ld mas[N];<br><span class="hljs-type">int</span> ls[N],rs[N],pre[N];<span class="hljs-comment">//记录最优决策点</span><br><span class="hljs-type">int</span> que[N];<br><span class="hljs-type">int</span> hd,tl,p_ans;<br>ld dp[N];<br><span class="hljs-function">ld <span class="hljs-title">ksm</span><span class="hljs-params">(ld x,ll y)</span></span><br><span class="hljs-function"></span>&#123;<br>    ld ans=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(y)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) ans=ans*x;<br>        x=x*x;<br>        y&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function">ld <span class="hljs-title">cal</span><span class="hljs-params">(ll k,ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> dp[k]+<span class="hljs-built_in">ksm</span>(<span class="hljs-built_in">abs</span>(mas[x]-mas[k]<span class="hljs-number">-1</span>-L),P);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    n=<span class="hljs-built_in">read</span>();L=<span class="hljs-built_in">read</span>();P=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s[i]);<br>    <span class="hljs-comment">// for(int i=1;i&lt;=n;++i) cin&gt;&gt;s[i];</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        mas[i]=mas[i<span class="hljs-number">-1</span>]+<span class="hljs-built_in">strlen</span>(s[i])+<span class="hljs-number">1</span>;<br>    &#125;<br>    hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>    que[++tl]=<span class="hljs-number">0</span>;ls[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>,rs[<span class="hljs-number">0</span>]=n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;rs[que[hd]]&lt;i) hd++;<br>        dp[i]=<span class="hljs-built_in">cal</span>(que[hd],i);<br>        pre[i]=que[hd];<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">cal</span>(i,ls[que[tl]])&lt;=<span class="hljs-built_in">cal</span>(que[tl],ls[que[tl]])) tl--;<br>        ll l=ls[que[tl]],r=n+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;=r)<br>        &#123;<br>            ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cal</span>(i,mid)&lt;=<span class="hljs-built_in">cal</span>(que[tl],mid)) r=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-comment">//二分查找i与que[tl]的转移分界点，也就是最小的满足i优于que[tl]的点</span><br>            <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        p_ans=r+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(p_ans&gt;n) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//i并没有用</span><br>        rs[que[tl]]=p_ans<span class="hljs-number">-1</span>;<br>        que[++tl]=i;<span class="hljs-comment">//插入队列</span><br>        ls[i]=p_ans,rs[i]=n;<br>    &#125;<br>    <span class="hljs-comment">///////</span><br><br>    <span class="hljs-keyword">if</span>(dp[n]&gt;inf)<br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Too hard to arrange&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(ll)dp[n]);<br>        vector&lt;string&gt; ans;<br>        ll pos=n;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>        &#123;<br>            ll x=pre[pos]+<span class="hljs-number">1</span>;<br>            string ss=<span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;pos;++i) ss+=s[i],ss+=<span class="hljs-string">&quot; &quot;</span>;<br>            ss+=s[pos];<br>            ans.<span class="hljs-built_in">push_back</span>(ss);<br>            pos=pre[pos];<br>            <span class="hljs-keyword">if</span>(pos==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:ans) cout&lt;&lt;i&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;--------------------&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);</span><br>    ll t;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--)<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="二分栈">二分栈</h4>
<p>一般用于最优决策点是不增的情况。在原本的二分队列的做法中，我们从队列的首部取出最优决策点，从队列的尾部放入决策点。那么如果决策点是不增的，意味着我们需要从队列的尾部取最优决策点。这样取和放的操作都是在队列的尾部，我们只要用一个栈来实现就好了。同样的，相邻的两个决策点更新的区间会有一个边界，我们不妨记为<span
class="math inline">\(k_{l,r}\)</span>,当尝试加入<span
class="math inline">\(i\)</span>的时候，记队列倒数第一个元素为<span
class="math inline">\(p_1\)</span>,倒数第二个元素为<span
class="math inline">\(p_2\)</span>,那么如果<span
class="math inline">\(k_{p_1,p_2}\leq k_{p_2,i}\)</span>,那么<span
class="math inline">\(p_2\)</span>就可以踢掉了，因为它不管在什么时候都不会是<span
class="math inline">\(i,p_1,p_2\)</span>中的最优解。然后将<span
class="math inline">\(i\)</span>加入队列之后再按照<span
class="math inline">\(k_{p_1,p_2}\)</span>是否<span
class="math inline">\(\leq i\)</span>来踢即可</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5504">JSOI2001
柠檬</a></p>
<p>思路：</p>
<p>首先不难发现最优选择下每一段的首尾的颜色就是这段的<span
class="math inline">\(s_0\)</span>，否则我们就可以将首尾的没用的点分出去自称一段，贡献一定更优</p>
<p>所以我们可以按照不同的颜色来分开处理</p>
<p><span class="math inline">\(dp_i=max_{col_j=col_i,j\leq
i}\{dp_{j-1}+w(j,i)\}\)</span>,其中<span
class="math inline">\(w(j,i)=(sum_i-sum_j+1)^2\)</span></p>
<p>这里我们画图就能发现决策点是单调不增的（按照上文与图形结合的方法），所以可以使用二分栈。但是这题的决策单调性是在相同颜色的点之间才存在的，所以我们要分开来做二分栈</p>
<p>然后每一个点不会从0转移，所以一开始也不用把0放进去</p>
<p>code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> il inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bc(idx) vt[idx].size()-1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bd(idx) vt[idx].size()-2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> g(a,b) vt[a][b]</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">200000</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br>ll n;<br>ll mas[N];<br>vector&lt;ll&gt; vt[N];<br>ll dp[N];<br>ll ls[N],rs[N];<br>map&lt;ll,ll&gt; mp;<br>ll sum[N];<br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll k,ll num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> dp[k<span class="hljs-number">-1</span>]+mas[k]*num*num;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">gtf</span><span class="hljs-params">(ll a,ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll l=<span class="hljs-number">1</span>,r=n;<br>    <span class="hljs-keyword">while</span>(l&lt;=r)<br>    &#123;<br>        ll mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(a,mid-sum[a]+<span class="hljs-number">1</span>)&gt;=<span class="hljs-built_in">gt</span>(b,mid-sum[b]+<span class="hljs-number">1</span>)) r=mid<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;mas[i];<br>        mp[mas[i]]++;<br>        sum[i]=mp[mas[i]];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        ll idx=mas[i];<br>        <span class="hljs-keyword">while</span>(vt[idx].<span class="hljs-built_in">size</span>()&gt;=<span class="hljs-number">2</span>&amp;&amp; <span class="hljs-built_in">gtf</span>(<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bd</span>(idx)),<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bc</span>(idx)))&lt;=<span class="hljs-built_in">gtf</span>(<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bc</span>(idx)),i)) vt[idx].<span class="hljs-built_in">pop_back</span>();<br>        vt[idx].<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">while</span>(vt[idx].<span class="hljs-built_in">size</span>()&gt;=<span class="hljs-number">2</span>&amp;&amp; <span class="hljs-built_in">gtf</span>(<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bd</span>(idx)),<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bc</span>(idx)))&lt;=sum[i]) vt[idx].<span class="hljs-built_in">pop_back</span>();<br>        dp[i]=<span class="hljs-built_in">gt</span>(<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bc</span>(idx)),sum[i]-sum[<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bc</span>(idx))]+<span class="hljs-number">1</span>);<br>    &#125;<br>    cout&lt;&lt;dp[n]&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="分治">分治</h4>
<p>分治的方法主要用于同一层之间的点相互之间线性无关的情况。</p>
<p>比如<span class="math inline">\(F_1\)</span> <span
class="math inline">\(:dp_{i,j}=min\{dp_{i-1,k}+w(k,i)\}\)</span>.<span
class="math inline">\(F_2\)</span> <span
class="math inline">\(:dp_i=min\{a_k+w(k,i)\}\)</span></p>
<p>可以看到同一层之间的点不会相互转移</p>
<p>那么如果同一层的点满足决策单调性的话，也就是意味着决策点是单调的，我们就可以采用分治的策略来优化转移的过程</p>
<p>假设当前需要转移的区间是<span
class="math inline">\([L,R]\)</span>,决策点的选择区间是<span
class="math inline">\([p_l,p_r]\)</span>(显然一开始转移区间和决策点的选择区间都为<span
class="math inline">\([1,n]\)</span>)，设<span
class="math inline">\(mid=\frac{L+R}{2}\)</span>,我们可以先暴力求出<span
class="math inline">\(mid\)</span>的最优决策点<span
class="math inline">\(pos\)</span>,那么<span
class="math inline">\([L,mid-1]\)</span>的决策点选择区间就是<span
class="math inline">\([p_l,pos]\)</span>,<span
class="math inline">\([mid+1,R]\)</span>的决策点选择区间就是<span
class="math inline">\([pos,p_r]\)</span>，那么这样分治下去就好了。</p>
<p>如果我们可以<span
class="math inline">\(O(1)\)</span>求代价的话，对<span
class="math inline">\(mid\)</span>求<span
class="math inline">\(pos\)</span>的时间复杂度就只有<span
class="math inline">\(O(n)\)</span>,再加上每次要处理的区间长度会变成原本的一半，所以处理区间为n的复杂度是<span
class="math inline">\(f(n)=O(n)+O(f(n/2))\)</span>,总复杂度是<span
class="math inline">\(O(nlogn)\)</span></p>
<p>一个板子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solve</span><span class="hljs-params">(ll l,ll r,ll pl,ll pr)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">//当前分治处理区间是[l,r],最佳决策区间是[pl,pr]</span><br>	ll mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>	ll pos;<span class="hljs-comment">//mid的最佳决策点</span><br>	dp[mid]=<span class="hljs-built_in">gt</span>(pos=pl,mid);<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pl+<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">min</span>(mid<span class="hljs-number">-1</span>,pr);++i)<br>	&#123;<br>		<span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(i,mid)&lt;dp[mid]) dp[mid]=<span class="hljs-built_in">gt</span>(pos=i,mid);<br>	&#125;<br>	<span class="hljs-keyword">if</span>(l&lt;mid) <span class="hljs-built_in">Solve</span>(l,mid<span class="hljs-number">-1</span>,pl,pos);<br>	<span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">Solve</span>(mid+<span class="hljs-number">1</span>,r,pos,pr);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5503">JSOI2016
灯塔</a></p>
<p>大意：</p>
<p>给定<span class="math inline">\(h_i\)</span>，对于每一个<span
class="math inline">\(i\)</span>,要求<span class="math inline">\(\forall
j,p_i\geq h_j-h_i+\sqrt{|i-j|}\)</span>,求最小的<span
class="math inline">\(p_i\)</span></p>
<p>思路：</p>
<p>不妨先将绝对值去掉，那么<span
class="math inline">\(p_i=\left\{\begin{matrix}
min\{h_j+\sqrt{i-j}-h_i\} &amp; j&lt;i\\ min\{h_j+\sqrt{j-i}-h_i\} &amp;
j&gt;i \end{matrix}\right.\)</span></p>
<p>那么我们只要处理第一个式子就好了，第二个式子只要把整个数组反一下即可</p>
<p>可以发现<span
class="math inline">\(p_i=min\{h_j+\sqrt{i-j}-h_i\}\)</span>满足决策单调性，并且<span
class="math inline">\(p_i\)</span>之间相互无关，所以直接分治就解决了</p>
<p>code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IL inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">5e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> ep=<span class="hljs-number">1e-9</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">998244353</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br>ll n;<br>ll mas[N];<br><span class="hljs-type">double</span> dp1[N],dp2[N];<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">gt</span><span class="hljs-params">(ll p,ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> mas[p]+<span class="hljs-built_in">sqrt</span>(x-p)-mas[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solve</span><span class="hljs-params">(ll l,ll r,ll pl,ll pr,<span class="hljs-type">double</span> *dp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// if(l&gt;r||pl&gt;pr) return;</span><br>    ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    ll pos=pl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pl;i&lt;=<span class="hljs-built_in">min</span>(mid,pr);++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(i,mid)-dp[mid]&gt;=-ep) dp[mid]=<span class="hljs-built_in">gt</span>(pos=i,mid);<span class="hljs-comment">//要取&gt;=0</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(l&lt;mid) <span class="hljs-built_in">Solve</span>(l,mid<span class="hljs-number">-1</span>,pl,pos,dp);<br>    <span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">Solve</span>(mid+<span class="hljs-number">1</span>,r,pos,pr,dp);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;mas[i];<br>    <span class="hljs-built_in">Solve</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,n,dp1);<br>    <span class="hljs-built_in">reverse</span>(mas+<span class="hljs-number">1</span>,mas+<span class="hljs-number">1</span>+n);<br>    <span class="hljs-built_in">Solve</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,n,dp2);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-type">double</span> x=<span class="hljs-built_in">fmax</span>(dp1[i],dp2[n-i+<span class="hljs-number">1</span>]);<br>        cout&lt;&lt;(ll)<span class="hljs-built_in">ceil</span>(x)&lt;&lt;endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// ll t;t=read();while(t--)</span><br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4072">SDOI2016
征途</a></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF321E">CF321 E</a></p>
<h5 id="类莫队做法">类莫队做法</h5>
<p>注意到分治要保证时间复杂度的前提是每次求<span
class="math inline">\(w\)</span>代价的复杂度是<span
class="math inline">\(O(1)\)</span>的</p>
<p>但是有一类<span
class="math inline">\(w\)</span>比较特殊：关于区间的信息的记录，比如区间数字种类数等。这种问题我们一般可以离线下来用莫队处理，那么仿照莫队用左右端点的连续移动就可以做到<span
class="math inline">\(O(1)\)</span>转移了，因为我们的决策点的选择范围也刚好是一个连续的区间，所以这样的话复杂度是正确的</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF868F">CF868 F</a></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5574">CmdOI2019
任务分配问题</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IL inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">3e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> ep=<span class="hljs-number">1e-9</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">998244353</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tree</span><br>&#123;<br>    ll tr[N];<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> low(x) x&amp;(-x)</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(x&lt;N)<br>        &#123;<br>            tr[x]+=y;<br>            x+=<span class="hljs-built_in">low</span>(x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">sum</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ll ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x)<br>        &#123;<br>            ans+=tr[x];<br>            x-=<span class="hljs-built_in">low</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;T;<br>ll n,k;<br>ll mas[N];<br>ll dp[N],pp[N];<br><span class="hljs-keyword">namespace</span> Mo<br>&#123;<br>    <span class="hljs-type">int</span> L=<span class="hljs-number">1</span>,R=<span class="hljs-number">0</span>;<br>    ll ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> col[N];<br>    ll cnt[N];<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add1</span><span class="hljs-params">(ll pos,ll op)</span><span class="hljs-comment">//区间左边</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)<br>        &#123;<br>            ans+=T.<span class="hljs-built_in">sum</span>(n+<span class="hljs-number">1</span>)-T.<span class="hljs-built_in">sum</span>(col[pos]);<br>            T.<span class="hljs-built_in">add</span>(col[pos],<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ans-=T.<span class="hljs-built_in">sum</span>(n+<span class="hljs-number">1</span>)-T.<span class="hljs-built_in">sum</span>(col[pos]);<br>            T.<span class="hljs-built_in">add</span>(col[pos],<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add2</span><span class="hljs-params">(ll pos,ll op)</span><span class="hljs-comment">//区间右边</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)<br>        &#123;<br>            ans+=T.<span class="hljs-built_in">sum</span>(col[pos]<span class="hljs-number">-1</span>);<br>            T.<span class="hljs-built_in">add</span>(col[pos],<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ans-=T.<span class="hljs-built_in">sum</span>(col[pos]<span class="hljs-number">-1</span>);<br>            T.<span class="hljs-built_in">add</span>(col[pos],<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll l,ll r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        l++;<br>        <span class="hljs-keyword">while</span>(L&lt;l) <span class="hljs-built_in">add1</span>(L++,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span>(L&gt;l) <span class="hljs-built_in">add1</span>(--L,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span>(R&gt;r) <span class="hljs-built_in">add2</span>(R--,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span>(R&lt;r) <span class="hljs-built_in">add2</span>(++R,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> pp[l<span class="hljs-number">-1</span>]+ans;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solve</span><span class="hljs-params">(ll l,ll r,ll pl,ll pr)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    ll pos;<br>    dp[mid]=Mo::<span class="hljs-built_in">gt</span>(pos=pl,mid);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pl+<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">min</span>(mid<span class="hljs-number">-1</span>,pr);++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(dp[mid]&gt;Mo::<span class="hljs-built_in">gt</span>(i,mid)) dp[mid]=Mo::<span class="hljs-built_in">gt</span>(pos=i,mid);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(l&lt;mid) <span class="hljs-built_in">Solve</span>(l,mid<span class="hljs-number">-1</span>,pl,pos);<br>    <span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">Solve</span>(mid+<span class="hljs-number">1</span>,r,pos,pr);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;Mo::col[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) pp[i]=Mo::<span class="hljs-built_in">gt</span>(<span class="hljs-number">0</span>,i);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;k;++i)<br>    &#123;<br>        <span class="hljs-built_in">Solve</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">0</span>,n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) pp[j]=dp[j];<br>    &#125;<br>    cout&lt;&lt;pp[n]&lt;&lt;endl;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// ll t;t=read();while(t--)</span><br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="smawk">SMAWK</h4>
<p>SMAWK的用途跟分治一样，用于处理同一层之间没有转移关系的情况，但是复杂度会更优，可以达到<span
class="math inline">\(O(n)\)</span></p>
<p>我们考虑从另一个角度来理解决策单调性</p>
<blockquote>
<p><strong>定义1</strong>
若矩阵A满足∀i,j∈[0,k],pos(i)&lt;pos(j)则称A为单调矩阵。若A的任意子矩阵均为单调矩阵，则称A为完全单调矩阵</p>
</blockquote>
<p>重新定义四边形不等式</p>
<blockquote>
<p>定义2 对于n*m的矩阵A，若<span class="math inline">\(\forall
1&lt;i_1&lt;i_2\leq n,1\leq j_1,\leq j_2\leq m\)</span>,均有<span
class="math inline">\(A_{i_1,j_1}+A_{i_2,j_2}\leq
A_{i_1,j_2}+A_{i_2,j_1}\)</span>,则称A满足四边形不等式</p>
</blockquote>
<p>快速判断矩阵是否满足四边形不等式：</p>
<blockquote>
<p>定理1 对于n*m的矩阵A，若<span class="math inline">\(\forall
1&lt;i&lt;n,1\leq j&lt;m\)</span>,均有<span
class="math inline">\(A_{i,j}+A_{i+1,j+1}\leq
A_{i,j+1}+A_{i+1,j}\)</span>,则称A满足四边形不等式</p>
</blockquote>
<blockquote>
<p>定理2 若矩阵A满足四边形不等式，则A以及<span
class="math inline">\(A^{T}\)</span>是完全单调矩阵</p>
</blockquote>
<p>接下来考虑<span
class="math inline">\(dp_i=min_{j&lt;i}\{a_j+w(j,i)\}\)</span>,放到矩阵上，当<span
class="math inline">\(j&lt;i\)</span>时，<span
class="math inline">\(A_{i,j}=dp_j+w(j,i),j\geq i\)</span>时，令<span
class="math inline">\(A_{i,j}=inf\)</span>，那么求<span
class="math inline">\(dp_i\)</span>其实就是在第i行找最小值对应的列j.如果矩阵是一个单调矩阵，也就是dp满足决策单调性，我们就可以采用SMAWK</p>
<p>SMAWK的核心内容是reduce的过程，当列数m远大于n的时候，我们的枚举量会多很多，但是其实一行只会对应一个最优列，所以大量列是多余的，reduce过程就是在去除这些冗余列</p>
<p>当然，为了保证一行只有一个答案，我们要限定取每一行最左边/最右边的最小值<strong>（这一点在与WQS二分结合的时候很重要）</strong></p>
<p>其步骤如下：</p>
<ul>
<li><p>1初始定义 <em>k</em> = 1；</p></li>
<li><p>2当 <em>n</em> <em>≥</em> <em>m</em> 时结束过程；否则比较 <span
class="math inline">\(A_{k,k}\)</span> 和 <span
class="math inline">\(A_{k,k+1}\)</span></p></li>
<li><p>3若 <span class="math inline">\(A_{k,k}\geq
A_{k,k+1}\)</span>，删除第 <em>k</em> 列，<em>k</em> <em>←</em>
max(<em>k</em> <em>−</em> 1<em>,</em> 1)，回到步骤 2；</p></li>
<li><p>4若 <span class="math inline">\(A_{k,k}&lt; A_{k,k+1}\)</span> 且
<em>k</em> = <em>n</em>，删除第 <em>n</em> + 1 列，回到步骤 2；</p></li>
<li><p>5若 <span class="math inline">\(A_{k,k}&lt; A_{k,k+1}\)</span> 且
<em>k</em> = <em>n</em>，<em>k</em> <em>←</em> <em>k</em> + 1，回到步骤
2。</p></li>
</ul>
<p>每一步的原因还是很显然的，这里不多赘述了。复杂度是<span
class="math inline">\(O(m+n)\)</span></p>
<p>为了保证线性复杂度的正确性，可以用链表实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    ll val,opt;<br>    Node *lst,*nxt;<br>    <span class="hljs-built_in">Node</span>()&#123;val=opt=<span class="hljs-number">0</span>;lst=nxt=<span class="hljs-literal">NULL</span>;&#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">List</span><br>&#123;<br>    ll len;<span class="hljs-comment">//列表长度</span><br>    Node *s,*e;<br>    <span class="hljs-built_in">List</span>()<br>    &#123;<br>        len=<span class="hljs-number">0</span>;<br>        s=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();s-&gt;opt=<span class="hljs-number">1</span>;<br>        e=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();e-&gt;opt=<span class="hljs-number">-1</span>;<br>        s-&gt;nxt=e;e-&gt;lst=s;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//将x加入尾部</span><br>        Node *n=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        n-&gt;val=x;<br>        Node *a=e-&gt;lst;<span class="hljs-comment">//尾部元素</span><br>        a-&gt;nxt=n;n-&gt;lst=a;<br>        n-&gt;nxt=e;e-&gt;lst=n;<br>        len++;<span class="hljs-comment">//长度</span><br>    &#125;<br>    <span class="hljs-built_in">List</span>(<span class="hljs-type">const</span> List &amp;a)<br>    &#123;<br>        <span class="hljs-comment">//Copy</span><br>        len=<span class="hljs-number">0</span>;<br>        s=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();s-&gt;opt=<span class="hljs-number">1</span>;<br>        e=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();e-&gt;opt=<span class="hljs-number">-1</span>;<br>        s-&gt;nxt=e;e-&gt;lst=s;<br>        Node *n=a.s-&gt;nxt;<br>        <span class="hljs-keyword">while</span>(n-&gt;opt!=<span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-built_in">append</span>(n-&gt;val);<br>            n=n-&gt;nxt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">Node* <span class="hljs-title">del</span><span class="hljs-params">(Node *n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        --len;<br>        Node *a=n-&gt;lst,*b=n-&gt;nxt;<br>        a-&gt;nxt=b,b-&gt;lst=a;<br>        <span class="hljs-built_in">delete</span>(n);<br>        <span class="hljs-keyword">return</span> a;<span class="hljs-comment">//前一个节点</span><br>    &#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">submat</span><br>&#123;<br>    List r,c;<br>    <span class="hljs-comment">//row,column</span><br>&#125;A;<br><span class="hljs-function">submat <span class="hljs-title">Reduce</span><span class="hljs-params">(<span class="hljs-type">const</span> submat &amp;A)</span></span><br><span class="hljs-function"></span>&#123;<br>    submat B;<br>    B.r=(List)A.r;B.c=(List)A.c;<br>    <span class="hljs-type">int</span> n=A.r.len;<span class="hljs-comment">//行数</span><br>    <span class="hljs-type">int</span> m=A.c.len;<span class="hljs-comment">//列数</span><br>    Node *nr=B.r.s-&gt;nxt;<span class="hljs-comment">//第一个节点</span><br>    Node *nc=B.c.s-&gt;nxt;<br>    ll k=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(n&lt;m)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(nr-&gt;val,nc-&gt;val)&gt;<span class="hljs-built_in">get</span>(nr-&gt;val,nc-&gt;nxt-&gt;val))<br>        &#123;<br>            nc=B.c.<span class="hljs-built_in">del</span>(nc);<br>            m--;<br>            <span class="hljs-keyword">if</span>(k&gt;<span class="hljs-number">1</span>)<br>            &#123;<br>                --k;<br>                nr=nr-&gt;lst;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">//k=1</span><br>                nr=B.r.s-&gt;nxt;nc=B.c.s-&gt;nxt;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k==n)<br>        &#123;<br>            B.c.<span class="hljs-built_in">del</span>(nc-&gt;nxt);m--;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            k++;<br>            nr=nr-&gt;nxt;nc=nc-&gt;nxt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> B;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>reduce之后我们就真正开始SMAWK了</p>
<p>SMAWK(A) 表示计算 <em>n</em> <em>×</em> <em>m</em> 的完全单调矩阵
<em>A</em> 的<strong>每行最小值</strong>所在</p>
<p>列。步骤如下：</p>
<ul>
<li>1若 min(<em>n,</em> <em>m</em>) = 1 直接计算答案；</li>
<li>2对Areduce，得到矩阵B,并且我们取其所有偶数行组成一个新矩阵C</li>
<li>4递归SMAWK(C),得到C的每一行的最小值所在位置</li>
<li>4对于B中的奇数行，其答案在相邻两行的答案之间，那么之间暴力遍历一下即可。该步骤的复杂度为<span
class="math inline">\(O(m)\)</span></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SMAWK</span><span class="hljs-params">(submat A)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n=A.r.len;<span class="hljs-comment">//行数</span><br>    <span class="hljs-type">int</span> m=A.c.len;<span class="hljs-comment">//列数</span><br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>    &#123;<br>        ll x=A.r.s-&gt;nxt-&gt;val;<span class="hljs-comment">//只有一行</span><br>        Node *nc=A.c.s-&gt;nxt;<br>        ll maxn=<span class="hljs-number">0</span>;<br>        ll maxp=<span class="hljs-number">0</span>;<span class="hljs-comment">//最值位置</span><br>        <span class="hljs-keyword">while</span>(nc-&gt;opt!=<span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(x,nc-&gt;val)&gt;=maxn)<br>            &#123;<br>                maxp=nc-&gt;val,maxn=<span class="hljs-built_in">get</span>(x,nc-&gt;val);<br>            &#125;<br>            nc=nc-&gt;nxt;<br>        &#125;<br>        ans[x]=maxp;<span class="hljs-comment">//存储最大值所在位置</span><br>        <span class="hljs-comment">///</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(m==<span class="hljs-number">1</span>)<br>    &#123;<br>        ll y=A.c.s-&gt;nxt-&gt;val;<br>        Node *nr=A.r.s-&gt;nxt;<span class="hljs-comment">//第一行</span><br>        <span class="hljs-keyword">while</span>(nr-&gt;opt!=<span class="hljs-number">-1</span>)<br>        &#123;<br>            ans[nr-&gt;val]=y;<br>            nr=nr-&gt;nxt;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    submat B=<span class="hljs-built_in">Reduce</span>(A);<br>    submat C;C.c=<span class="hljs-built_in">List</span>(B.c);<span class="hljs-comment">//首先保存每一列的信息</span><br>    Node *nr=B.r.s-&gt;nxt;<span class="hljs-comment">//行第一个元素</span><br>    <span class="hljs-type">bool</span> fl=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(nr-&gt;opt!=<span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(fl) C.r.<span class="hljs-built_in">append</span>(nr-&gt;val);<span class="hljs-comment">//C保存偶数行</span><br>        nr=nr-&gt;nxt;<br>        fl^=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//得到一个只有偶数行，列不变的矩阵</span><br>    <span class="hljs-built_in">SMAWK</span>(C);<span class="hljs-comment">//递归</span><br>    nr=B.r.s-&gt;nxt;fl=<span class="hljs-number">0</span>;<br>    Node *nc=B.c.s-&gt;nxt;<span class="hljs-comment">//列指针</span><br>    <span class="hljs-keyword">while</span>(nr-&gt;opt!=<span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!fl)<br>        &#123;<br>            ll z=ans[nr-&gt;nxt-&gt;val];<span class="hljs-comment">//已经处理过了，这里是有值的</span><br>            ll x=nr-&gt;val;<br>            ll maxn=<span class="hljs-number">0</span>,maxp=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(z==<span class="hljs-number">0</span>) z=inf;<br>            <span class="hljs-keyword">while</span>(nc-&gt;opt!=<span class="hljs-number">-1</span> &amp;&amp; nc-&gt;val&lt;=z)<br>            &#123;<br>                <span class="hljs-comment">//枚举列</span><br>                <span class="hljs-comment">//返回的是最右边的最小值</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(x,nc-&gt;val)&gt;=maxn)<br>                &#123;<br>                    maxn=<span class="hljs-built_in">get</span>(x,nc-&gt;val);<br>                    maxp=nc-&gt;val;<br>                &#125;<br>                nc=nc-&gt;nxt;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nc-&gt;lst-&gt;val==z) nc=nc-&gt;lst;<br>            ans[x]=maxp;<br>        &#125;<br>        nr=nr-&gt;nxt;<br>        fl^=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>理论上是可以平替分治的，但是写起来太烦了。。。</p>
<p>有一份短一点的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//求每行最左边最小值</span><br><span class="hljs-type">int</span> pre[N],suf[N],M[N],n,m,ans=<span class="hljs-number">1e18</span>,P=<span class="hljs-number">0</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;L,H;<br>map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;Mp[N];<br><span class="hljs-function">ll <span class="hljs-title">get</span><span class="hljs-params">(ll a,ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//返回第a行第b列的元素</span><br>&#125; <br><span class="hljs-type">int</span> pre[N],suf[N],M[N],P=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (pre[x]!=<span class="hljs-number">-1</span>)<br>        suf[pre[x]]=suf[x]; <span class="hljs-keyword">else</span> P=suf[x];<br>    pre[suf[x]]=pre[x];<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">reduce</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;X,vector&lt;<span class="hljs-type">int</span>&gt;Y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;Y.<span class="hljs-built_in">size</span>();i++) pre[i]=i<span class="hljs-number">-1</span>,suf[i]=i+<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,y=<span class="hljs-number">0</span>;<br>    P=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> nmsl=Y.<span class="hljs-built_in">size</span>()-X.<span class="hljs-built_in">size</span>();nmsl&gt;<span class="hljs-number">0</span>;nmsl--)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>(X[x],Y[y])&lt;<span class="hljs-built_in">get</span>(X[x],Y[suf[y]]))<br>        &#123;<br>            y=suf[y];<br>            <span class="hljs-built_in">del</span>(pre[y]);<br>            <span class="hljs-keyword">if</span> (x) y=pre[y],x--;<br>        &#125; <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (x==X.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>) <span class="hljs-built_in">del</span>(suf[y]);<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                y=suf[y];<br>                x++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt;ret;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=P;i!=Y.<span class="hljs-built_in">size</span>();i=suf[i])  ret.<span class="hljs-built_in">push_back</span>(Y[i]);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solve</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;X,vector&lt;<span class="hljs-type">int</span>&gt;Y)</span></span><br><span class="hljs-function"></span>&#123;<br>    Y=<span class="hljs-built_in">reduce</span>(X,Y);<br>    <span class="hljs-keyword">if</span> (X.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)<br>    &#123;<br>        M[X[<span class="hljs-number">0</span>]]=Y[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt;Z;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;X.<span class="hljs-built_in">size</span>();i++)<br>        <span class="hljs-keyword">if</span> (!(i%<span class="hljs-number">2</span>)) Z.<span class="hljs-built_in">push_back</span>(X[i]);<br>    <span class="hljs-built_in">Solve</span>(Z,Y);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;X.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!(i%<span class="hljs-number">2</span>)) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> l=<span class="hljs-built_in">lower_bound</span>(Y.<span class="hljs-built_in">begin</span>(),Y.<span class="hljs-built_in">end</span>(),M[X[i<span class="hljs-number">-1</span>]])-Y.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-type">int</span> r=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i==X.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>) r=Y.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            r=<span class="hljs-built_in">lower_bound</span>(Y.<span class="hljs-built_in">begin</span>(),Y.<span class="hljs-built_in">end</span>(),M[X[i+<span class="hljs-number">1</span>]])-Y.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>        M[X[i]]=Y[l];<br>        <span class="hljs-keyword">while</span> (l&lt;r)<br>        &#123;<br>            l++;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>(X[i],Y[l])&gt;<span class="hljs-built_in">get</span>(X[i],M[X[i]])) M[X[i]]=Y[l];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>	&#123;<br>		H.<span class="hljs-built_in">push_back</span>(i);<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++) L.<span class="hljs-built_in">push_back</span>(i);<br>	<span class="hljs-built_in">Solve</span>(H,L);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="wqs二分">WQS二分+</h4>
<p>可以与其它方法结合在一起，达到一个非常优秀的时间复杂度</p>
<p>关于WQS二分本身的内容这里就不多赘述了，可以去看其它文章理解一下，这里主要讲一下如何将其应用在决策单调性中</p>
<p>考虑一类问题：将一个序列强制分为k段，每一段<span
class="math inline">\([l,r]\)</span>有一个价值<span
class="math inline">\(w(l,r)\)</span>,问总价值最小的分段</p>
<p>假设将序列分为k段的最优价值为<span
class="math inline">\(f_k\)</span>，<strong>如果</strong>所有的<span
class="math inline">\((k,f_k)\)</span>组成一个凸函数，那么我们就可以使用WQS二分了。外层枚举斜率，内层就去掉了分段的限制，就可以使用二分队列/斜率优化/分治等措施了。</p>
<p>现在问题还是很多的，比如凸性的证明，WQS二分的边界问题，内部求最优值时更新的取等问题等。一个一个来</p>
<h5 id="wqs多解情况">WQS多解情况</h5>
<p>多解情况是指答案K与多个点在一条线段上，此时我们无法直接通过枚举斜率来做到只切到点K，所以我们需要在枚举的同时让得到的方案具有完全的偏序，来保证我们枚举斜率的时候，知道当前斜率对应的答案是哪一点的答案，是线段左端点的，还是右端点的，从而保证后面二分调整mid的时候不会弄混淆。很重要的一点是，我们需要的只是正确的斜率，不需要保证当前斜率做出来的最优点一定是K,因为<span
class="math inline">\(f_k=mid*k+b\)</span>,其中斜率<span
class="math inline">\(mid\)</span>和截距<span
class="math inline">\(b\)</span>都是二分之后确定的值，在同一线段上的点做出的<span
class="math inline">\(mid,b\)</span>都是一样的。</p>
<p>那么为了做到严格偏序，我们需要对每一个属性都定义大小</p>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/Emm_Titan/article/details/124035796?spm=1001.2014.3001.5502">这篇博客</a>讲的很清晰，我可能讲的有点抽象，可以去再看看</p>
<p><img src="https://s2.loli.net/2023/12/19/3lAUxiLe4rvwNRa.png" srcset="/img/loadings.gif" lazyload alt="image-20230916171500911" style="zoom:100%;" /></p>
<h5
id="满足四边形不等式的序列划分问题的答案凸性以及wqs二分的方案构造">满足四边形不等式的序列划分问题的答案凸性以及WQS二分的方案构造</h5>
<p>这里我们尝试证明满足四边形不等式的序列划分问题都具有凸性</p>
<blockquote>
<p>不妨先来看另一个问题：给定一张n个点的DAG，点<span
class="math inline">\(i\)</span>与点<span
class="math inline">\(j\)</span>当<span
class="math inline">\(i&lt;j\)</span>时有权值<span
class="math inline">\(w(i,j)\)</span>,问从1走到n的经过k条边的最短路</p>
</blockquote>
<p>简单转化一下，这个问题的dp方程就是我们熟悉的:<span
class="math inline">\(dp_{i,j}=min\{dp_{k,j-1}+w(k,i)\}\)</span>,<span
class="math inline">\(dp_{i,j}\)</span>表示走到i，经过j条边的最短路</p>
<p>设<span class="math inline">\(f_k\)</span>表示经过k条边的最短路</p>
<p>下面我们尝试证明：当权值矩阵w满足四边形不等式的时候，<span
class="math inline">\(f_k\)</span>是一个下凸函数。换句话说，<span
class="math inline">\(\forall k\in[2,n-2]\)</span>，<span
class="math inline">\(f_{k+1}-f_k&gt;f_k-f_{k-1}\)</span></p>
<blockquote>
<p>引理：<em>∀</em>1 <em>≤</em> <em>s</em> <em>&lt;</em> <em>r</em>
<em>&lt;</em> <em>t</em> <em>≤</em> <em>n</em> <em>−</em> 1<em>,</em>
<em>f</em>(<em>s</em>) + <em>f</em>(<em>t</em>) <em>≥</em>
<em>f</em>(<em>r</em>) + <em>f</em>(<em>s</em> + <em>t</em> <em>−</em>
<em>r</em>)</p>
</blockquote>
<p>如果我们能够证明该引理的话，带入<span
class="math inline">\(s=k-1,r=k,t=k+1\)</span>,则命题得证</p>
<p>下面尝试证明引理：</p>
<hr />
<p>不妨记<span class="math inline">\(f_s\)</span>对应的最优方案是<span
class="math inline">\(p_1,p_2...p_{s+1}\)</span>,<span
class="math inline">\(f_t\)</span>对应的最优方案是<span
class="math inline">\(q_1,q_2,..q_{t+1}\)</span></p>
<p>记<span
class="math inline">\(v=r-s&gt;0\)</span>,如果我们能够找到<span
class="math inline">\(i \in [1,s]\)</span>,满足<span
class="math inline">\(p_i\leq q_{i+v}&lt;q_{i+v+1}\leq p_{i+1}(i+v+1\leq
s+v+1\leq t)\)</span>,就能够构造路径<span
class="math inline">\(R_1:\)</span><span
class="math inline">\(p_1,...p_i,q_{i+v+1},q_{i+v+2},..q_{t+1}\)</span>,以及路径<span
class="math inline">\(R_2:\)</span><span
class="math inline">\(q_1,...q_{i+v},p_{i+1},p_{i+2},...p_{s+1}\)</span>(也就是把两段路径的后半段交换了一下，并且保证一定交换了一部分)</p>
<p>两段路径的<strong>长度</strong>分别是<span
class="math inline">\(i-1+(t+1-i-v-1)+1=t-v=t-r+s\)</span>,以及<span
class="math inline">\(i-1+v+(s+1-i-1)+1=s+v=r\)</span>,</p>
<p>那么由f的定义,<span
class="math inline">\(R_1\)</span>的<strong>路径长度</strong><span
class="math inline">\(len（R_1) \geq f_{t-r+s}\)</span>,<span
class="math inline">\(R_2\)</span>的<strong>路径长度</strong><span
class="math inline">\(len(R_2)\geq f_{r}\)</span>,</p>
<p>由四边形不等式<span
class="math inline">\(w(p_i,q_{i+v+1})+w(q_{i+v},p_{i+1})\leq
w(q_{i+v}+q_{i+v+1})+w(p_i,p_{i+1})\)</span></p>
<p>故<span class="math inline">\(f_s+f_t\geq len(R_1)+len(R_2)\geq
f_{t-r+s}+f_r\)</span></p>
<p>第一个不等式是因为<span
class="math inline">\(R_1,R_2\)</span>与原本路径的区别只有中间衔接的一段</p>
<p>由上，我们只要证明存在这样的一个<span
class="math inline">\(i\)</span>即可。</p>
<figure>
<img src="https://s2.loli.net/2023/12/19/r69QhC8pR2SqgJM.png" srcset="/img/loadings.gif" lazyload
alt="image-20230916142205317" />
<figcaption aria-hidden="true">image-20230916142205317</figcaption>
</figure>
<p>不妨记路径P将<span
class="math inline">\((1,n]\)</span>分成了s个部分，其中第i个部分是<span
class="math inline">\((p_i,p_{i+1}]\)</span></p>
<p>我们记<span class="math inline">\(a_i\)</span>表示<span
class="math inline">\(q_{i+v}\)</span>在哪一段，那么如果存在<span
class="math inline">\(i\)</span>,<span
class="math inline">\(a_i=a_i+1=k\)</span>,我们就找到答案为k了。</p>
<p>记<span class="math inline">\(b_i=a_i-i\)</span>,显然<span
class="math inline">\(b_1\geq 0,b_{s+1}\leq -1\)</span>，后者是因为<span
class="math inline">\(a_{s+1}-(s+1)\leq
s-(s+1)=-1\)</span>,此外显然<span
class="math inline">\(b_i-b_{i-1}=0\)</span>或<span
class="math inline">\(-1\)</span>,故<span
class="math inline">\(b_i-b_{i-1}\geq -1\)</span></p>
<p>由此序列b中一定存在一个-1,取最靠前的-1，记为<span
class="math inline">\(b_{i+1}\)</span>.它前面一定是<span
class="math inline">\(b_i=0\)</span>,故<span
class="math inline">\(a_i=a_{i+1}\)</span></p>
<p>这样我们就找到了一个合法的<span
class="math inline">\(i\)</span>,引理得证，故命题得证 Q.E.D</p>
<hr />
<p>这段证明还是非常玄妙(玄幻)的。当然它对于我们的方案构造也有帮助</p>
<p>WQS二分中有时候会存在要求为k，但是<span
class="math inline">\(k&gt;l,k&lt;r\)</span>且<span
class="math inline">\(l,r,k\)</span>在一条线段上的情况，这时候我们一般通过限定边数尽可能多/少来保证取到线段的端点。但是想要构造方案的话就会不知所措了</p>
<p>我们记答案斜率为mid,这条包含答案k的线段的端点为<span
class="math inline">\((l,f_l),(r,f_r)\)</span>,则<span
class="math inline">\(\forall i\in[l,r],f_i=f_l+mid*(i-l)\)</span></p>
<p>我们可以先把<span
class="math inline">\(l,r\)</span>对应的最优方案找出来，长度分别为<span
class="math inline">\(l,r\)</span>,那么按照上述证明中的构造方式我们得到长度为<span
class="math inline">\(k,l+r-k\)</span>的路径<span
class="math inline">\(R_1,R_2\)</span>,记其<strong>路径长度</strong>分别为<span
class="math inline">\(len(R_1)=a,len(R_2)=b\)</span>,有<span
class="math inline">\(a\geq f_l+mid*(k-l),b\geq
f_l+mid*(l+r-k-l)\)</span></p>
<p>且有<span
class="math inline">\(2f_l+mid*(k-l)+mid*(l+r-k-l)=2f_l+mid*(r-l)\leq
a+b\leq f_l+f_r=2f_l+mid*(r-l)\)</span></p>
<p>第二个不等号的原因见证明片段</p>
<p>发现<span class="math inline">\(a+b\)</span>被边界夹住了，故<span
class="math inline">\(a= f_l+mid*(k-l)\)</span>,由此a就是<span
class="math inline">\(f_{k}\)</span>,我们就得到了长度为k的构造方案</p>
<p>以上内容参考 <a target="_blank" rel="noopener" href="https://www.osti.gov/biblio/10146169">论文</a>
《The <em>d</em>-Edge Shortest-Path Problem for a Monge
Grapll》，以及APIO2021《决策单调性与四边形不等式》</p>
<hr />
<h5 id="wqs外层二分时的边界">WQS外层二分时的边界</h5>
<p>一般来说直接取<span
class="math inline">\([-inf,inf]\)</span>即可，或者稍微算一下卡住边界</p>
<p>不管是这样的</p>
<p><img src="https://s2.loli.net/2023/12/19/knMY3pRujfh4ZiU.png" srcset="/img/loadings.gif" lazyload alt="image-20230916170032830" style="zoom:60%;" /></p>
<p>还是这样的</p>
<p><img src="https://s2.loli.net/2023/12/19/irx2etJHF1LEcWR.png" srcset="/img/loadings.gif" lazyload alt="image-20230916170003304" style="zoom:60%;" /></p>
<p>只要边界范围足够就不会有问题。但是有一类分段问题，图像长这样</p>
<p><img src="https://s2.loli.net/2023/12/19/QXIrSU7uc1BfaWv.png" srcset="/img/loadings.gif" lazyload alt="image-20230916170405876" style="zoom:70%;" /></p>
<p>分段为0的时候，总价值为0，然后开始分段之后价值随分段减少。不考虑0的话，后面的一段也是满足凸函数的，那么这个对我们的边界会有影响吗？个人感觉没有，因为我们只要保证wqs二分之后在做最优决策的时候保证不让段数为0即可</p>
<p>比如这题就是这个情况<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF321E">CF321 E</a>
(在分治部分此题作为练习出现，当然它也可以WQS二分，毕竟它满足四边形不等式，而我们已经证明了该类问题的凸性)</p>
<p>那么到这里，理论部分就差不多完善了，我们就可以看看应用了</p>
<p>不妨就看看这题<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF321E">CF321
E</a></p>
<p>按照套路，我们外层枚举斜率，内层就是每一段的贡献要减去一个<span
class="math inline">\(mid\)</span>,问最优分段数及其对应的总贡献。dp式满足决策单调性，可以直接上单调队列，复杂度是<span
class="math inline">\(O(nlogn^2)\)</span>,外层<span
class="math inline">\(O(log)\)</span>,内层<span
class="math inline">\(O(nlog)\)</span>，可以看到比普通的<span
class="math inline">\(O(n^2log)\)</span>分治要优化了不少</p>
<p>code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> il inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">4010</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br>ll n,m;<br>ll mp[N][N];<br>ll cnt[N];<br>ll sum[N][N];<br>ll dp[N];<br>ll que[N];<br>ll ls[N],rs[N];<br>ll ANS;<br><span class="hljs-function">ll <span class="hljs-title">cal</span><span class="hljs-params">(ll l,ll r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//l+1-&gt;r</span><br>    <span class="hljs-keyword">return</span> sum[r][r]-sum[l][r]-sum[r][l]+sum[l][l];<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll k,ll x,ll val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> dp[k]+<span class="hljs-built_in">cal</span>(k,x)-val;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>    que[++tl]=<span class="hljs-number">0</span>;ls[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>,rs[<span class="hljs-number">0</span>]=n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cnt[i]=<span class="hljs-number">0</span>,ls[i]=rs[i]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;rs[que[hd]]&lt;i) hd++;<br>        dp[i]=<span class="hljs-built_in">gt</span>(que[hd],i,x);<br>        cnt[i]=cnt[que[hd]]+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">gt</span>(i,ls[que[tl]],x)&lt;<span class="hljs-built_in">gt</span>(que[tl],ls[que[tl]],x)) tl--;<br>        ll L=ls[que[tl]],R=n+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(L&lt;=R)<br>        &#123;<br>            ll mid=(L+R)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(i,mid,x)&lt;=<span class="hljs-built_in">gt</span>(que[tl],mid,x)) R=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> L=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;que[tl]&lt;&lt;&#x27; &#x27;&lt;&lt;R+1&lt;&lt;&quot; &quot;&lt;&lt;gt(i,R+1,x)&lt;&lt;&quot; &quot;&lt;&lt;gt()</span><br>        ll p_ans=R+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(p_ans&gt;n) <span class="hljs-keyword">continue</span>;<br>        rs[que[tl]]=p_ans<span class="hljs-number">-1</span>;<br>        que[++tl]=i;<br>        ls[i]=p_ans,rs[i]=n;<br>    &#125;<br>    ANS=dp[n];<br><span class="hljs-comment">//     cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;cnt[n]&lt;&lt;&quot; &quot;&lt;&lt;ANS&lt;&lt;&quot; &quot;&lt;&lt;ANS+m*x&lt;&lt;endl;</span><br>    <span class="hljs-keyword">return</span> cnt[n]&gt;=m;<br>    <span class="hljs-comment">//尽可能分多段，尽可能选靠后的点转移</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)<br>        &#123;<br>            cin&gt;&gt;mp[i][j];<br>            <span class="hljs-keyword">if</span>(i&gt;j) mp[i][j]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)<br>        &#123;<br>            sum[i][j]=sum[i][j<span class="hljs-number">-1</span>]+sum[i<span class="hljs-number">-1</span>][j]+mp[i][j]-sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>        &#125;<br>    &#125;<br>    ll l=<span class="hljs-number">-1e18</span>,r=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;=r)<br>    &#123;<br>        ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(mid)) r=mid<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">judge</span>(r+<span class="hljs-number">1</span>);<br>    cout&lt;&lt;ANS+m*(r+<span class="hljs-number">1</span>)&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6246">IOI2000 邮局
加强版</a></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4072">SDOI2016
征途</a></p>
<p>套路都差不多，套一个WQS的事，内层看情况用不同的优化手段</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5308">Akvizna</a></p>
<p>你面临 <em>n</em> 名参赛者的挑战，最终要将他们全部战胜。
每一轮中，都会淘汰一些选手；你会得到这一轮奖金池中 被淘汰者 除以
这一轮对手总数 比例的奖金。</p>
<p>例如某一轮有 10 个对手，淘汰了 3 个，那么你将获得奖金池中 3/10
的奖金。</p>
<p>假设每一轮的奖金池均为一元，<code>Mirko</code> 希望通过恰好
<em>k</em> 轮赢得比赛，那么他最多可能获得多少奖金呢？</p>
<p>你只需要输出答案保留 9 位小数即可。</p>
<p>这题略阴间，二分的时候不枚举小数的话过不了，肥肠卡精度，不过思维难度一般</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-12</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-type">const</span> ll N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">double</span> dp[N];<br><span class="hljs-type">double</span> ANS;<br><span class="hljs-type">double</span> inv[N];<br>ll cnt[N];<span class="hljs-comment">//分的段数</span><br>ll que[N];<br>ll ls[N],rs[N];<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">gt</span><span class="hljs-params">(ll k,ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> dp[k]+(<span class="hljs-type">double</span>)((x-k)*<span class="hljs-number">1.0</span>*inv[n-k]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>    que[++tl]=<span class="hljs-number">0</span>;ls[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>,rs[<span class="hljs-number">0</span>]=n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cnt[i]=<span class="hljs-number">0</span>,ls[i]=rs[i]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;rs[que[hd]]&lt;i) hd++;<br>        cnt[i]=cnt[que[hd]]+<span class="hljs-number">1</span>;<br>        dp[i]=<span class="hljs-built_in">gt</span>(que[hd],i)-x;<br>        <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;que[hd]&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i]&lt;&lt;endl;</span><br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">gt</span>(i,ls[que[tl]])&gt;=<span class="hljs-built_in">gt</span>(que[tl],ls[que[tl]])) tl--;<br>        ll L=ls[que[tl]],R=n+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(L&lt;=R)<br>        &#123;<br>            ll mid=(L+R)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(i,mid)&gt;=<span class="hljs-built_in">gt</span>(que[tl],mid)) R=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> L=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        ll p_ans=R+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(p_ans&gt;n) <span class="hljs-keyword">continue</span>;<br>        rs[que[tl]]=p_ans<span class="hljs-number">-1</span>;<br>        que[++tl]=i;<br>        ls[i]=p_ans,rs[i]=n;<br>    &#125;<br>    ANS=dp[n];<br>    <span class="hljs-comment">// cout&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;cnt[n]&lt;&lt;&#x27; &#x27;&lt;&lt;ANS&lt;&lt;&#x27; &#x27;&lt;&lt;ANS+m*x&lt;&lt;endl;</span><br>    <span class="hljs-keyword">return</span> cnt[n]&lt;=m;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) inv[i]=<span class="hljs-number">1.0</span>/(i*<span class="hljs-number">1.0</span>);<br>    <span class="hljs-comment">// for(int i=1;i&lt;=n;++i)</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     for(int j=1;j&lt;=min(i,m);++j)</span><br>    <span class="hljs-comment">//     &#123;</span><br>    <span class="hljs-comment">//         for(int k=j-1;k&lt;i;++k)</span><br>    <span class="hljs-comment">//         &#123;</span><br>    <span class="hljs-comment">//             dp[i][j]=max(dp[i][j],dp[k][j-1]+(double)((i-k)*1.0/(n-k)));</span><br>    <span class="hljs-comment">//         &#125;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// judge(0);</span><br>    <span class="hljs-comment">// for(double i=-2;i&lt;=2;i+=0.1) judge(i);</span><br>    <span class="hljs-type">double</span> l=<span class="hljs-number">-100</span>,r=<span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">while</span>(l+eps&lt;=r)<br>    &#123;<br>        <span class="hljs-type">double</span> mid=(l+r)/<span class="hljs-number">2.0</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(mid)) r=mid;<br>        <span class="hljs-keyword">else</span> l=mid;<br>    &#125;<br>    <span class="hljs-built_in">judge</span>(r);<br>    <span class="hljs-comment">// cout&lt;&lt;r+1&lt;&lt;endl;</span><br>    cout&lt;&lt;fixed&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">9</span>)&lt;&lt;ANS+m*<span class="hljs-number">1.0</span>*(r)&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h5 id="tips">Tips：</h5>
<p>做WQS二分一定要注意问题函数是一个上凸包还是下凸包</p>
<p>注意左右边界</p>
<p>有时候也是也是要二分小数的！</p>
<h4 id="斜率优化">斜率优化</h4>
<p>基本的斜率优化本人已经在<a
target="_blank" rel="noopener" href="https://blog.csdn.net/sophilex/article/details/132634582?spm=1001.2014.3001.5502">另一篇博客</a>中讲的很详细了，从入门到精通应该都有了。</p>
<p>然后更多的应用大概就是与WQS二分结合了吧</p>
<p>注意点好像也没啥，毕竟WQS二分之后内部就是一个纯纯的一维dp</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4072">SDOI2016
征途</a></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5308">Akvizna</a></p>
<p>值得一提的还有这道题<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5504">JSOI2001 柠檬</a></p>
<p>之前在二分栈里提过它，但其实它也可以用斜率优化做，但是因为斜率实际上是递减的，所以内部维护凸包的时候是用一个栈（因为最优点在最后了，放入点也是在最后），这个还是比较少见的</p>
<p>code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ld long double</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IL inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">100010</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">998244353</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> X=<span class="hljs-number">0</span>; <span class="hljs-type">bool</span> flag=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">0</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="hljs-number">1</span>)+(X&lt;&lt;<span class="hljs-number">3</span>)+ch-<span class="hljs-string">&#x27;0&#x27;</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> X;<br>    <span class="hljs-keyword">return</span> ~(X<span class="hljs-number">-1</span>);<br>&#125;<br>ll n,a;<br>ll dp[N];<br>vector&lt;ll&gt; col[N],st[N];<span class="hljs-comment">//栈</span><br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll x,ll c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> dp[col[c][x]<span class="hljs-number">-1</span>]+c*x*x<span class="hljs-number">-2</span>*x*c;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Slope</span><span class="hljs-params">(ll a,ll b,ll col)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a==b) <span class="hljs-keyword">return</span> inf;<br>    <span class="hljs-type">double</span> x=<span class="hljs-built_in">gt</span>(a,col)-<span class="hljs-built_in">gt</span>(b,col);x=x*<span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">double</span> y=a-b;y*=<span class="hljs-number">1.0</span>;<br>    <span class="hljs-keyword">return</span> x/y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10000</span>;++i) col[i].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;a;<br>        ll len=col[a].<span class="hljs-built_in">size</span>();<br>        col[a].<span class="hljs-built_in">push_back</span>(i);<span class="hljs-comment">//放入id</span><br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">1</span>) st[a].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//st存的是横坐标（颜色前缀和）</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//维护上凸包</span><br>            <span class="hljs-keyword">while</span>(st[a].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;<span class="hljs-built_in">Slope</span>(st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>],st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>],a)&lt;=<span class="hljs-number">2</span>*a*len) st[a].<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//sum_i=len</span><br>            ll id=st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>            dp[i]=dp[col[a][id]<span class="hljs-number">-1</span>]+a*(<span class="hljs-number">1</span>+len-id)*(<span class="hljs-number">1</span>+len-id);<br>            <span class="hljs-keyword">while</span>(st[a].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;<span class="hljs-built_in">Slope</span>(st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>],st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>],a)&lt;=<span class="hljs-built_in">Slope</span>(st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>],len,a)) st[a].<span class="hljs-built_in">pop_back</span>();<br>            st[a].<span class="hljs-built_in">push_back</span>(len);<br>        &#125;<br>        dp[i]=<span class="hljs-built_in">max</span>(dp[i],dp[i<span class="hljs-number">-1</span>]+a);<br>    &#125;<br>    cout&lt;&lt;dp[n]&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// ll t;t=read();while(t--)</span><br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="一些特殊情况">一些特殊情况</h4>
<p>可以看到，如果题目已经有了决策单调性，大部分情况下还是比较套路的，但是有些时候问题在全局上不满足决策单调性并不意味着局部也没有。</p>
<p>还是<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5504">JSOI2001
柠檬</a>这道题，它就是在同种颜色内部满足决策单调性（这么一看这真是道好题啊，哪哪都这么与众不同）</p>
<p>以及<a target="_blank" rel="noopener" href="https://codeforces.com/gym/101002/attachments">2016NAIP
H</a></p>
<p>大意：</p>
<p>有n个物品，每个物品有一个体积<span
class="math inline">\(w_i\)</span>和价值<span
class="math inline">\(v_i\)</span>，现在要求对<span
class="math inline">\(V∈[1,m]\)</span>，求出体积为<span
class="math inline">\(V\)</span>的 背包能够装下的最大价值</p>
<p><span
class="math inline">\(1≤n≤1000000;1≤m≤100000;1≤w_i≤300;1≤v_i≤10^9\)</span></p>
<p>其实就是对每一个<span
class="math inline">\(V\)</span>，做一个多重背包</p>
<p>思路：</p>
<p>发现每一个物品的体积都比较小，所以可以按照体积分类。那么对于同一种体积的物品，我们肯定贪心选择价值最大的，所以可以排个序</p>
<p>考虑<span class="math inline">\(dp_{i,j}\)</span>表示使用体积<span
class="math inline">\(\leq
i\)</span>的物品，总体积为j的最大价值。我们可以将所有需要更新的体积按照%i来重新编号。比如当前i是2，m是9，我们就可以将<span
class="math inline">\(0,2,4,6,8\)</span>化为一类各自重新编号为<span
class="math inline">\(0,1,2,3,4\)</span>，<span
class="math inline">\(1,3,5,7,9\)</span>划为一类，编号同理</p>
<p>这样的好处就是我们对于每一个i，j的范围也只有<span
class="math inline">\([0,i]\)</span>这么大了，以及同一组体积内部的差恰好为i，那么物品就可以直接按照价值大小贪心塞了。</p>
<p>那么此时dp的意义就变了。如果当前是在更新%i=a的体积，则<span
class="math inline">\(dp_{i,j}\)</span>表示使用体积<span
class="math inline">\(\leq i\)</span>的物品，总体积为<span
class="math inline">\(j*i+a\)</span>的最大值</p>
<p>%i=a时，<span class="math inline">\(dp_{i,j}=max_{k\leq
j}\{dp_{i-1,k}+w(k,j)\}\)</span>,其中<span
class="math inline">\(w(k,j)\)</span>表示体积=i的物品中最大的<span
class="math inline">\(j-k\)</span>个物品的价值和，记为前缀和<span
class="math inline">\(vt_{i,j-k}\)</span></p>
<p>简单证一下四边形不等式:</p>
<p>考虑<span class="math inline">\(i,i+1,j,j+1,i+1&lt;j\)</span></p>
<p><span class="math inline">\(w(i,j)+w(i+1,j+1)=2vt_{j-i}\)</span></p>
<p><span
class="math inline">\(w(i+1,j)+w(i,j+1)=vt_{j-i-1}+vt_{j-i+1}=2vt_{j-i}+a_{j-i+1}-a_{j-i-1}\leq
w(i,j)+w(i+1,j+1)\)</span></p>
<p>得证</p>
<p>那么直接分治即可</p>
<p>code</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-11</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-type">const</span> ll N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br>ll n,m;<br>vector&lt;ll&gt; vt[<span class="hljs-number">310</span>];<br>ll dp[N],pp[N];<br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll id,ll x,ll mod,ll res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> pp[id*mod+res]+vt[mod][x-id<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(ll a,ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a&gt;b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solve</span><span class="hljs-params">(ll l,ll r,ll pl,ll pr,ll mod,ll res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span>;<br>    ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    ll pos=mid;<br>    dp[mid*mod+res]=pp[mid*mod+res];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">min</span>(mid<span class="hljs-number">-1</span>,pr);i&gt;=pl;--i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(mid-i&gt;(<span class="hljs-type">int</span>)vt[mod].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(i,mid,mod,res)&gt;dp[mid*mod+res]) dp[mid*mod+res]=<span class="hljs-built_in">gt</span>(pos=i,mid,mod,res);<br>    &#125;<br>    <span class="hljs-built_in">Solve</span>(l,mid<span class="hljs-number">-1</span>,pl,pos,mod,res);<br>    <span class="hljs-built_in">Solve</span>(mid+<span class="hljs-number">1</span>,r,pos,pr,mod,res);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        ll a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        vt[a].<span class="hljs-built_in">push_back</span>(b);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">300</span>;++i)<br>    &#123;<br>        <span class="hljs-built_in">sort</span>(vt[i].<span class="hljs-built_in">begin</span>(),vt[i].<span class="hljs-built_in">end</span>(),cmp);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;(<span class="hljs-type">int</span>)vt[i].<span class="hljs-built_in">size</span>();++j) vt[i][j]+=vt[i][j<span class="hljs-number">-1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">300</span>;++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!vt[i].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//枚举物品体积的类别</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;++j)<br>        &#123;<br>            <span class="hljs-comment">//枚举%i=j的体积</span><br>            <span class="hljs-built_in">Solve</span>(<span class="hljs-number">0</span>,(m-j)/i,<span class="hljs-number">0</span>,(m-j)/i,i,j);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j<span class="hljs-number">-1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) pp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) cout&lt;&lt;pp[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>本来想用SMAWK写的，但是一直MLE，不懂，求懂的佬教教</p>
<p>当然这题的决策单调性也是分组才有的，很抽象，感觉本人是不可能看出来的（哭</p>
<p>总结：</p>
<p>大工程，希望对自己&amp;大家有用:heartpulse:</p>
<p>参考文章</p>
<p><a target="_blank" rel="noopener" href="https://oi-wiki.org/">OIWIKI</a></p>
<p><a target="_blank" rel="noopener" href="https://www.osti.gov/biblio/10146169">Bein, W W, Larmore, L
L, and Park, J K. <em>The d-edge shortest-path problem for a Monge
graph</em>. United States: N. p., 1992. Web.</a></p>
<p><a target="_blank" rel="noopener" href="https://www.osti.gov/biblio/10175042">Bein, W W, Brucker, P,
and Park, J K. <em>Applications of an algebraic Monge property</em>.
United States: N. p., 1993. Web.</a></p>
<p><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/command-block/dp-di-jue-ce-dan-diao-xing-you-hua-zong-jie">DP的决策单调性优化总结</a></p>
<p><a
target="_blank" rel="noopener" href="https://cp-algorithms.com/dynamic_programming/divide-and-conquer-dp.html">Divide
and Conquer DP</a></p>
<p><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/MCAdam/jue-ce-dan-diao-xing">决策单调性
- MCAdam</a></p>
<p><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/flashblog/solution-p1912">关于决策单调性与图像的结合</a></p>
<p>彭思进 《决策单调性与四边形不等式》</p>
<p>[CF802 O] (https://www.luogu.com.cn/problem/CF802O)
Wqs二分+反悔贪心</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="category-chain-item">动态规划</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="print-no-link">#学习笔记</a>
      
        <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="print-no-link">#动态规划</a>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/" class="print-no-link">#算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>各类基于决策单调性的dp优化</div>
      <div>https://sophilex.github.io/2023/12/19/各类基于决策单调性的dp优化/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Sophilex</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年12月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/12/19/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8D%9A%E5%BC%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="二分图博弈学习笔记">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">二分图博弈学习笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/12/19/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp%E6%80%BB%E7%BB%93/" title="斜率优化dp总结">
                        <span class="hidden-mobile">斜率优化dp总结</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      京ICP证123456号
    </a>
  </span>
  
    
      <span>
        <a
          href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
          rel="nofollow noopener"
          class="beian-police"
          target="_blank"
        >
          
            <span style="visibility: hidden; width: 0">|</span>
            <img src="/img/police_beian.png" srcset="/img/loadings.gif" lazyload alt="police-icon"/>
          
          <span>京公网安备12345678号</span>
        </a>
      </span>
    
  
</div>

  
  
</div>
<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("12/18/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>


  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
