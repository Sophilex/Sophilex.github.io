<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Dilworth 定理</title>
    <link href="/2024/05/25/%E5%AE%9A%E7%90%86/"/>
    <url>/2024/05/25/%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="偏序集">偏序集</h2><p>偏序集是由集合<spanclass="math inline">\(S\)</span>以及其上的一个偏序关系<spanclass="math inline">\(R\)</span>定义的，记为<spanclass="math inline">\((S,R)\)</span></p><h3 id="偏序关系">偏序关系：</h3><p>对于一个二元关系<span class="math inline">\(R\subset S\timesS\)</span>,如果其满足： * <span class="math inline">\(\forall x\inS,xRx\)</span> <strong>自反性</strong> * <spanclass="math inline">\(\forall x,y\in S\)</span>,若<spanclass="math inline">\(xRy\)</span>且<spanclass="math inline">\(yRx\)</span>,则<spanclass="math inline">\(x=y\)</span> <strong>反对称性</strong> * <spanclass="math inline">\(xRy,yRz\rightarrow xRz\)</span><strong>传递性</strong> 显然自然数集<spanclass="math inline">\(N\)</span>以及最常见的小于等于关系<spanclass="math inline">\(\leq\)</span>,<spanclass="math inline">\((N,\leq)\)</span>就构成了一个偏序集 事实上<spanclass="math inline">\((N^*,|)\)</span>也是一个偏序集，其中<spanclass="math inline">\(|\)</span>表示正整数的整除关系</p><p>以下为了讨论方便，我们将<spanclass="math inline">\(R\)</span>简记为<spanclass="math inline">\(\leq\)</span>,当然它可以指代小于等于关系之外的其它关系</p><p>此外，<span class="math inline">\(\forall x,y\in S\)</span>,如果<spanclass="math inline">\(x\leq y\)</span>或<spanclass="math inline">\(y\leqx\)</span>，那么我们就说它们是<strong>可比</strong>的，否则说它们是<strong>不可比</strong>的</p><p>定义完了偏序集，我们可以从图上来看看它具体的样子</p><h2 id="哈斯图hasse-图">哈斯图(Hasse 图)</h2><p>考虑一个偏序集<span class="math inline">\((S,\leq)\)</span>,<spanclass="math inline">\(\forall x,y\in S\)</span>,如果<spanclass="math inline">\(x\leq y\)</span>且不存在<spanclass="math inline">\(z\ S.T. \ x\leq z\leq y\)</span>,我们称为<spanclass="math inline">\(y\)</span>覆盖<spanclass="math inline">\(x\)</span>,那么此时我们就连一条从<spanclass="math inline">\(x\)</span>指向<spanclass="math inline">\(y\)</span>的有向边，最后得到的图就称为这个偏序集<spanclass="math inline">\((S,\leq)\)</span>的Hasse图</p><p>比如下图是<spanclass="math inline">\({x,y,z}\)</span>的幂集关于包含关系得到的Hasse图<img src="https://s2.loli.net/2024/05/24/RbtO1csLZlwU3me.png"alt="image.png|370" /></p><p>由于偏序关系满足了反对称性，所以Hasse图里面一定没有自环（否则就会合并成一个点），所以我们可以说<strong>Hasse图一定是一张DAG</strong></p><h2 id="其它偏序集的前置芝士">其它偏序集的前置芝士</h2><p>还是记我们要讨论的偏序集为<spanclass="math inline">\((S,\leq)\)</span></p><p><strong>链</strong>： 偏序集中的一个全序子集。形式化地说，若集合<spanclass="math inline">\(C\subset S\)</span>,且<spanclass="math inline">\(\forall a,b\in C\)</span>,<spanclass="math inline">\(a,b\)</span>是可比的，那么<spanclass="math inline">\(C\)</span>就是<spanclass="math inline">\(S\)</span>的一个链链这个名字起的就很有水平，因为我们不难发现，偏序集中的一个全序子集，其在Hasse图中<strong>似乎</strong>就一定表现为一条链。比如上图中的<spanclass="math inline">\(\{\{x,y,z\},\{x,z\},\{x\},\{\phi\}\}\)</span>就是一个全序子集，在图中刚好也表现成一条链。但我没有严格证明，这边搁置。类似地，我们定义一个反链 <strong>反链</strong>： 若集合<spanclass="math inline">\(C\subset S\)</span>,且<spanclass="math inline">\(\forall a,b\in C\)</span>,<spanclass="math inline">\(a,b\)</span>是不可比的，那么<spanclass="math inline">\(C\)</span>就是<spanclass="math inline">\(S\)</span>的一个反链 在图上看的话，<spanclass="math inline">\(\{\{x\},\{y\},\{z\}\}\)</span>就是一个反链</p><p><strong>深度</strong>: 最长链大小</p><p><strong>宽度</strong>： 最长反链大小</p><p>以上两个定义也是相当的形象。因为我们不难发现，如果把Hasse图按照偏序关系从低到高排列的话，链在图中往往就是一条竖着的，而反链是横着的，由此给出如上定义</p><p><strong>最小链划分</strong>： 将集合<spanclass="math inline">\(S\)</span>划分为最少的若干个不相交的链</p><p><strong>最小反链划分</strong>： 将集合<spanclass="math inline">\(S\)</span>划分为最少的若干个不相交的反链</p><h2 id="dilworth-定理">Dilworth 定理</h2><p>现在可以给出Dilworth 定理的具体内容了</p><blockquote><p>Lemma1对于任意<font color='red'>有限</font>偏序集，其<strong>最长反链大小</strong>必等于<strong>最小链划分中链的数目</strong>其对偶形式也成立： Lemma2对于任意<font color='red'>有限</font>偏序集，其<strong>最长链大小</strong>必等于其<strong>最小反链划分中反链的数目</strong></p></blockquote><p><strong>以下讨论均假定偏序集有限</strong></p><p>总结以下： 最小链划分 = 最长反链大小 = 偏序集宽度 最小反链划分 =最长链大小 = 偏序集深度</p><p><font color='green'>先来证Lemma2：</font></p><p>记定理中的最长链大小为n，我们对n做数学归纳法 显然n=1时定理成立若n=k时定理成立，我们来证 n=k+1时定理成立此时偏序集中的最长链长度为k+1,我们取出集合<spanclass="math inline">\(S\)</span>的所有极大元，组成集合<spanclass="math inline">\(M\)</span>,显然<spanclass="math inline">\(M\)</span>是一个反链，并且考虑<spanclass="math inline">\(S-M\)</span>,其最大链长一定为k（因为取出了所有的极大元），根据之前的归纳假设，<spanclass="math inline">\(S-M\)</span>的最小反链划分数目为k，再加上M自己是一个反链，从而此时S的最小反链划分数为 k+1 = 最长链长度<span class="math inline">\(\square\)</span></p><p><font color='green'>再来看Lemma1：</font></p><p>考虑偏序集<span class="math inline">\((S,\leq)\)</span>,记<spanclass="math inline">\(|S|=m\)</span>，我们对m进行归纳 <spanclass="math inline">\(m=1\)</span>时Lemma1显然成立 若<spanclass="math inline">\(m=k\)</span>时定理成立，我们来证<spanclass="math inline">\(m=k+1\)</span>时定理成立:</p><p>设<span class="math inline">\(A\)</span>是集合<spanclass="math inline">\(S\)</span>的一条最长反链，记为 <spanclass="math display">\[A = \{a_1,a_2,...a_w\}\]</span> 其中<span class="math inline">\(|A|=w\)</span> 我们取 <spanclass="math display">\[D(A) = \{x\notin A|\exists \alpha \in S,x\leq a\}\]</span> <span class="math display">\[U(A) = \{x\notin A|\exists \alpha \in S,a\leq x\}\]</span> 显然<span class="math inline">\(D(A)\bigcup U(A)\bigcup A =S\)</span></p><p>若存在最长反链<span class="math inline">\(A\)</span>使得<spanclass="math inline">\(D(A),U(A)\)</span>均非空： <spanclass="math inline">\(A\)</span>是<spanclass="math inline">\(S\)</span>的最长反链，故<spanclass="math inline">\(A\)</span>也是<span class="math inline">\(A\bigcupD(A)\)</span>的一个最长反链。注意到<spanclass="math inline">\(|U(A)|\geq 1\)</span>,故<spanclass="math inline">\(|A\bigcup D(A)|\leqk\)</span>，从而由归纳假设，<span class="math inline">\(A\bigcupU(A)\)</span>可以划分为<span class="math inline">\(w\)</span>条链<spanclass="math inline">\(c_1,c_2,...c_w\)</span>，其中<spanclass="math inline">\(c_i\)</span>的极大元是<spanclass="math inline">\(a_i\)</span>.(这一点显然) 同理，<spanclass="math inline">\(A\bigcup D(A)\)</span>也可以划分为<spanclass="math inline">\(w\)</span>条链<spanclass="math inline">\(d_1,d_2,...d_w\)</span>,其中<spanclass="math inline">\(d_i\)</span>的极小元是<spanclass="math inline">\(a_i\)</span> 从而，我们就可以将<spanclass="math inline">\(S\)</span>划分为<spanclass="math inline">\(w\)</span>条链：<spanclass="math inline">\(c_1\cup d_1,....c_w\cup d_w\)</span></p><p>若对于任意最长反链<span class="math inline">\(A\)</span>,都有<spanclass="math inline">\(D(A)=\phi\)</span>或<spanclass="math inline">\(U(A)=\phi\)</span> 由假设，任一条反链<spanclass="math inline">\(A\)</span>必定构成全上界或者全下界。在<spanclass="math inline">\(S\)</span>中选一个极大元<spanclass="math inline">\(y\)</span>,再选一个极小元<spanclass="math inline">\(x\)</span>满足<span class="math inline">\(x\leqy\)</span>,<span class="math inline">\(\{x,y\}\)</span>构成一条链<spanclass="math inline">\(C\)</span>,从而在集合<spanclass="math inline">\(S-C\)</span>中，任一条最长反链的大小为<spanclass="math inline">\(w-1\)</span>（必定去除了一个元素），从而根据归纳假设，<spanclass="math inline">\(S-C\)</span>的最小链划分数为<spanclass="math inline">\(w-1\)</span>,再加上<spanclass="math inline">\(C\)</span>自己是一条链，故<spanclass="math inline">\(S\)</span>的最小链划分数为<spanclass="math inline">\(w\)</span></p><p><span class="math inline">\(\square\)</span> ### 应用举例</p><p>求一个序列的最大非递增序列长度以及其最少可以划分为多少个非递增序列</p><p>考虑由(位置，元素大小)这个二元组组成的集合，再定义一个偏序关系<spanclass="math inline">\(&lt;\)</span>: <spanclass="math inline">\(a&lt;b\)</span>当且仅当 <spanclass="math inline">\(a\)</span>的位置&lt;<spanclass="math inline">\(b\)</span>的位置且<spanclass="math inline">\(a\)</span>的值<spanclass="math inline">\(&lt;b\)</span>的值</p><p>从而这就构成了一个偏序集<spanclass="math inline">\((s,&lt;)\)</span>,并且要求的分别就是集合的最长反链以及最小反链划分数第一个问题可以直接dp即可，第二个问题，根据Dilworth定理，实际上就是求偏序集的最长链大小，实际上也就是序列的LIS，非常妙的一个转化。</p><h2 id="与dag">与DAG</h2><p>之前说过，Hasse图就是一个DAG，而反过来，我们将DAG的点作为集合<spanclass="math inline">\(S\)</span>的元素，将偏序关系<spanclass="math inline">\(\leq\)</span>定义为点之间的可达性，就定义了一个偏序集<spanclass="math inline">\((S,\leq)\)</span>从而DAG上的最小可重路径覆盖（要求覆盖所有点）就等价于偏序集<spanclass="math inline">\((S,\leq)\)</span>上的最小链覆盖</p><p>同理，将DAG上的有向边作为集合<spanclass="math inline">\(T\)</span>的元素，将偏序关系<spanclass="math inline">\(\leq&#39;\)</span>定义为边之间的可达性，就得到的另一个偏序集<spanclass="math inline">\((T,\leq&#39;)\)</span>从而DAG上的最小可重路径覆盖(要求覆盖所有<strong>边</strong>)就等价于偏序集<spanclass="math inline">\((T,\leq&#39;)\)</span>上的最小链覆盖</p><h2 id="erdősszekeres-定理">Erdős–Szekeres 定理</h2><p>含至少<span class="math inline">\(rs+1\)</span>个元素的实数序列<spanclass="math inline">\(\{a\}\)</span>要么有一个长为<spanclass="math inline">\(r+1\)</span>的不下降子序列，要么有一个长为<spanclass="math inline">\(s+1\)</span> 的不上升子序列<font color='orange'>Proof:</font> 设序列长度为<spanclass="math inline">\(n\geq rs+1\)</span>,定义偏序集<spanclass="math inline">\(\{(i,a_i)\}_{i=1}^{n}\)</span>,其上的偏序关系<spanclass="math inline">\(\leq\)</span>定义为： <spanclass="math display">\[(i,a_i)\leq (j,a_i)\Leftrightarrow (i\leq j \ \wedge \ a_i\leq a_j)\]</span> 假设该偏序集的宽度<span class="math inline">\(\leqs\)</span>,则由Dilllworth定理可知其最小链覆盖数<spanclass="math inline">\(\leq s\)</span>,若这些链的长度都<spanclass="math inline">\(\leq r\)</span>,则总元素数<spanclass="math inline">\(\leq rs&lt; rs+1\leq n\)</span> 矛盾。 <spanclass="math inline">\(\square\)</span></p>]]></content>
    
    
    <categories>
      
      <category>组合数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>学习笔记</tag>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂想-抽奖问题平凡解</title>
    <link href="/2024/05/11/%E6%9D%82%E6%83%B3-%E6%8A%BD%E5%A5%96%E9%97%AE%E9%A2%98%E5%B9%B3%E5%87%A1%E8%A7%A3/"/>
    <url>/2024/05/11/%E6%9D%82%E6%83%B3-%E6%8A%BD%E5%A5%96%E9%97%AE%E9%A2%98%E5%B9%B3%E5%87%A1%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="background">Background</h2><p>复习概率论的时候看到了对抽奖问题的讨论，突然就想推一下平凡解</p><p>总共有<span class="math inline">\(n\)</span>张票，其中有<spanclass="math inline">\(k\)</span>张中奖，问第<spanclass="math inline">\(i\)</span>个来抽奖的人中奖的概率。</p><p>这应该算是一个最平凡的情形了吧</p><h2 id="solution">Solution</h2><p>整个概率空间可以被划分为<spanclass="math inline">\(k+1\)</span>个部分，第<spanclass="math inline">\(j\)</span>个部分<spanclass="math inline">\(S_j\)</span>表示前<spanclass="math inline">\(i-1\)</span>个人中了<spanclass="math inline">\(j\)</span>张</p><p>那么 <span class="math display">\[ans=\sum_{j=0}^{k} P(S_j)P(A|S_j)\]</span> 其中<span class="math inline">\(P(A)\)</span>表示第<spanclass="math inline">\(i\)</span>个人中奖</p><p>对于前<span class="math inline">\(i-1\)</span>个人中了<spanclass="math inline">\(j\)</span>张的情况，有方案数为 <spanclass="math display">\[cnt_j=\binom{k}{j}\binom{n-k}{i-1-j}(i-1)!\]</span> 所以 <span class="math display">\[P(S_j)=\frac{cnt_j}{\sum_t cnt_t}\]</span> 其中 <span class="math display">\[\sum_t cnt_t=(i-1)!\sum_t \binom{k}{j}\binom{n-k}{i-1-j}\]</span> 后面部分是一个范德蒙德卷积，从而 <span class="math display">\[\sum_t cnt_t=(i-1)!\binom{n}{i-1}\]</span> 从而 <span class="math display">\[\begin{flalign}ans=&amp;\frac{1}{(i-1)!\binom{n}{i-1}}\sum_{j=0}^{k}cnt_jP(A|S_j)\\&amp;=\frac{1}{(i-1)!\binom{n}{i-1}}\sum_{j=0}^{k}\binom{k}{j}\binom{n-k}{i-1-j}(i-1)!\frac{k-j}{n-i+1}\\&amp;=\frac{k}{(n-i+1)\binom{n}{i-1}}\sum_{j=0}^{k}\binom{k-1}{j}\binom{n-k}{i-1-j}\\&amp;=\frac{k}{(n-i+1)\binom{n}{i-1}}\binom{n-1}{i-1}\\&amp;=\frac{k}{n-i+1}\frac{(i-1)!(n-i+1)!}{n!}\frac{(n-1)!}{(i-1)!(n-i)!}\\&amp;=\frac{k}{n}\end{flalign}\]</span> 从而中奖概率确实与抽奖顺序无关</p><p>over</p><p>（久违的推式子环节，真是太舒服了~)</p><p>update：</p><p>队友给出了一个更加优雅的解法：</p><p>考虑数学归纳法：</p><p>第一个人中奖的概率显然为<spanclass="math inline">\(\frac{k}{n}\)</span></p><p>假设对于第<spanclass="math inline">\(j\)</span>个人，他中奖的概率也为<spanclass="math inline">\(\frac{k}{n}\)</span>,我们来证对于第<spanclass="math inline">\(j+1\)</span>个人，其中奖的概率也为<spanclass="math inline">\(\frac{k}{n}\)</span></p><p>其中奖的概率为 <span class="math display">\[P_{j+1}=\sum_{i=0}^{p}\binom{p}{i}(\frac{k}{n})^i(\frac{n-k}{n})^{p-i}\frac{k-i}{n-j}\\其中p=min(k,j)\]</span> 这里将<span class="math inline">\(p\)</span>与<spanclass="math inline">\(j\)</span>做区分是因为中奖的人数最多只能有<spanclass="math inline">\(k\)</span>个</p><p>注意到式子中的<spanclass="math inline">\(\sum_{i=0}^{p}\binom{p}{i}(\frac{k}{n})^i(\frac{n-k}{n})^{p-i}\)</span>实际上就是一个伯努利分布，所以我们可以化为<span class="math display">\[\begin{flalign}P_{j+1}&amp;=\frac{k}{n-j}\sum_{i=0}^{p}\binom{p}{i}(\frac{k}{n})^i(\frac{n-k}{n})^{p-i}-\frac{1}{n-j}\sum_{i=0}^{p}\binom{p}{i}(\frac{k}{n})^i(\frac{n-k}{n})^{p-i}i\\&amp;=\frac{k}{n-j}-\frac{1}{n-j}\frac{k}{n}j\\&amp;=\frac{k}{n}\end{flalign}\]</span> 其中第二个式子实际上就是伯努利分布的期望</p><p>比我的证法短多了，思路也更加清晰。优雅，太优雅了！</p><p>over</p>]]></content>
    
    
    <categories>
      
      <category>杂想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LightGCN:简化和增强图卷积网络的推荐</title>
    <link href="/2024/04/01/%C2%96%C2%96%C2%96LightGCN-%E7%AE%80%E5%8C%96%E5%92%8C%E5%A2%9E%E5%BC%BA%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C%E7%9A%84%E6%8E%A8%E8%8D%90/"/>
    <url>/2024/04/01/%C2%96%C2%96%C2%96LightGCN-%E7%AE%80%E5%8C%96%E5%92%8C%E5%A2%9E%E5%BC%BA%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C%E7%9A%84%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<h1id="lightgcn简化和增强图卷积网络的推荐">LightGCN:简化和增强图卷积网络的推荐</h1><h2 id="abstract">Abstract</h2><p>图卷积网络 (GCN)已成为协同过滤的最新技术。然而，它推荐有效性的原因并没有得到很好的理解。该工作还发现GCN中最常见的两种设计——<strong>特征变换和非线性激活</strong>——对协同过滤的性能贡献不大，并且还增加了训练的难度，降低了推荐性能。在这项工作中，作者提出了一种新的模型LightGCN，只包含GCN中最基本的组件——<strong>邻域聚合</strong>。具体来说，LightGCN通过在用户-项目交互图上线性传播来学习用户和项目嵌入，并使用所有层学习到的嵌入的<strong>加权和</strong>作为最终嵌入。这种简单、线性和整洁的模型更容易实现和训练，与同一个组之前提出的NGCF相比，有明显的改进（平均约16.0% 的相对改进）。最后对LightGCN的合理性进行了分析。 本文的主要贡献：* 通过实验说明GCN中的非线性激活以及特征变换对协同过滤没有积极影响 *提出了LightGCN，结构更加简洁，并且性能更好 * 对LightGCN的合理性进行分析## NGCF 先简单介绍一下NGCF。NGCF主张在协同过滤中加入对user-item对信息的编码，而不仅仅是只考虑user，item的emmbedding，从而能够获得更多信息，进而进行推荐。实际场景中user-item对的信息很多，所以它借鉴了GCN中的领域聚合的思想，仿照GCN的结构，每一层聚合周围邻居的信息，从而在多层之后实现对多跳邻居的信息的收集。具体来说，每一层的信息传播公式为 <span class="math display">\[m_{u\leftarrowi}^{(l)}=\frac{1}{\sqrt{|N_u||N_i|}}(W_1^{(l)}e_i^{(l-1)}+W_2^{(l)}(e_i^{(l-1)}⊙e_u^{(l-1)}))\]</span> <span class="math display">\[m_{u\leftarrow u}^{(l)}=W_1^{(l)}e_u^{(l-1)}\]</span></p><p>这是对user而言的，item的传播公式同理 其中<spanclass="math inline">\(m_{u\leftarrow i}\)</span>表示<spanclass="math inline">\(item_i\)</span>与<spanclass="math inline">\(user_u\)</span>之间的协作信息，<spanclass="math inline">\(\frac{1}{\sqrt{|N_u||N_i|}}\)</span>借鉴了GCN的思路，不过作者在文中把它理解为信息的衰减系数，也就是当前信息应该随着层的传播而比重变小。考虑到自己到自己的信息不用衰减，所以第二个式子没有乘上对称归一化的系数。<spanclass="math inline">\(W_1,W_2\)</span>是可训练系数，<spanclass="math inline">\(e_i,e_u\)</span>就是item和user的当前特征embedding，最后加了一个<spanclass="math inline">\(e_i⊙e_u\)</span>,也就是两者的哈达玛积，用来编码两者的信息交互（有点像attention？）最后得到每一层的新的特征表示： <span class="math display">\[e_u^{(l)} = LeakyReLU(m_{u\leftarrow u}^{(l)}+\sum_{i\inN_u}m_{u\leftarrow i}^{(l)})\]</span>这是NGCF的基本结构。首先在embedding层获得每一个user，item的embedding，这里展示了<spanclass="math inline">\(e_{u_1}^{(0)}\)</span>以及<spanclass="math inline">\(e_{i_4}^{(0)}\)</span>的embedding。然后逐层传播并更新每一层的embedding，在最后一层将每一层的embedding进行<strong>拼接</strong>，然后拿去做预测。这里拼接应该也是为了进行特征增强，不过后面LightGCN也还是改掉了。<img src="https://s2.loli.net/2024/03/28/HnMszK8L3F6bJag.png" alt="image.png|475" style="zoom:67%;" /></p><h2 id="lightgcn">LightGCN</h2><p>可以看到NGCF其实大量借鉴了GCN的结构，但是其中也有一些操作是毫无理由就搬上来了。所以作者对其进行了大量的消融分析，包括对非线性激活和特征变化结构的质疑。作者建立了四个模型进行比较，分别是 * NGCF,也就是原模型 * NGCF-n去掉了特征变换，也就是上一节中的<spanclass="math inline">\(W_1,W_2\)</span>参数矩阵的NGCF * NGCF-f去掉了非线性激活的NGCF * NGCF-fn 去掉了特征变换以及非线性激活的NGCF然后在<span class="math inline">\(Gowalla\)</span>和<spanclass="math inline">\(Amazon-Book\)</span>数据集上进行测试，得到结果如下：<img src="https://s2.loli.net/2024/03/28/fIGPmyxuSr2KU1O.png" alt="image.png|850" style="zoom:150%;" />可以看出NGCF-fn的性能是远好于NGCF的，作者将这一点归因于特征变换以及非线性激活操作加大了训练的难度，从而提出对其进行简化，得到如下的传播公式<span class="math display">\[e_{u}^{(k+1)}=\sum_{i\in N_u}\frac{1}{\sqrt{|N_u||N_i|}}e_i^{(k+1)}\\e_{i}^{(k+1)}=\sum_{u\in N_i}\frac{1}{\sqrt{|N_u||N_i|}}e_u^{(k+1)}\]</span> 在最后一层进行每一层特征的加权求和得到最终特征 <spanclass="math display">\[e_u=\sum_{k=0}^{K}\alpha_ke_u^{(k)}\\e_i=\sum_{k=0}^{K}\alpha_ke_i^{(k)}\]</span> 最终得到user-item项目的最终得分为 <spanclass="math display">\[\hat{y}_{ui}=e_u^{T}e_i\]</span> 上面的式子不方便实现，我们将其转换为矩阵形式 假设user有<spanclass="math inline">\(N\)</span>个，item有<spanclass="math inline">\(M\)</span>个，每一个user/item的特征长度为<spanclass="math inline">\(T\)</span>,那么定义邻接矩阵<spanclass="math inline">\(A\inR^{(N+M)\times(N+M)}\)</span>表示user-item的邻接矩阵，矩阵<spanclass="math inline">\(E\in R^{(N+M)\timesT}\)</span>表示每一个user/item的embedding，显然<spanclass="math inline">\(E^{0}\)</span>就表示了大家的初始embedding。再定义矩阵<spanclass="math inline">\(D\in R^{(N+M)\times(N+M)}\)</span>表示度数矩阵。从而得到传播公式为 <span class="math display">\[E^{k+1} = (D^{-\frac{1}{2}}AD^{-\frac{1}{2}})E^{k}\]</span> 最终每一个user/item的embedding为 <span class="math display">\[E =\alpha_0E^{0}+\alpha_1E^{1}+....+\alpha_KE^{K}=\alpha_0E^{0}+\alpha_1\tilde{A}E^{0}+....+\alpha_K\tilde{A}^{K}E^{0}=\sum_{i=0}^{K}\alpha_i\tilde{A}^iE^0\]</span> 其中<spanclass="math inline">\(\tilde{A}=D^{-\frac{1}{2}}AD^{-\frac{1}{2}}\)</span></p><hr /><p>与NGCF的式子进行对比，可以发现LightGCN总共去掉了如下几个构造： *<strong>特征变换，非线性激活</strong> * <strong>自连接</strong> *<strong>user-item的哈达玛积</strong>对于哈达玛积的移除作者没有详细介绍，只是在后面实验时提了一嘴LightGCN效果比NGCF-fn效果更好，所以可能也没啥用，就移掉了。除此之外，在实现细节上，LightGCN相比GCN还有如下变化 *<strong>在最后一层将每一层特征的concat操作变成了加权求和</strong> *<strong>去掉了每一层的dropout操作</strong> ## 模型分析分析一下每一个操作的合理性 ### 加权求和与去除自连接作者去除自连接的原因与最后一步的加权求和有关系。注意到最后的特征表示为<span class="math display">\[E =\sum_{i=0}^{K}\alpha_i\tilde{A}^iE^0\]</span>这与之前的一些工作具有相同的形式，所以作者指出该模型同样可以享用它们的优点#### SGCN这是之前的一篇简化GCN的工作，它同样是去除了非线性激活函数，并且将每一层的权重矩阵简化成了一个，其传播公式为<span class="math display">\[E^{(k+1)}=(D+I)^{-\frac{1}{2}}(A+I)(D+I)^{-\frac{1}{2}}E^{k}\]</span>它包含了自连接操作，我们将其在式子中提取出来了，然后进行化简，得到 <spanclass="math display">\[E^{(k)}=(\tilde{A}+(D+I)^{-1})E^{k-1}=(\tilde{A}+(D+I)^{-1})^KE^{0}=(\tilde{A}+\tilde{D})^KE^0\]</span> 其中 <span class="math display">\[\tilde{A}=D^{-\frac{1}{2}}AD^{-\frac{1}{2}},\tilde{D}=(D+I)^{-1}\]</span> 对前面的系数二项展开，得到 <span class="math display">\[E^{(k)}=\binom{K}{0}\tilde{D}^KE^{0}+\binom{K}{1}\tilde{D}^{K-1}AE^{0}+...+\binom{K}{K}A^KE^{0}=\sum_{i=0}^{K}\binom{K}{i}\tilde{D}^{K-i}\tilde{A}^iE^0\]</span>没错，与LightGCN的式子相比还多了一个对角矩阵，形式上是不一样的。原文是用另一个方法推导的，省略了<spanclass="math inline">\((D+I)^{-\frac{1}{2}}\)</span>,理由是它只缩放了embedding，但是个人认为每一维的缩放系数不同，不能直接这样忽略。这里存疑。总之作者在这里得到结论是两个模型在结构上相同，所以没有添加自环也没有关系，实际效果上已经添加了。#### APPNP这个工作宣称可以在没有过度平滑的风险的情况下传播远程，其传播公式为 <spanclass="math display">\[E^{K}=\beta E^0+(1-\beta)\tilde{A}E^{K-1}\]</span> 显然这是一个可以求通项的式子，化简得到 <spanclass="math display">\[E^{K}=\beta E^0+(1-\beta)\tilde{A}E^{K-1}\\=\beta E^0+\beta(1-\beta)\tilde{A}E^{0}+(1-\beta)^2\tilde{A}^2E^{K-2}\\=\betaE^0+\beta(1-\beta)\tilde{A}E^{0}+(1-\beta)^2\tilde{A}^2E^{0}+...+(1-\beta)^K\tilde{A}^KE^0\]</span></p><p>注意到该式子与LightGCN的传播公式也就只有系数差别，所以LightGCN在减少过拟合方面有较好的效果，后面的实验也佐证了这一点</p><h3 id="去除哈达玛积">去除哈达玛积</h3><p>作者引入它是为了强调user-item的交互，有点类似attention，但是个人感觉模型已经是在gcn的基础上做改进了，而gcn的一个最大特点就是逐层聚合邻域信息，这一点本身就已经在实现信息的交互了，所以可能这也是在LightGCN中将其移除的原因吧</p><h3 id="去除dropout">去除dropout</h3><p>注意到LightGCN整个模型其实已经只有初始化embedding的一些矩阵参数了，每一层传播的时候是没有参数的了，所以也没有做dropout的必要了，<spanclass="math inline">\(L_2\)</span>正则化就足够保证避免过拟合了</p><h3 id="嵌入的平滑性">嵌入的平滑性</h3><p>我们考虑两个共享同一个item的节点的信息传递</p><p><span class="math display">\[e_u^{(2)}=\sum_{i\in N_u}\frac{1}{\sqrt{|N_u||N_i|}}e_i^{(1)}=\sum_{i\inN_u}\frac{1}{|N_i|}\sum_{v\in N_i}\frac{1}{\sqrt{|N_u||N_v|}}e_v^{(0)}\]</span> 注意到<span class="math inline">\(user_v\)</span>与<spanclass="math inline">\(user_u\)</span>之间的信息传递的系数为 <spanclass="math display">\[c_{v\rightarrow u}\frac{1}{\sqrt{|N_u||N_v|}}\sum_{i\in N_u\capN_v}\frac{1}{|N_i|}\]</span> 这一系数符合很多直观的想法，二阶邻居 v 对 u 的影响由 1)共同交互项目的数量、越大； 2)共同交互项目的流行程度越低（即更能指示用户个性化偏好）越大； 3) v的活动，越大越活跃。 这种可解释性很好地满足了 CF 在测量用户相似度中的假设，并证明了 LightGCN 的合理性。</p><h2 id="留的坑">留的坑</h2><p>作者在文末指出对<spanclass="math inline">\(\alpha_i\)</span>的个性化调节，即稀疏用户可能需要更多来自高阶邻居的信号，而活动用户只需要更少</p><h2 id="总结">总结</h2><p>总体来说，LightGCN在NGCF的基础上，指出特征变换与非线性激活在推荐模型上的冗余性，充分简化了其模型结构，并且提高了性能。但是这是建立在推荐的场景下，原始的GCN是用于节点分类的，此时每一个节点包含更多信息，而不是只有id信息，所以还是需要非线性激活与特征变换的。</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Attention-Machanism</title>
    <link href="/2024/03/13/Attention-Machanism/"/>
    <url>/2024/03/13/Attention-Machanism/</url>
    
    <content type="html"><![CDATA[<h1 id="attention-mechanism">Attention Mechanism</h1><p>现在给定一组数据，假设包含若干个 特征-值 对 <spanclass="math inline">\((Key,Value)\)</span>,那么现在我们拿着一个特征<spanclass="math inline">\(Query\)</span>,要如何利用这组数据确定一个合理的<spanclass="math inline">\(value\)</span>?有一些比较naive的想法，比如取最近邻的对应<spanclass="math inline">\(Value\)</span>,或者取较近的几个<spanclass="math inline">\(Key\)</span>,再拿它们的<spanclass="math inline">\(Value\)</span>做个平均啥的。这些想法有其合理性，并且都蕴含一个核心点就是：&gt;我们在尽可能地将注意力集中在与<spanclass="math inline">\(Query\)</span>相近的<spanclass="math inline">\(Key\)</span>对应的<spanclass="math inline">\(Value\)</span>上，因为这些<spanclass="math inline">\(Value\)</span>更大概率会与我们要确定的值更加接近</p><p>所以就有了<span class="math inline">\(Attention\  Mechanism\)</span>## 低维 我们首先在一维空间<spanclass="math inline">\(\mathbb{R}\)</span>下讨论这件事情。下面是一个非常直观的过程.我们有若干组<spanclass="math inline">\((Key_i,Value_i)\)</span>,以及一个查询<spanclass="math inline">\(Query\)</span>,我们的目标是得到<spanclass="math inline">\(Output\)</span>.首先我们会让<spanclass="math inline">\(Query\)</span>与各个<spanclass="math inline">\(Key_i\)</span>做一个<spanclass="math inline">\(a\)</span>运算，得到结果<spanclass="math inline">\(a(Query,Key_i)\)</span>,它表示<spanclass="math inline">\(Query\)</span>与<spanclass="math inline">\(Key_i\)</span>的相似程度，显然它与我们之后要在<spanclass="math inline">\(Key_i,Value_i\)</span>上投入的注意力大小成正比，我们就记为注意力评分函数(attentionscoring function).然后我们就拿<spanclass="math inline">\(a_i=a(Query,Key_i)\)</span>转换成概率分布<spanclass="math inline">\(s_i\)</span>,再与<spanclass="math inline">\(Value_i\)</span>相乘并求和得到 <spanclass="math display">\[Output = \sum_i s_iValue_i\]</span> 这就是最后的结果了。 这里<spanclass="math inline">\(a_i\)</span>到<spanclass="math inline">\(s_i\)</span>我们简单点，可以直接取 <spanclass="math display">\[s_i=\frac{a_i}{\sum_{j=1}^{n} a_j}\]</span>可以看到这个求法还是有一定的合理性的，因为它不仅考虑到了注意力要偏向重点，还考虑到了整体的数据，而不是像之前那样只关注一小部分。接下来还剩下一个问题，就是我们的注意力评分函数<spanclass="math inline">\(a(Query,Key_i)\)</span>要怎么算。一个方法就是可以使用核回归：这里我们核函数选择<span class="math inline">\(Gauss\)</span>核函数 <spanclass="math display">\[K(u)=\frac{1}{\sqrt{2\pi}}exp(-\frac{u^2}{2})\]</span> 从而<span class="math inline">\(u\)</span>就取<spanclass="math inline">\(Query-Key_i\)</span>,得到 <spanclass="math display">\[Output = \sum_i\frac{exp(-\frac{1}{2}(Query-Key_i)^2)}{\sum_jexp(-\frac{1}{2}(Query-Key_j)^2)}Value_i\]</span> 注意到第一个求和号里面其实就是一个softmax，从而 <spanclass="math display">\[Output = \sum_i softmax(-\frac{1}{2}(Query-Key_i)^2)Value_i\]</span>为了给整个模型加入一点可学习的东西，我们可以在softmax里面加入一个参数<spanclass="math inline">\(w\)</span>,得到 <span class="math display">\[Output = \sum_i softmax(-\frac{1}{2}(Query-Key_i)^2w)Value_i\]</span> 这就是最终结果了。</p><h2 id="高维">高维</h2><p>现在不管是<span class="math inline">\(Query,Key\)</span>还是<spanclass="math inline">\(Value\)</span>,都从原本的一维数据变成了高维的向量，然后我们再重新审视这个问题。下面这张图是非常形象的。<img src="https://s2.loli.net/2024/03/13/XigM7pTvh8AH2bu.png"alt="image-20240313151037340" /> 用一个函数<spanclass="math inline">\(f\)</span>来形式化地描述整个过程。有<spanclass="math inline">\(n\)</span>个键值对<spanclass="math inline">\(\boldsymbol{k_i}\in\mathbb{R}^k,\boldsymbol{v_i}\in \mathbb{R}^v\)</span>,给定一个查询<spanclass="math inline">\(\boldsymbol{q}\in \mathbb{R}^q:\)</span> <spanclass="math display">\[Output =f(\boldsymbol{q},(\boldsymbol{k_1},\boldsymbol{v_1}),\cdots,(\boldsymbol{k_n},\boldsymbol{v_n}))=\sum_{i=1}^{n}\alpha(\boldsymbol{q},\boldsymbol{k_i})\boldsymbol{v_i}\in\mathbb{R}^v\]</span> 其中 <span class="math display">\[\alpha(\boldsymbol{q,k_i})=\frac{exp(a(\boldsymbol{q,k_i}))}{\sum_{j=1}^{n}exp(a(\boldsymbol{q,k_j}))}\]</span>由于把核函数的一部分抽象成了softmax操作，所以在低维情况下我们的<spanclass="math inline">\(a(q,k_i)\)</span>函数实际对应的是<spanclass="math inline">\(-\frac{1}{2}(q-k_i)^2\)</span>而在高维向量情况下，我们有对<spanclass="math inline">\(a\)</span>一般有两种处理方式 ### 加性注意力一般来说，当查询和键<font color='red'>是不同长度的矢量时</font>，可以使用加性注意力作为评分函数。此时给定<spanclass="math inline">\(\boldsymbol{q}\in \mathbb{R}^q,\boldsymbol{k}\in\mathbb{R}^k\)</span>,有 <span class="math display">\[a(\boldsymbol{q,k})=\boldsymbol{w}_v^T\tanh(\boldsymbol{W}_q\boldsymbol{q+\boldsymbol{W}_k\boldsymbol{k}})\]</span> 其中<span class="math inline">\(\boldsymbol{W}_q\in\mathbb{R}^{h\times q},\boldsymbol{W}_k\in \mathbb{R}^{h\timesk},\boldsymbol{w}_v\in \mathbb{R}^{h}\)</span>都是可学习的参数，而<spanclass="math inline">\(h\)</span>是作为一个可以调整的超参数，tanh就是一个激活函数。仔细观察一下就是，括号里面将<spanclass="math inline">\(\boldsymbol{q}\)</span>和<spanclass="math inline">\(\boldsymbol{k}\)</span>都转化成了一个<spanclass="math inline">\(h\)</span>维向量，然后再与外面的<spanclass="math inline">\(\boldsymbol{w}_v^T\)</span>一乘，就得到了一个实数作为最终结果</p><h3 id="缩放点积注意力">缩放点积注意力</h3><p>当查询和键的长度相同时，我们就可以不必这么麻烦，把它们统一转化成一个长度的向量了。我们可以直接做向量内积，从而有<spanclass="math inline">\(\boldsymbol{q,k}\in \mathbb{R}^d\)</span>, <spanclass="math display">\[a(\boldsymbol{q},\boldsymbol{k})=\boldsymbol{q}^T\boldsymbol{k}\]</span> 但是这样其实有一个问题。因为我们的结果<spanclass="math inline">\(a(\boldsymbol{q},\boldsymbol{k})\)</span>是要拿去做softmax的，而softmax由于是由指数函数实现的，当指数差距过大时，概率的偏差就会变的极大，从而失去参考价值。所以我们可以统一除以一个<spanclass="math inline">\(\sqrt{d}\)</span>来减少差距,至于为什么是<spanclass="math inline">\(\sqrt{d}\)</span>,等我以后再细细研究...</p><p>以上都是考虑样本数为1的情况，实际情况中有多个样本，多个数据,记为查询<spanclass="math inline">\(\boldsymbol{Q}\in \mathbb{R}^{m\timesd}\)</span>,键值<span class="math inline">\(\boldsymbol{K}\in\mathbb{R}^{n\times d},\boldsymbol{V}\in \mathbb{R}^{n\timesv}\)</span>,就有</p><p><span class="math display">\[f=softmax(\frac{\boldsymbol{QK}^T}{\sqrt{d}})\boldsymbol{V}\in\mathbb{R}^{m \times v}\]</span> 这里softmax操作就是对每一行进行softmax操作的意思总体可以用这一张图表示 <imgsrc="https://s2.loli.net/2024/03/13/heWdDc7K4BqrwiL.png"alt="image.png|170" /> 首先<spanclass="math inline">\(\boldsymbol{Q,K}\)</span>做内积，然后放缩(除以<spanclass="math inline">\(\sqrt{d}\)</span>)，然后做softmax，最后与<spanclass="math inline">\(\boldsymbol{V}\)</span>点乘</p><h1 id="self-attention-mechanism">Self-Attention Mechanism</h1><p>说是叫self-attention，不过我觉得这里的self更多的应该是指一个集合本身，而不是集合中的某一个元素回忆一下Attention Mechanism：有<spanclass="math inline">\(m\)</span>个长度为<spanclass="math inline">\(d\)</span>的查询向量<spanclass="math inline">\(\boldsymbol{q_1,q_2,...q_n}\)</span>,就记为行向量好了，它们组成一个矩阵<spanclass="math inline">\(\boldsymbol{Q\in \mathbb{R}^{m\timesd}}\)</span>,同理有n个键行向量组成的矩阵<spanclass="math inline">\(\boldsymbol{K}\in \mathbb{R}^{n\timesd}\)</span>,以及<spanclass="math inline">\(n\)</span>个值行向量组成的矩阵<spanclass="math inline">\(\boldsymbol{V}\in \mathbb{R}^{n\times v}\)</span>&gt;（这里为了方便我们就只讨论查询向量与键值向量的长度相等的情况了，然后就直接用ScaledDot-Product Attention来处理了，另一种情况的处理显然也会是类似的）</p><p>然后就有结果矩阵 <span class="math display">\[f=softmax(\frac{\boldsymbol{QK}^T}{\sqrt{d}})\boldsymbol{V}\in\mathbb{R}^{m \times v}\]</span> 这里有几点要指出： * f的行大小是与<spanclass="math inline">\(Q\)</span>相同的，它相当于是对每一个询问行向量<spanclass="math inline">\(q_i\)</span>的所有特征进行了一个回答 *任意两个询问行向量<spanclass="math inline">\(q_i,q_j\)</span>之间是可以没有任何关系的，相当于<spanclass="math inline">\(m\)</span>次互不影响的询问那么自注意力机制就是在次基础上做的改进 --- 我们现在有<spanclass="math inline">\(m\)</span>个事物，它们是一个整体，<spanclass="math inline">\(m\)</span>个事物之间有可能某个集合的事物之间是包含一定的关系的。如果我们想只用这<spanclass="math inline">\(m\)</span>个事物的当前特征去做attention，得到一些信息，那么显然我们的查询矩阵<spanclass="math inline">\(\boldsymbol{Q}\)</span>的每一行就要取对应事物的特征。那么<spanclass="math inline">\(\boldsymbol{K,V}\)</span>呢?我们还是取这个集合内每一个事物的对应信息。相当于从集合内部的事物之间的隐含的关系来找到信息从而我们的<spanclass="math inline">\(\boldsymbol{Q,K,V}\)</span>的第<spanclass="math inline">\(i\)</span>个行向量来自第<spanclass="math inline">\(i\)</span>个事物的信息。为此我们需要引入<spanclass="math inline">\(\boldsymbol{W_q,W_k,W_v}\in \mathbb{R}^{d\timesb}\)</span>三个矩阵来提取信息，当然它们是可学习的,而这<spanclass="math inline">\(m\)</span>个事物本身的信息可以写成一个<spanclass="math inline">\(\boldsymbol{X}\in \mathbb{R}^{m\timesd}\)</span>,从而， <span class="math display">\[\boldsymbol{Q=XW_q,K=XW_k,V=XW_v}\]</span> 最后套用原本的attention机制，我们得到 <spanclass="math display">\[f=softmax(\frac{\boldsymbol{QK}^T}{\sqrt{d}})\boldsymbol{V}\in\mathbb{R}^{m \times d}\]</span> <spanclass="math inline">\(f\)</span>的每一个行向量就是第<spanclass="math inline">\(i\)</span>个事物从这n个事物当中提取到的信息了注意到自注意力机制与普通的注意力机制的区别就在于：它的信息来源是一个固定的集合，集合的每一个元素既为其它元素提供信息，也从其它元素那里提取信息。所以我在这一节的一开始说，<strong>self更多的应该是指一个集合本身，而不是集合中的某一个元素</strong>这样做的意义是：对于集合中的每一个元素<spanclass="math inline">\(a\)</span>,它可以从与它相近的其它元素中得到更多信息，而不仅仅是只有自己的信息</p><h1 id="multi-head-attention-mechanism">Multi-head AttentionMechanism</h1><p>注意到之前对于每一个事物，我们只用了一组矩阵<spanclass="math inline">\(W_q,Q_k,Q_v\)</span>来提取其特征。一个很自然的问题：这样提取够吗？会不会导致提取的信息不足？解决方案也很简单，那就多用几组<spanclass="math inline">\(W_q,Q_k,Q_v\)</span>来提取就好了，然后再把它们的结果放到一起，再拼在一起就可以啦。第<spanclass="math inline">\(i\)</span>组用的矩阵就是<spanclass="math inline">\(W_{q_i},Q_{k_i},Q_{v_i}\)</span>,不同组之间显然是可以并行计算的，互不影响。</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>环论</title>
    <link href="/2024/01/03/%E7%8E%AF%E8%AE%BA/"/>
    <url>/2024/01/03/%E7%8E%AF%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<table><thead><tr class="header"><th></th><th>子环</th><th>环同态</th><th>理想</th></tr></thead><tbody><tr class="odd"><td>单位元（乘法单位元）</td><td>环与子环的单位元无必然关系,即子环不一定有单位元，有也不一定和环的单位元相同比如<font color='red'><spanclass="math inline">\(Z_6\)</span>有单位元1，其子环<spanclass="math inline">\((2)\)</span>单位元为4;Z有单位元1，其子环2Z没有单位元</font></td><td>若R有单位元，则<spanclass="math inline">\(ImR\)</span>也有单位元，且<spanclass="math inline">\(ImR\)</span>的单位元为f(1)<font color='red'>(同态满射)</font></td><td>环与子环的单位元无必然关系。即子环不一定有单位元，有也不一定和环的单位元相同</td></tr><tr class="even"><td>零元（加法单位元）</td><td>保持存在且不变</td><td>保持存在且不变</td><td>保持存在且不变</td></tr><tr class="odd"><td>零因子</td><td>无关</td><td><font color='red'>同构映射下，零因子保持（若<spanclass="math inline">\(a\)</span>为<spanclass="math inline">\(G\)</span>的零因子，则<spanclass="math inline">\(F(a)为G&#39;\)</span>的零因子）</font>，但是在普通环同态下没啥关系</td><td>无关</td></tr></tbody></table><ul><li>零元保持不变是因为它是加法的单位元，而环<spanclass="math inline">\(R\)</span>关于加法是做成群的，众所周知群的性质是相当优秀的，无论在子群还是群同态下都保持单位元</li><li>理想一定是子环，只是在此基础上满足了强吸收性，所以子环的性质它都满足。</li></ul><h1 id="环的基本性质">环的基本性质</h1><h2 id="零因子">零因子：</h2><p>环<spanclass="math inline">\(R\)</span>中必定存在0元(关于加法的群的单位元),对于<span class="math display">\[a\neq 0\in R,若\exist b\neq 0,S.T. ab=0\]</span> 则<span class="math inline">\(a\)</span>是环<spanclass="math inline">\(R\)</span>的左零因子。同理可以定义环<spanclass="math inline">\(R\)</span>的右零因子。</p><p>若<span class="math inline">\(a\)</span>既是环<spanclass="math inline">\(R\)</span>的左零因子，又是环<spanclass="math inline">\(R\)</span>的右零因子，它就是环<spanclass="math inline">\(R\)</span>的零因子。</p><p>1.1</p><blockquote><p>如果一个环<spanclass="math inline">\(R\)</span>有左零因子，它也一定有右零因子</p></blockquote><p><strong><font color='orange'>Proof:</font></strong></p><p>注意到若<span class="math inline">\(a\neq 0\inR\)</span>是左零因子，则<span class="math inline">\(\exist b\neq0,ab=0\)</span>，故<span class="math inline">\(b\)</span>是<spanclass="math inline">\(R\)</span>的右零因子。 <spanclass="math inline">\(\square\)</span></p><p>该结论将左右零因子的地位反过来也是同理的。</p><p>1.2</p><blockquote><p><span class="math inline">\(R\)</span>为无零因子环<spanclass="math inline">\(\LeftrightarrowR\)</span>中关于乘法的左(右)消去律成立（此处消去律是针对非零元的）</p></blockquote><p><strong><font color='orange'>Proof:</font></strong></p><p><span class="math inline">\(\Leftarrow:\)</span></p><p>若<span class="math inline">\(R\)</span>中左消去律成立。若<spanclass="math inline">\(a\neq 0\)</span>，有<spanclass="math inline">\(ab=0\)</span>,则<spanclass="math inline">\(a*b=0=a*0\)</span>,故由左消去律知<spanclass="math inline">\(b=0\)</span>,故<spanclass="math inline">\(R\)</span>中没有左零因子，同理可得<spanclass="math inline">\(R\)</span>中没有右零因子。</p><p><span class="math inline">\(\Rightarrow:\)</span></p><p>设环<span class="math inline">\(R\)</span>无左零因子。若有<spanclass="math inline">\(ab=ac\)</span>,则<spanclass="math inline">\(ab-ac=a(b-c)=0\)</span>,<spanclass="math inline">\(a\neq 0\)</span>时，由<spanclass="math inline">\(R\)</span>无左零因子，故<spanclass="math inline">\(b-c=0\)</span>，即<spanclass="math inline">\(b=c\)</span>,左消去律得证。</p><p>由<strong>环<span class="math inline">\(R\)</span>无左零因子，故<spanclass="math inline">\(R\)</span>也没有右零因子</strong>，同理得右消去律成立<span class="math inline">\(\square\)</span></p><p>由此我们马上就知道：</p><p>1.3</p><blockquote><p>环<span class="math inline">\(R\)</span>中左右消去律等价</p></blockquote><p>这是因为左消去律成立，就能知道<spanclass="math inline">\(R\)</span>是无零因子环，从而<spanclass="math inline">\(R\)</span>满足右消去律。反之同理。</p><h2 id="单位元">单位元：</h2><p>定义为环<spanclass="math inline">\(R\)</span>关于乘法的群的单位元。</p><p>即 <span class="math display">\[若e为R的单位元，则\forall x\in R,ex=xe=x\]</span> 一般默认<span class="math inline">\(e\neq 0\)</span></p><h3 id="可逆元">可逆元：</h3><p>对于<span class="math inline">\(a\in R\)</span>,若<spanclass="math inline">\(\exist b\in R,S.T.\)</span> <spanclass="math inline">\(ab=ba=e\)</span>,则<spanclass="math inline">\(a\)</span>是环<spanclass="math inline">\(R\)</span>的可逆元</p><h2 id="可逆元与零元">可逆元与零元</h2><h3 id="z_n中的可逆元与零元"><spanclass="math inline">\(Z_n中的可逆元与零元\)</span></h3><p>1.4</p><blockquote><p><span class="math inline">\(\bar{x}\)</span>为<spanclass="math inline">\(Z_n\)</span>的可逆元<spanclass="math inline">\(\Leftrightarrow\)</span> <spanclass="math inline">\((x,n)=1\)</span></p></blockquote><p><strong><font color='orange'>Proof:</font></strong></p><p><span class="math inline">\(\bar{x}\)</span>为<spanclass="math inline">\(Z_n\)</span>的可逆元<spanclass="math inline">\(\Leftrightarrow\)</span> <spanclass="math inline">\(\exist \bar{y}\in R,xy\equiv 1(mod n)\)</span>$kZ,xy+kn=1 $ <span class="math inline">\(\Leftrightarrow\)</span> <spanclass="math inline">\((x,n)=1\)</span></p><p><span class="math inline">\(\square\)</span></p><p>1.5</p><blockquote><p><span class="math inline">\(\bar{x}\)</span>为<spanclass="math inline">\(Z_n\)</span>的零因子<spanclass="math inline">\(\Leftrightarrow\)</span> <spanclass="math inline">\((x,n)\neq 1\)</span></p></blockquote><p><strong><font color='orange'>Proof:</font></strong></p><p>考虑 <span class="math display">\[n=\prod_{i=1}^{k} p_i^{\alpha_i},x=\prod_{i=1}^{d}q_i^{\beta_i}\]</span> 若<span class="math inline">\((x,n)=d&gt;1\)</span>,则<spanclass="math inline">\(x(n/d)\equiv 0(mod n)\)</span>,故<spanclass="math inline">\(x\)</span>为<spanclass="math inline">\(Z_n\)</span>的零因子</p><p>反之，若<span class="math inline">\(x\)</span>为<spanclass="math inline">\(Z_n\)</span>的零因子,则<spanclass="math inline">\(\exist d,xd\equiv 0(mod n)\)</span>,即<spanclass="math inline">\(n|xd\)</span></p><p>若<span class="math inline">\((x,n)=1\)</span>,则<spanclass="math inline">\(n|d\)</span>,这与<spanclass="math inline">\(d&lt;n\)</span>矛盾。故<spanclass="math inline">\((x,n)&gt;1\)</span></p><p><span class="math inline">\(\square\)</span></p><p>从而，我们得知，在环<span class="math inline">\(Z_n\)</span>中，<font color='green'><strong>零因子与可逆元交集为空</strong></font>。这不是偶然</p><p>1.6</p><blockquote><p>环<span class="math inline">\(R\)</span>的可逆元一定不是零因子</p></blockquote><p><strong><font color='orange'>Proof:</font></strong></p><p>若<span class="math inline">\(a\)</span>为环<spanclass="math inline">\(R\)</span>的可逆元，且<spanclass="math inline">\(a\)</span>为零因子，则<spanclass="math inline">\(\exist b\neq 0,ab=0=a0\)</span>,又<spanclass="math inline">\(a\)</span>为可逆元，由左消去律知<spanclass="math inline">\(b=0\)</span>,这与<span class="math inline">\(b\neq0\)</span>矛盾。</p><p><span class="math inline">\(\square\)</span></p><p>若<spanclass="math inline">\(a\)</span>同时为可逆元，零因子，则与上述结论矛盾。故得可逆元一定不是零因子，零因子一定不是可逆元。</p><p>由证明过程不难得到如下推论：</p><p>1.6.2</p><blockquote><p>环<spanclass="math inline">\(R\)</span>的左右零因子一定不是可逆元</p></blockquote><p><spanclass="math inline">\(Z_n\)</span>的例子仿佛告诉我们虽然两者交集为空，但是覆盖了所有非零元。但是</p><p>1.7</p><p><strong><font color='red'>事实上两者并不一定覆盖所有非零元</font></strong>。</p><p><font color='red'>比如环<spanclass="math inline">\(2Z\)</span>没有零因子（毕竟<spanclass="math inline">\(Z\)</span>都没有），但是也没有单位元，自然也没有可逆元的说法。</font></p><p>不过事实上在<spanclass="math inline">\(R\)</span>为有单位元的有限环的时候还是有点关系的。</p><p>1.8</p><blockquote><p>在有单位元的有限交换环<spanclass="math inline">\(R\)</span>中，任一不是零因子的非零元一定是可逆元</p></blockquote><p><strong><font color='orange'>Proof:</font></strong></p><p>可以设<spanclass="math inline">\(R=\{a_1,a_2,...a_n\}\)</span>,若<spanclass="math inline">\(a_i\neq 0\)</span>,且不为零因子，则<spanclass="math inline">\(a_iR=\{a_ia_1,a_ia_2,...a_ia_n\}\)</span>的元素两两不等（若<spanclass="math inline">\(a_ia_x=a_ia_y\)</span>,则<spanclass="math inline">\(a_i(a_x-a_y)=0\)</span>,由<spanclass="math inline">\(a_i\)</span>不为零因子，故<spanclass="math inline">\(a_x=a_y\)</span>,这与初始条件矛盾），故<spanclass="math inline">\(|a_iR|=|R|\)</span>,又<spanclass="math inline">\(a_iR\subseteq R\)</span></p><p>故<span class="math inline">\(a_iR=R\)</span>，故<spanclass="math inline">\(\exist a_j\neq 0 ,a_ia_j=1\)</span>,故<spanclass="math inline">\(a_i\)</span>为<spanclass="math inline">\(R\)</span>的左逆元。</p><p>又<span class="math inline">\(R\)</span>交换，故<spanclass="math inline">\(a_ja_i=1\)</span>,从而<spanclass="math inline">\(a_i\)</span>为可逆元 <spanclass="math inline">\(\square\)</span></p><h2 id="整环">整环：</h2><p>有单位元，无零因子，交换的环</p><h2 id="除环">除环：</h2><p>至少有两个元素，非零元关于乘法做成群的环</p><p>由定义可知除环一定有单位元，无零因子。（非零元关于乘法做成群，必定有单位元，也必定满足封闭性）</p><h2 id="域">域：</h2><p>交换除环</p><p>由除环性质可知，域在除环的基础上加了交换性，从而<strong>域一定是一个整环</strong></p><p>1.9</p><blockquote><p>有限整环是一个域</p></blockquote><p><strong><font color='orange'>Proof:</font></strong></p><p>显然只需证非零元关于乘法做成群即可，又只需证每一个元素可逆。这一点的证明与1.8的证明几乎一样。<span class="math inline">\(\square\)</span></p><p>需要注意的是，该证明显然只对有限环成立。</p><p>1.10</p><blockquote><p><span class="math inline">\(Z_m\)</span>为域<spanclass="math inline">\(\Leftrightarrow\)</span> m为素数</p></blockquote><p><strong><font color='orange'>Proof：</font></strong></p><p><span class="math inline">\(Z_m\)</span>是一个域<spanclass="math inline">\(\Leftrightarrow\)</span> <spanclass="math inline">\(Z_m\)</span>是一个整环<spanclass="math inline">\(\Leftrightarrow\)</span> <spanclass="math inline">\(Z_m\)</span>无零因子<spanclass="math inline">\(\Leftrightarrow\)</span> <spanclass="math inline">\(m\)</span>为素数</p><p>第二个等价符号是因为<spanclass="math inline">\(Z_m\)</span>本身已经满足可交换和有单位元的性质了</p><p><span class="math inline">\(\square\)</span></p><h2 id="环的特征">环的特征</h2><p>设<spanclass="math inline">\(R\)</span>是一个环，如果存在最小的正整数<spanclass="math inline">\(n\)</span>，使得 <span class="math display">\[\forall x\in R,nx=0\]</span> 则称<span class="math inline">\(n\)</span>为环<spanclass="math inline">\(R\)</span>的特征，记为<spanclass="math inline">\(ChR\)</span></p><p>若不存在这样的<span class="math inline">\(n\)</span>，称环<spanclass="math inline">\(R\)</span>的特征为<strong>无限</strong></p><p><font color='red'><strong>不难发现,<spanclass="math inline">\(ChR\)</span>就是环内所有元素关于加法的阶的</strong><spanclass="math inline">\(Lcm\)</span></font></p><p>1.11</p><blockquote><p>若<span class="math inline">\(R\)</span>有单位元，则<spanclass="math inline">\(ChR\)</span>等于单位元1关于加法的阶<spanclass="math inline">\(n\)</span></p></blockquote><p><strong><font color='orange'>Proof:</font></strong></p><p>显然<span class="math inline">\(ChR\geq |1|=n\)</span>。</p><p><span class="math inline">\(\forall x\inR,nx=n(1*x)=(n1)*x=0*x=0\)</span>,故<span class="math inline">\(|x||n\)</span></p><p>从而<span class="math inline">\(ChR\leq n\)</span></p><p>从而<span class="math inline">\(ChR=n\)</span> <spanclass="math inline">\(\square\)</span></p><p>1.12</p><blockquote><p>若环<spanclass="math inline">\(R\)</span><font color='red'><strong>无零因子</strong></font>，则<spanclass="math inline">\(R\)</span>中所有非零元关于加法的阶都相同，从而<spanclass="math inline">\(ChR\)</span>等于任意非零元的关于加法的阶。另外，此时<strong><spanclass="math inline">\(ChR\)</span>为素数</strong></p></blockquote><p><strong><font color='orange'>Proof:</font></strong></p><p>若<spanclass="math inline">\(R\)</span>中所有元素的阶都是无限的，该结论显然正确。</p><p>否则<span class="math inline">\(\exist x\inR,|x|=n\)</span>为一个有限正整数。从而<spanclass="math inline">\(nx=0\)</span>。此时 <span class="math display">\[\forall y\neq 0 \in R,x*(ny)=(nx)*y=0*y=0\]</span> 又环中无零因子，从而<spanclass="math inline">\(ny=0\)</span>，从而<spanclass="math inline">\(|y|\leq |x|\)</span></p><p>此时<spanclass="math inline">\(|y|\)</span>也有限，我们交换一下x，y的位置马上得到：<spanclass="math inline">\(|y|\geq |x|\)</span></p><p>从而<span class="math inline">\(|x|=|y|\)</span>。从而<spanclass="math inline">\(R\)</span>中所有非零元关于加法的阶都相同。</p><p>接下来证明第二个子结论。若<span class="math inline">\(\exist1&lt;k,t&lt;n\in Z,k*t=n\)</span>,即<spanclass="math inline">\(n\)</span>为一个合数，</p><p><span class="math inline">\(\forall x\in R^{*},x^2\inR\)</span>,从而<span class="math inline">\(|x|=|x^2|=n\)</span>,故 <spanclass="math display">\[0=n*x^{2}=kt*x^{2}=(kx)(tx)=0\]</span> 又<font color='red'><spanclass="math inline">\(R\)</span>没有零因子</font>，故<spanclass="math inline">\(kx=0或tx=0\)</span>,这与<spanclass="math inline">\(|x|=n\)</span>矛盾。</p><p>从而<span class="math inline">\(n\)</span>为素数</p><p><span class="math inline">\(\square\)</span></p><p>不难得到以下推论</p><p>1.13</p><blockquote><p>整环的特征为素数，从而域的特征为素数</p></blockquote><h1 id="子环">子环</h1><p><img src="https://s2.loli.net/2023/12/27/jCHtAnwarGSDZ8v.png" alt="绘图1" style="zoom:40%;" /></p><h2 id="定义">定义：</h2><p>设<span class="math inline">\(S\)</span>是环<spanclass="math inline">\(R\)</span>的<font color='red'>非空子集</font>，若<spanclass="math inline">\(S\)</span>关于<spanclass="math inline">\(R\)</span>的加法，乘法也做成环，则<spanclass="math inline">\(S\)</span>是环<spanclass="math inline">\(R\)</span>的子环</p><h3 id="判定">判定</h3><p>2.1</p><blockquote><p>若<span class="math inline">\(S\)</span>是环<spanclass="math inline">\(R\)</span>的非空子集，则<spanclass="math inline">\(S\)</span>是<spanclass="math inline">\(R\)</span>的子环的充要条件： <spanclass="math display">\[\forall a,b\in S\\\begin{flalign}&amp;(1)a-b\in S,\\&amp;(2)ab\in S\end{flalign}\]</span></p></blockquote><p><strong><font color='orange'>Proof:</font></strong></p><p>条件(1)与<spanclass="math inline">\(S\)</span>关于加法做成群等价。接下来证<spanclass="math inline">\(S\)</span>是半群即可。<spanclass="math inline">\(R\)</span>已经满足运算的合理性，结合律，我们只要封闭性即可。这一点由(2)保证，且是等价的。</p><p><span class="math inline">\(\square\)</span></p><h2 id="循环环的子环">循环环的子环：</h2><p>2.2</p><blockquote><p>循环环的子环<span class="math inline">\(\Leftrightarrow\)</span>循环环的加法子群</p></blockquote><p><font color='orange'><strong>Proof：</strong></font></p><p>设<span class="math inline">\(R=(a)=\{ka|k\inZ\}\)</span>为循环环</p><p><span class="math inline">\(\Leftarrow:\)</span></p><p><span class="math inline">\(S\)</span>为<spanclass="math inline">\(R\)</span>的子群，则<spanclass="math inline">\(\exist l\in Z,S=(la)=\{k(la)|k\inZ\}\)</span>,从而 <span class="math display">\[\forall k_1(la),k_2(la)\in R,k_1(la)*k_2(la)=k_1k_2l^2a^2\\a^2\in R,故\exist s\in Z,sa=a^2\\从而\\k_1(la)*k_2(la)=k_1k_2ls(la)\in (la)=S\]</span> 故<spanclass="math inline">\(S\)</span>关于乘法封闭。显然<spanclass="math inline">\(S\)</span>关于加法做成群，故<spanclass="math inline">\(S\)</span>是<spanclass="math inline">\(R\)</span>的子环。</p><p><span class="math inline">\(\Rightarrow:\)</span></p><p>显然</p><p><span class="math inline">\(\square\)</span></p><h2 id="子环关于交的封闭性">子环关于交的封闭性</h2><p>2.3</p><blockquote><p>环<spanclass="math inline">\(R\)</span>的若干个子环的交仍是子环。将子环换成子整环，子除环，子域显然也是正确的。</p></blockquote><p>这个不证了。</p><p>从而我们可以引出生成子环的概念。至于为什么生成子环是由该性质引出的，看证明就能明白。</p><h3 id="生成子环">生成子环</h3><p>设<span class="math inline">\(T\)</span>是<spanclass="math inline">\(R\)</span>的一个非空子集，若<spanclass="math inline">\(R\)</span>的子环<spanclass="math inline">\(S\)</span>满足 <span class="math display">\[\begin{flalign}&amp;(1) T\subseteq S\\&amp;(2) \forall S&#39;&lt;R且T\subseteq S&#39;,S\subseteq S&#39;\end{flalign}\]</span> 则<span class="math inline">\(S\)</span>称为<spanclass="math inline">\(T\)</span>生成的子环，记为<spanclass="math inline">\(S=[T]\)</span></p><h4 id="生成子环的存在性">2.4 生成子环的存在性</h4><p><font color='orange'><strong>Proof:</strong></font></p><p>我们需要对于一个集合<spanclass="math inline">\(T\)</span>,其生成子环总是存在的，并且满足上述性质。概括一下就是包含<spanclass="math inline">\(T\)</span>的<strong>最小</strong>子环。可以取所有包含<spanclass="math inline">\(T\)</span>的子环的交，先证其最小，再证其为子环。</p><p>记<span class="math inline">\(\{S_i|i\in I\}\)</span>为包含<spanclass="math inline">\(T\)</span>的子环集合。显然<spanclass="math inline">\(T\subseteq R,R为环\)</span>,故<spanclass="math inline">\(\{S_i|i\in I\}\)</span>非空。</p><p>取<span class="math inline">\(S=\bigcap_{i\inI}S_i,S\)</span>的最小性显然。注意到 <span class="math display">\[\forall i\in I,T\subseteq S_i\]</span> 故 <span class="math display">\[T\subseteq \bigcap_{i\in I}S_i=S\]</span> 又<spanclass="math inline">\(S\)</span>是若干个子环的交，故<spanclass="math inline">\(S\)</span>是一个子环。从而<spanclass="math inline">\(S\)</span>是包含<spanclass="math inline">\(T\)</span>的最小子环，<spanclass="math inline">\(S=[T]\)</span></p><p>存在性得证,且 <span class="math display">\[[T]=\bigcap_{i\in I}S_i\]</span> <span class="math inline">\(\square\)</span></p><h4 id="生成子环t的元素形式">生成子环[T]的元素形式</h4><p>任取<span class="math inline">\(t_1,t_2,...t_k\in T\)</span>,则 <spanclass="math display">\[\pm t_1t_2...t_k\in [T]\]</span> 从而由子环对加法的封闭性知 <span class="math display">\[\{\sum \pm t_1t_2...t_k|t_i\in T,k\in Z^{+}\}\subseteq [T]\]</span> 又不难证明 <span class="math display">\[\{\sum \pm t_1t_2...t_k|t_i\in T,k\in Z^{+}\}是一个子环\]</span> 且显然它包含<span class="math inline">\(T\)</span>。由<spanclass="math inline">\([T]\)</span>的最小性可知 <spanclass="math display">\[[T]\subseteq \{\sum \pm t_1t_2...t_k|t_i\in T,k\in Z^{+}\}\]</span> 从而 <span class="math display">\[[T]= \{\sum \pm t_1t_2...t_k|t_i\in T,k\in Z^{+}\}\]</span> 这就是生成子环<spanclass="math inline">\([t]\)</span>的元素形式。</p><p>2.5</p><blockquote><p>当<span class="math inline">\(T=\{a\}\)</span>时, <spanclass="math display">\[[T]=\{\sum n_ia^{i}|i\in Z^{+},n_i\in Z\}\]</span></p></blockquote><h1 id="环同态">环同态</h1><p>其实与群同态是类似的，要求映射满足加法保持运算，乘法保持运算即可。</p><h4 id="性质">性质：</h4><ul><li>0元保持不变</li><li>像的逆等于逆的像</li></ul><p>以上两条由加法群同态保证.若f是一个<spanclass="math inline">\(R\)</span>到<spanclass="math inline">\(R&#39;\)</span>的<font color='red'>满射</font>，则</p><ul><li>若<span class="math inline">\(R\)</span>是交换群，则<spanclass="math inline">\(R&#39;\)</span>也是交换群</li><li>若<span class="math inline">\(R\)</span>有单位元1，则<spanclass="math inline">\(R&#39;\)</span>也有单位元<spanclass="math inline">\(f(1)\)</span></li></ul><p>以上四条的逆均未必成立。</p><p>3.1</p><blockquote><p>构造<span class="math inline">\(Z_n\)</span>到<spanclass="math inline">\(Z_m\)</span>的环同态</p></blockquote><p><font color='orange'><strong>Start:</strong></font></p><p>环同态首先是群同态，由此我们需要满足： <span class="math display">\[\begin{flalign}&amp;(1) f(0)=0\\&amp;(2) nf(1)\equiv 0(mod m)\end{flalign}\]</span> 此时只需要保证<spanclass="math inline">\(f\)</span>关于乘法保持运算即可。</p><p>下面给出在加法满足群同态的情况下f关于乘法保持运算的充要条件： <spanclass="math display">\[f(1)\equiv f^{2}(1)(mod m)\]</span> <font color='green'><strong>Proof:</strong></font></p><p><span class="math inline">\(\Leftarrow:\)</span></p><p>已知<span class="math inline">\(f(1)\equiv f^{2}(1)(modm)\)</span>，<span class="math inline">\(\forall x,y\in R\)</span> <spanclass="math display">\[\begin{flalign}f(xy)&amp;=f(\underbrace{(1+1+...+1)}_{x个}*y)=f(\underbrace{y+y+...+y}_{x个})\\&amp;=xf(y)=x(yf(1))=xyf^{2}(1)=(xf(1))(yf(1))=f(x)f(y)\end{flalign}\]</span> <span class="math inline">\(\Rightarrow:\)</span></p><p>已知<span class="math inline">\(\forall x,y\inR,f(xy)=f(x)f(y)\)</span></p><p>带入<span class="math inline">\(x=y=1\)</span>即得证。</p><p><span class="math inline">\(\square\)</span></p><p>从而，f是<span class="math inline">\(Z_n\)</span>到<spanclass="math inline">\(Z_m\)</span>的充要条件为： <spanclass="math display">\[\begin{flalign}&amp;(1) f(0)=0\\&amp;(2) nf(1)\equiv 0(mod m)\\&amp;(3) f(1)\equiv f^{2}(1)(mod m)\end{flalign}\]</span> <font color='orange'><strong>End</strong></font></p><h1 id="理想">理想</h1><p><img src="https://s2.loli.net/2023/12/27/kwFLon3ZBCl1H2r.png" alt="理想" style="zoom:25%;" /></p><p>从理想开始就算是正式进入环论了。</p><h2 id="定义-1">定义</h2><p>设<span class="math inline">\(I\)</span>是环<spanclass="math inline">\(R\)</span>的一个非空子集，若 <spanclass="math display">\[\begin{flalign}&amp;(1) \forall a,b\in I,a-b\in I\\&amp;(2) \forall a\in I,\forall b\in R,ab,ba\in I\end{flalign}\]</span> 则称<span class="math inline">\(I\)</span>是环<spanclass="math inline">\(R\)</span>的理想</p><p>显然理想必定是子环，但是子环不一定是理想。</p><p>任意一个非零环<span class="math inline">\(R\)</span>都含有<spanclass="math inline">\(\{0\}和R\)</span>本身这两个理想，它们称为平凡理想。除此之外的理想称为<spanclass="math inline">\(R\)</span>的真理想。</p><h2 id="单环">单环</h2><p>4.1</p><blockquote><p>设<span class="math inline">\(R\)</span>是一个有单位元的环，<spanclass="math inline">\(R\)</span>的每一个真理想都不可能含有单位元</p></blockquote><p><font color='orange'><strong>Proof:</strong></font></p><p>设<span class="math inline">\(I\)</span>是<spanclass="math inline">\(R\)</span>的一个真理想。若<spanclass="math inline">\(1\in I\)</span>，则 <span class="math display">\[\forall x\in R,x=1*x\in I\]</span> 从而<span class="math inline">\(I=R\)</span>,这与<spanclass="math inline">\(I\)</span>是<spanclass="math inline">\(R\)</span>的真理想矛盾。 <spanclass="math inline">\(\square\)</span></p><blockquote><p>不含有真理想的环<span class="math inline">\(R\)</span>称为单环</p></blockquote><p>4.2</p><blockquote><p>除环，域都是单环</p></blockquote><p><font color='orange'><strong>Proof:</strong></font></p><p>设<span class="math inline">\(I\)</span>是域<spanclass="math inline">\(F\)</span>的一个真理想,则<spanclass="math inline">\(\exist x\in I,x\neq 0\)</span></p><p>从而<span class="math inline">\(x\in I,x^{-1}\in I,xx^{-1}=1\inI\)</span>,这与4.1的结论矛盾。（这里用到了<spanclass="math inline">\(F^{*}\)</span>是一个群，从而保证逆元存在，这一点除环和域是一样的）</p><p>从而<span class="math inline">\(I\)</span>不是<spanclass="math inline">\(F\)</span>的真理想。 <spanclass="math inline">\(\square\)</span></p><p>4.3</p><blockquote><p>设<span class="math inline">\(R\)</span>是一个有单位元<spanclass="math inline">\(1\)</span>的交换环。若<spanclass="math inline">\(R\)</span>没有非平凡的理想，则<spanclass="math inline">\(R\)</span>是一个域</p></blockquote><p><font color='orange'><strong>Proof:</strong></font></p><p>要证<spanclass="math inline">\(R\)</span>是一个域，我们现在只需要证明<spanclass="math inline">\(R^{*}\)</span>关于乘法做成群即可。如此只需要验证乘法封闭性以及每一个非零元的可逆性即可。</p><p><strong><font color='red'>注意到可逆元一定不是非零元，从而保证了乘法封闭。</font></strong></p><p>所以我们只需验证每一个元素可逆即可。</p><p>任取<span class="math inline">\(a\in R\)</span>,考虑 <spanclass="math display">\[aR=\{ar|r\in R\}\]</span> 显然该集合关于加法做成群。且 <span class="math display">\[\forall ar\in aR,x\in R\\\exist d\in R,d=rx=xr\]</span> 从而 <span class="math display">\[(ar)*x=a*(rx)=ad\in aR\\x*(ar)=(xr)*a=ad\in aR\]</span> 故<span class="math inline">\(aR\)</span>是<spanclass="math inline">\(R\)</span>的一个理想。又<spanclass="math inline">\(R\)</span>不含真理想，且<spanclass="math inline">\(a\in aR\)</span>,从而<spanclass="math inline">\(aR=R\)</span></p><p>故 <span class="math display">\[\exist x\in R,ax=xa=1\]</span> 从而<spanclass="math inline">\(a\)</span>可逆。由此我们证得每一个非零元都是可逆的。</p><p>故<span class="math inline">\(R\)</span>是一个域。 <spanclass="math inline">\(\square\)</span></p><blockquote><p>这种算是一个常见套路了。通过构造环的左陪集=环本身来证明元素的可逆性，这一点在这里和证明有限整环是域的时候都用过。只不过之前是用无零因子来证明相等，而这里使用无真理想来证明，实际上也推出了无零因子</p></blockquote><p>从4.2和4.3我们不难得到下述结论</p><p>4.4</p><blockquote><p>这<spanclass="math inline">\(R\)</span>是一个有单位元的交换环，则<spanclass="math inline">\(R\)</span>是域<strong>当且仅当</strong><spanclass="math inline">\(R\)</span>没有非平凡理想，即<spanclass="math inline">\(R\)</span>是单环</p></blockquote><p>证明从略。</p><h2 id="理想关于交的封闭性">理想关于交的封闭性</h2><blockquote><p>环<span class="math inline">\(R\)</span>的若干个理想的交仍是理想</p></blockquote><p>证明从略。</p><p>理想它首先是一个子环，所以子环的很多结论它都是可以对应过来的。那么跟子环一样，我们同样在这里可以导出生成理想的概念</p><h3 id="生成理想">生成理想</h3><p>设<span class="math inline">\(T\)</span>是环<spanclass="math inline">\(R\)</span>的一个非空子集，若存在<spanclass="math inline">\(R\)</span>的理想<spanclass="math inline">\(I\)</span>,使得 <span class="math display">\[\begin{flalign}&amp;(1) T\subseteq I\\&amp;(2) \forall I&#39;是R的理想,且T\subseteq I&#39;,有I\subseteq I&#39;\end{flalign}\]</span> 则<span class="math inline">\(I\)</span>称为集合<spanclass="math inline">\(T\)</span>的生成理想。记为<spanclass="math inline">\(I=(T)\)</span></p><h4 id="生成理想的存在性">生成理想的存在性</h4><p>我们很快注意到这一块跟子环是完全类似的。证明的思路也是一模一样。</p><p>先证包含<spanclass="math inline">\(T\)</span>的理想总是存在，再构造<spanclass="math inline">\(I=\bigcap_{i\in I}I_i\)</span>,其中<spanclass="math inline">\(I_i\)</span>的意义就是包含<spanclass="math inline">\(T\)</span>的所有理想。证明<spanclass="math inline">\(I\)</span>的最小性和以及它是一个理想即可。</p><p>设<spanclass="math inline">\(T=\{a_1,a_2....a_n\}\)</span>,则记理想<spanclass="math inline">\((T)=(a_1,a_2,...a_n)\)</span>.当<spanclass="math inline">\(T=\{a\}\)</span>时，称<spanclass="math inline">\((T)=(a)\)</span>为<spanclass="math inline">\(a\)</span>生成的主理想。</p><p>再来看看理想关于和的封闭性。</p><h2 id="理想关于和的封闭性">理想关于和的封闭性</h2><p>4.5</p><blockquote><p>设<span class="math inline">\(I_1,I_2\)</span>为<spanclass="math inline">\(R\)</span>的两个理想，则<spanclass="math inline">\(I_1+I_2\)</span>也是理想。</p></blockquote><p><strong><font color='orange'>Proof：</font></strong></p><p><span class="math inline">\(\forall x,y\in I_1+I_2,\forall r\inR\)</span>,记<spanclass="math inline">\(x=x_1+x_2,y=y_1+y_2\)</span>,其中<spanclass="math inline">\(x_1,y_1\in I_1,x_2,y_2\in I_2\)</span>.则 <spanclass="math display">\[x-y=x_1+x_2-y_1-y_2=(x_1-y_1)+(x_2-y_2)\in I_1+I_2\\rx=r(x_1+x_2)=rx_1+rx_2\in I_1+I_2\\xr=(x_1+x_2)r=x_1r+x_2r\in I_1+I_2\\\]</span> 从而<span class="math inline">\(I_1+I_2\)</span>是<spanclass="math inline">\(R\)</span>的理想 <spanclass="math inline">\(\square\)</span></p><p>进而得到下述结论：</p><p>4.6</p><blockquote><p>设<span class="math inline">\(a_1,a_2,..a_n\in R\)</span>,</p><p>则<spanclass="math inline">\((a_1,a_2,...a_n)=(a_1)+(a_2)+...+(a_n)\)</span></p></blockquote><p><strong><font color='orange'>Proof:</font> </strong></p><p>记<spanclass="math inline">\(I_1=(a_1,a_2,...a_n),I_2=(a_1)+(a_2)+...+(a_n)\)</span></p><p><span class="math inline">\(\forall a_i,a_i\in (a_i)\subseteqI_2\)</span></p><p>又<span class="math inline">\(I_1\)</span>是包含所有<spanclass="math inline">\(a_i\)</span>的最小理想，故<spanclass="math inline">\(I_1\subseteq I_2\)</span></p><p>又<span class="math inline">\((a_i)\)</span>是包含<spanclass="math inline">\(a_i\)</span>的最小理想，故<spanclass="math inline">\(\forall i\in [1,n],(a_i)\subseteq I_1\)</span></p><p>由理想对加法的封闭性，<span class="math inline">\(I_2\subseteqI_1\)</span></p><p>故<span class="math inline">\(I_1=I_2\)</span> <spanclass="math inline">\(\square\)</span></p><h3 id="理想与主理想的关系">理想与主理想的关系</h3><p>根据4.6，我们得到如下结论：</p><blockquote><p>每一个理想都是若干个主理想之和</p></blockquote><p>有了以上铺垫，我们就可以来探究生成理想的元素形式了。</p><h2 id="生成理想的元素形式">生成理想的元素形式</h2><p>由于4.6的结论，实际上我们只需要探究主理想的元素形式。</p><p>给出结论</p><blockquote><p>在<span class="math inline">\(R\)</span>中，<spanclass="math inline">\((a)=\{\sum x_iay_i+sa+at+na|x_i,y_i,s,t\in R ,n\inZ\}\)</span></p></blockquote><p>4.7</p><p>若<span class="math inline">\(R\)</span>是一个有单位元的环，则 <spanclass="math display">\[(a)=\{\sum x_iay_i|x_i,y_i\in R\}\]</span> 若<span class="math inline">\(R\)</span>是一个交换环，则 <spanclass="math display">\[(a)=\{\sum ra+na|r\in R,n\in Z\}\]</span> 若<spanclass="math inline">\(R\)</span>是一个有单位元的交换环，则 <spanclass="math display">\[(a)=\{ra|r\in R\}=aR=Ra\]</span></p><h2 id="循环环的理想">循环环的理想：</h2><p>在子环中已经讲过，循环环的子环等价于循环环关于加法的子群，事实上，循环环的子环也一定是理想，且为主理想。</p><p>4.8</p><blockquote><p>循环环的理想都是主理想</p></blockquote><p>设<span class="math inline">\(I\)</span>是循环环<spanclass="math inline">\(R=(a)\)</span>的理想,则<spanclass="math inline">\(I\)</span>也是<spanclass="math inline">\(R\)</span>的加法子群，故<spanclass="math inline">\(I=(sa)\)</span></p><p>下证<span class="math inline">\(I就是sa\)</span>生成的主理想</p><p><span class="math inline">\(sa\)</span>生成的主理想 <spanclass="math display">\[&lt;sa&gt;=\{r(sa)+n(sa)|r\in R,n\in Z\}\]</span> 显然<span class="math inline">\(&lt;sa&gt;\subseteqI\)</span></p><p>又 <span class="math display">\[\forall x=m(sa)\in I,x=0*(sa)+m*(sa)\in &lt;sa&gt;\]</span> 故<span class="math inline">\(I\subseteq&lt;sa&gt;\)</span></p><p>故<span class="math inline">\(I=&lt;sa&gt;\)</span> <spanclass="math inline">\(\square\)</span></p><p>从而</p><blockquote><p>在循环环中，子环<spanclass="math inline">\(\Leftrightarrow\)</span>理想<spanclass="math inline">\(\Leftrightarrow\)</span>主理想</p></blockquote><p>4.9</p><blockquote><p>设<span class="math inline">\(f\)</span>是<spanclass="math inline">\(R\)</span>到<spanclass="math inline">\(R&#39;\)</span>的一个环同态满射。<spanclass="math inline">\(I\)</span>是环<spanclass="math inline">\(R\)</span>的子集，<spanclass="math inline">\(I&#39;\)</span>是环<spanclass="math inline">\(R&#39;\)</span>的子集</p><p>则: <span class="math display">\[\begin{flalign}&amp;(1) 若I是环R的理想，则f(I)是环R&#39;的理想\\&amp;(2)若I&#39;是环R’的理想，则f^{-1}(I&#39;)是环R的理想，且Kerf\subseteqf^{-1}(I&#39;)&amp;\end{flalign}\]</span></p></blockquote><p>证明不难，可以看书的课后习题 3.4 9</p><p>但定理告诉我们，<strong><font color='red'>理想在同态满射下是保持的</font></strong>。并且需要指出的是，第二条结论并不需要满射的条件。</p><hr /><h2 id="商环">商环</h2><p>同群论中由不变子群引出商群一样，利用理想的概念，我们就可以引出商环的概念了。</p><blockquote><p>设<span class="math inline">\(I\)</span>是环<spanclass="math inline">\(R\)</span>的一个理想，那么记 <spanclass="math display">\[R/I=\{a+I|a\in R\}\]</span> 为<span class="math inline">\(R/I\)</span>的商集。</p><p>定义运算为: <span class="math display">\[(a+I)+(b+I)=(a+b)+I\\(a+I)*(b+I)=(ab)+I\\\]</span> 容易验证，<spanclass="math inline">\(R/I\)</span>关于新定义的乘法和加法做成环，故称它是环<spanclass="math inline">\(R\)</span>关于理想<spanclass="math inline">\(I\)</span>的商环。</p></blockquote><p><span class="math inline">\(R/I\)</span>中的元素也可以称为模<spanclass="math inline">\(I\)</span>的同余类，这一点可以通过<spanclass="math inline">\(Z\)</span>中<spanclass="math inline">\(Z/(n)\)</span>来理解</p><p>考虑 <span class="math display">\[n\in Z,(n)=\{kn|k\in Z\}\]</span> 则 <span class="math display">\[Z/(n)=\{x+(n)|x\in Z\}=\{a+nk|k\in Z\}\]</span> 此时<spanclass="math inline">\(Z/(n)\)</span>的实际含义是模<spanclass="math inline">\(n\)</span>的剩余类了，即 <spanclass="math display">\[Z/(n)=\{\overline{0},\overline{1},....\overline{n-1}\}\]</span> 从而模的意义得以体现。</p><p>eg：习题3.4 8</p><h1 id="环同态基本定理">环同态基本定理</h1><p>5.1</p><blockquote><p>环同态基本定理：</p><p>设<span class="math inline">\(f:R\rightarrowR&#39;\)</span>是一个环同态映射，则<spanclass="math inline">\(Kerf=\{x\in R|f(x)=0&#39;\}\)</span>是环<spanclass="math inline">\(R\)</span>的理想，且在<spanclass="math inline">\(R/Kerf\)</span>到<spanclass="math inline">\(R&#39;\)</span>之间存在唯一的<strong>单同态</strong>映射满足<spanclass="math inline">\(f=f_{*}\circ \phi\)</span>,其中<spanclass="math inline">\(\phi\)</span>为自然同态 <spanclass="math display">\[f_{*}:R/Kerf\rightarrow R&#39;\\x+Kerf\mapsto f(x)\]</span> 当<span class="math inline">\(f\)</span>为满射的时候，<spanclass="math inline">\(R/Kerf\cong R&#39;\)</span></p></blockquote><p>5.2 环同构第一定理</p><p><img src="https://s2.loli.net/2024/01/02/bTqU5fkWtgvLBVd.png" alt="image-20240102113208729" style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2024/01/02/7IEY35OuHbscBPG.png" alt="image-20240102113238355" style="zoom:67%;" /></p><p>5.3 环同构第二定理</p><figure><img src="https://s2.loli.net/2024/01/02/B6JTHwafjluQCLg.png"alt="image-20240102110428653" /><figcaption aria-hidden="true">image-20240102110428653</figcaption></figure><p>设<span class="math inline">\(R[x]\)</span>是实数域<spanclass="math inline">\(\mathbb{R}\)</span>上的多项式环，<spanclass="math inline">\(I=(x^2+1)\)</span>，则 <spanclass="math display">\[R[x]/I\cong \Complex\]</span> <font color='orange'><strong>Proof:</strong></font></p><p>构造 <span class="math display">\[\phi:R[x]\rightarrow \Complex\\f(x)\mapsto f(i)\]</span> 容易证明<spanclass="math inline">\(\phi\)</span>是一个满同态映射从而 <spanclass="math display">\[R[x]/Ker\phi \rightarrow \Complex\]</span> 考虑证明<span class="math inline">\(Ker\phi=(1+x^2)\)</span><span class="math display">\[Ker\phi=\{f(x)|f(i)=0\}\]</span> 从而<span class="math inline">\(i\)</span>是<spanclass="math inline">\(f(x)=0\)</span>的一个根，由于实系数多项式方程的复根是成对出现的，所以<spanclass="math inline">\(-i\)</span>也是该方程的一个根</p><p>从而 <span class="math display">\[(1+x^2)|f(x),\forall f(x)\in Ker\phi\]</span> 即 <span class="math display">\[f(x)=(1+x^2)g(x),g(x)\in R[x]\]</span> 从而 <span class="math display">\[Ker\phi\subseteq (1+x^2)\]</span> 至于另一个方向，只要把<spanclass="math inline">\(i\)</span>代入即可。从而 <spanclass="math display">\[Ker\phi=(1+x^2)\]</span> <span class="math inline">\(\square\)</span></p><p>这个东西其实还是有点套路的，比如说，考虑有理数域<spanclass="math inline">\(\mathbb{Q}\)</span>上的多项式环<spanclass="math inline">\(Q[x]\)</span>,我们构造 <spanclass="math display">\[\phi:Q[x]\rightarrow R\\f(x)\mapsto f(\sqrt(2))\]</span> 容易验证<spanclass="math inline">\(\phi\)</span>是一个环同态（当然它不是满同态，因为<spanclass="math inline">\(\sqrt(3)\in \mathbb{Q}\)</span>，但它不属于<spanclass="math inline">\(Img\phi\)</span>）,而 <spanclass="math display">\[Ker\phi=\{ f(x)|f(\sqrt(2))=0 \}\]</span> 这与上一道题的思路是极其类似的，由于<spanclass="math inline">\(\sqrt(2)\)</span>是方程的一个根，那么<spanclass="math inline">\(-\sqrt(2)\)</span>也是方程的一个根，从而不难证明<span class="math display">\[Ker\phi=(x-(\sqrt(2))^2)=(x-2)\]</span></p><h1 id="素理想与极大理想">素理想与极大理想</h1><h2 id="素理想">素理想</h2><p>如果<span class="math inline">\(P\)</span>是环<spanclass="math inline">\(R\)</span>的一个<strong>理想</strong>，并且满足<span class="math display">\[\forall a,b\in R,若ab\in P,则a\in P,或b\in P\]</span> 则<span class="math inline">\(P\)</span>是环<spanclass="math inline">\(R\)</span>的一个素理想</p><p>对于素理想的判定：</p><p>对于一个<font color='red'>有单位元的交换环</font><spanclass="math inline">\(R\)</span>,若<spanclass="math inline">\(P\)</span>是环<spanclass="math inline">\(R\)</span>的一个理想，且<spanclass="math inline">\(P\neq R\)</span>，则 <span class="math display">\[P是环R的素理想\Leftrightarrow R/P是一个整环\]</span> 证明略</p><p>6.1</p><p>从而，我们考虑整数环下的素理想</p><p>我们知道，若<span class="math inline">\(P\)</span>是整数环<spanclass="math inline">\(R\)</span>的一个素理想，首先有<spanclass="math inline">\(P\)</span>是循环群，从而<spanclass="math inline">\(P=(m)\)</span>,于是根据上一判定定理， <spanclass="math display">\[Z/P=Z/(m)=Z_m是一个整环\Leftrightarrow m是一个素数\]</span> 从而，整数环除自身外的所有素理想为<spanclass="math inline">\(\{(m)|m是素数\}\)</span></p><p>我猜这可能也是素理想这个名字的由来？因为整数环中对应的理想都是素数生成的主理想hhh</p><p>我们继续考虑如下问题。令<spanclass="math inline">\(F\)</span>是一个域，<spanclass="math inline">\(F[x]\)</span>是<spanclass="math inline">\(F\)</span>上的多项式环，考虑 <spanclass="math display">\[\phi:F[x]\rightarrow F\\f(x)\mapsto a_0\]</span> 根据环同态的知识，我们不难验证<spanclass="math inline">\(\phi\)</span>是一个环同态满射，从而有 <spanclass="math display">\[F[x]/Ker\phi\cong F\]</span></p><p>不难验证 <span class="math display">\[Ker\phi=(x)\]</span> 从而 <span class="math display">\[F[x]/(x)\cong F\]</span> 这是一个普适结论。更深入的，<spanclass="math inline">\(F\)</span>是一个域，那么它当然是一个整环，于是我们得到</p><p>6.2</p><blockquote><p>若<spanclass="math inline">\(F\)</span>是一个域，F[x]是F上的多项式环，则<spanclass="math inline">\((x)\)</span>是<spanclass="math inline">\(F[x]\)</span>的素理想</p></blockquote><h2 id="极大理想">极大理想</h2><p>设<span class="math inline">\(M\)</span>是环<spanclass="math inline">\(R\)</span>的一个理想，并且<spanclass="math inline">\(M\neq R\)</span>,若 <spanclass="math inline">\(\forall R\)</span>的理想N满足 <spanclass="math display">\[M\subseteq N\subseteq R\]</span> 都有<span class="math inline">\(N=M\)</span>或<spanclass="math inline">\(N=R\)</span>，则称<spanclass="math inline">\(M\)</span>是环<spanclass="math inline">\(R\)</span>的一个极大理想</p><p>简单来说，就是<spanclass="math inline">\(R\)</span>中不存在能完全包含<spanclass="math inline">\(M\)</span>的真理想</p><p><strong>根据定义我们很快就能知道，一个环<spanclass="math inline">\(R\)</span>可以有多个极大理想，但是事实上<font color='red'>并不是每一个环都有极大理想 </font></strong></p><p>看看极大理想的判定定理，它与素理想的判定定理是极为类似的</p><p>6.3 极大理想的判定定理</p><blockquote><p>对于一个<font color='red'>有单位元的交换环</font><spanclass="math inline">\(R\)</span>,若<spanclass="math inline">\(P\)</span>是环<spanclass="math inline">\(R\)</span>的一个理想，且<spanclass="math inline">\(P\neq R\)</span>，则 <span class="math display">\[P是环R的极大理想\Leftrightarrow R/P是一个域\]</span></p></blockquote><p>证明略</p><p><font color='red'>该定理启示我们可以通过极大理想来构造一个域</font></p><p>还是来看看整数环的极大理想长什么样子</p><p>若<span class="math inline">\(P\)</span>是整数环<spanclass="math inline">\(R\)</span>的一个极大理想，首先有<spanclass="math inline">\(P\)</span>是循环群，从而<spanclass="math inline">\(P=(m)\)</span>,于是根据判定定理， <spanclass="math display">\[Z/P=Z/(m)=Z_m是一个域\Leftrightarrow m是一个素数\]</span> 跟整数环的素理想是同一个集合<spanclass="math inline">\(\{(m)|m是素数\}\)</span>,当然这也说明了一个环确实可以有多个极大理想</p><p>此外，根据素理想与极大理想的判定定理，两者唯一的区别就是一个的除环是整环，而另一个的除环是域，而显然域一定是一个除环，所以：</p><p>6.4</p><blockquote><p>一个有单位元的交换环<spanclass="math inline">\(R\)</span>的极大理想一定是它的素理想</p></blockquote><p>注意这里的前提是有单位元的交换环</p><p>6.5</p><p>设<span class="math inline">\(R=2\mathbb{Z}\)</span>是偶数环，<spanclass="math inline">\(p\)</span>是素数，问<spanclass="math inline">\((2p)\)</span>是否为<spanclass="math inline">\(R\)</span>的极大理想，是否为<spanclass="math inline">\(R\)</span>的素理想</p><p><spanclass="math inline">\(R\)</span>是一个无单位元的交换环，所以<spanclass="math inline">\((2p)=\{2p*2k+2p*s|k,s\in Z\}=\{2kp|k\inZ\}\)</span></p><p>下面证明<span class="math inline">\(\forall p\)</span>为素数，<spanclass="math inline">\((2p)\)</span>是<spanclass="math inline">\(2\mathbb{Z}\)</span>的极大理想</p><p>首先显然<span class="math inline">\((2p)\neq2\mathbb{Z}\)</span>,若有<spanclass="math inline">\(R\)</span>的理想<spanclass="math inline">\(M\)</span>，使得<spanclass="math inline">\((2p)\subseteq M\subseteq R\)</span></p><p>当<span class="math inline">\((2p)\subset M\)</span>时，<spanclass="math inline">\(\exist x\in M,x=2k,x\notin (2p)\)</span>,从而<spanclass="math inline">\(p\)</span>不整除<spanclass="math inline">\(k\)</span>,从而<spanclass="math inline">\((x,p)=1\)</span>,从而 <spanclass="math display">\[\exist s,t\in Z,xs+pt=1\]</span> 则 <span class="math display">\[(2x)s+(2p)t=2\]</span> 由于<span class="math inline">\(2x,2p\in M\)</span>，从而<spanclass="math inline">\(2\in M\)</span>.又<spanclass="math inline">\(M\)</span>是循环群<spanclass="math inline">\(2\mathbb{Z}\)</span>的理想，所以<spanclass="math inline">\(M\)</span>也是一个循环群，又<spanclass="math inline">\(2\in M\)</span>，所以<spanclass="math inline">\(M=(2)=R\)</span></p><p><strong>从而<span class="math inline">\((2p)\)</span>是环<spanclass="math inline">\(R\)</span>的极大理想</strong> （感觉有点难想）</p><p>接下来考虑素理想</p><p>当<span class="math inline">\(p=2\)</span>时,<spanclass="math inline">\((2p)=(4)\)</span>，由<spanclass="math inline">\(2*2=4,2\notin (2p)\)</span>可知，<spanclass="math inline">\((4)\)</span>不是<spanclass="math inline">\(R\)</span>的素理想</p><p>当<span class="math inline">\(p&gt;2\)</span>时，若<spanclass="math inline">\(2k*2l\in (2p),则2p|4kl\)</span>，从而<spanclass="math inline">\(p|k\)</span>或<spanclass="math inline">\(p|l\)</span>,从而<span class="math inline">\(2k\in(2p)\)</span>或<span class="math inline">\((2l)\in(2p)\)</span>，从而<span class="math inline">\((2p)\)</span>是素理想</p>]]></content>
    
    
    <categories>
      
      <category>抽象代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>抽象代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理实验七-sql简易编译器</title>
    <link href="/2024/01/01/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%83-sql%E7%AE%80%E6%98%93%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    <url>/2024/01/01/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E4%B8%83-sql%E7%AE%80%E6%98%93%E7%BC%96%E8%AF%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="实验内容">实验内容</h2><p>利用yacc编写一个简易的sql编译器，使其能够使用sql查询语句</p><h2 id="实验思路">实验思路</h2><h3 id="词法分析">词法分析</h3><p>需要解析的单词其实并不是很多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tokens=(<span class="hljs-string">&#x27;SELECT&#x27;</span>,<span class="hljs-string">&#x27;FROM&#x27;</span>,<span class="hljs-string">&#x27;WHERE&#x27;</span>,<span class="hljs-string">&quot;DOT&quot;</span>,<span class="hljs-string">&quot;MAX&quot;</span>,<span class="hljs-string">&quot;MIN&quot;</span>,<span class="hljs-string">&quot;LP&quot;</span>,<span class="hljs-string">&quot;RP&quot;</span>,<span class="hljs-string">&quot;EQUAL&quot;</span>,<span class="hljs-string">&quot;AVERAGE&quot;</span>,<span class="hljs-string">&#x27;AND&#x27;</span>,<span class="hljs-string">&#x27;ORDER&#x27;</span>,<span class="hljs-string">&#x27;OR&#x27;</span>,<span class="hljs-string">&#x27;BIGGER&#x27;</span>,<span class="hljs-string">&#x27;SMALLER&#x27;</span>,<span class="hljs-string">&#x27;BY&#x27;</span>,<span class="hljs-string">&#x27;DESC&#x27;</span>,<span class="hljs-string">&#x27;NAME&#x27;</span>)<br></code></pre></td></tr></table></figure><p>但是对一些细节还是需要注意。比如相同前缀的单词，要注意先后顺序，就如<spanclass="math inline">\(ORDER\)</span>和<spanclass="math inline">\(OR\)</span></p><h3 id="语法分析">语法分析</h3><p>首先，对于每一个节点，我们用一个结构体<spanclass="math inline">\(node\)</span>来记录其相关信息，包括其本身字段的内容，以及其子字段的信息等等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">node</span>:<br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data</span>):<br>        self._data = data<br>        self._children = []<br>        self._queryType = <span class="hljs-string">&quot;NONE&quot;</span><br>        self._order = <span class="hljs-number">0</span><br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getdata</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self._data<br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getchildren</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self._children<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getqueryType</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span>  self._queryType<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">changeType</span>(<span class="hljs-params">self,<span class="hljs-built_in">str</span></span>):<br>        self._queryType = <span class="hljs-built_in">str</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getorder</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self._order<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rorder</span>(<span class="hljs-params">self</span>):<br>        self._order = <span class="hljs-number">1</span><br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, node</span>):<br>        self._children.append(node)<br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_node</span>(<span class="hljs-params">self, prefix</span>):<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;  &#x27;</span>*prefix,<span class="hljs-string">&#x27;+&#x27;</span>,self._data)<br>        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> self._children:<br>            child.print_node(prefix+<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="无条件查询">无条件查询</h4><p>首先来实现最简单的无条件查询，并且只是查询最简单的字段信息</p><p>总结其基本的语法结构，得到如下格式</p><p>SELECT list FROM table</p><p>这里SELECT 和 FROM都是我们在词法分析中会直接分析出来的单词，list表示的是需要查询的字段的列表，table就是我们需要查询的数据源</p><p>那么不难得到如下的基本语法 <span class="math display">\[\begin{flalign}&amp;query\rightarrow select\\&amp;select \rightarrow SELECT \ list\  FROM \ table\\&amp;table \rightarrow NAME\\&amp; list \rightarrow NAME|*\\&amp; list \rightarrow list \ DOT NAME\end{flalign}\]</span>这里DOT在词法分析中表示逗号，NAME就不是其余关键字的一个名称，一般就是字段名或者是某一个常数之类的</p><p>那么这样的话一个查询语句最后会归结成一个query节点，我们就能够对其进行操作了</p><p>以下是对应的文法实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_query</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;query :  select&#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=t[<span class="hljs-number">1</span>]<br>        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_select</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;select : SELECT list FROM table &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=node(<span class="hljs-string">&#x27;QUERY&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(node(<span class="hljs-string">&#x27;[SELECT]&#x27;</span>))<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">2</span>])<br>    t[<span class="hljs-number">0</span>].add(node(<span class="hljs-string">&#x27;[FROM]&#x27;</span>))<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">4</span>])<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_table</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;table : NAME&#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=node(<span class="hljs-string">&#x27;[TABLE]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">1</span>]))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_list</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; list : &#x27;*&#x27;</span><br><span class="hljs-string">             | NAME&#x27;&#x27;&#x27;</span><br><br>    t[<span class="hljs-number">0</span>]=node(<span class="hljs-string">&#x27;[FIELD]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">1</span>]))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_list_list_NAME</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; list : list DOT NAME&#x27;&#x27;&#x27;</span><br><br>    t[<span class="hljs-number">0</span>]=t[<span class="hljs-number">1</span>]<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">3</span>]))<br></code></pre></td></tr></table></figure><p>举例，对于查询语句</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> Chinese <span class="hljs-keyword">FROM</span> st<br></code></pre></td></tr></table></figure><p>来说，其查询的结构就如下所示</p><figure><img src="https://s2.loli.net/2024/01/01/oJciFNd2GgVKfzR.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><h4 id="无条件查询数字特征">无条件查询数字特征</h4><p>还是无条件查询，但是加入max，min或者average等操作</p><p>这种查询与上一种的区别在于，上一种查询返回的结果是一个集合，但是这一种返回的是一个数字。事实上在后面越发复杂的查询语句中，我们是很有必要对查询语句返回的结果进行判断的，所以这一点需要特别注意</p><p>并且不难发现，这种查询与上一种查询的语句结构是互斥的，其结构如下</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(<span class="hljs-keyword">NAME</span>) <span class="hljs-keyword">FORM</span> table<br></code></pre></td></tr></table></figure><p>所以我们重新引入一个单词number用来表示需要对某一个字段进行取max或者取min或者取平均等一系列操作</p><p>这一点并不是十分困难，我们很快就能得到新增的文法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查询集合与查询满足条件的数字，这两种查询应该是互斥的</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_select_num</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;select : SELECT number FROM table &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>] = node(<span class="hljs-string">&#x27;QUERY&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].changeType(<span class="hljs-string">&quot;NUMBER&quot;</span>)<br>    t[<span class="hljs-number">0</span>].add(node(<span class="hljs-string">&#x27;[SELECT]&#x27;</span>))<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">2</span>])<br>    t[<span class="hljs-number">0</span>].add(node(<span class="hljs-string">&#x27;[FROM]&#x27;</span>))<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">4</span>])<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_MAX_query</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; max_num : MAX LP NAME RP &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>] = node(<span class="hljs-string">&#x27;[MAX]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">3</span>]))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_MIN_query</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; min_num : MIN LP NAME RP &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>] = node(<span class="hljs-string">&#x27;[MIN]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">3</span>]))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_AVERAGE_query</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; average_num : AVERAGE LP NAME RP &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>] = node(<span class="hljs-string">&#x27;[AVERAGE]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">3</span>]))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_NUMBER</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; number : max_num</span><br><span class="hljs-string">               | min_num</span><br><span class="hljs-string">               | average_num&#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>] = node(<span class="hljs-string">&#x27;[NUMBER]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>从而完成了该功能的分析</p><h4 id="条件查询">条件查询</h4><p>条件查询的基本格式如下</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">SELECT</span></span> ... FROM <span class="hljs-keyword">table</span> WHERE <span class="hljs-comment">...</span><br></code></pre></td></tr></table></figure><p>WHERE后面的格式还是比较复杂的，因为其能够嵌套许多AND以及OR关键字，这就让条件之间的交并关系难以处理。这里给出了简化，保证查询条件是一个<strong>主析取范式</strong>，也就是</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">A1</span> <span class="hljs-keyword">AND </span><span class="hljs-built_in">A2</span> <span class="hljs-keyword">AND </span><span class="hljs-built_in">A3</span><br></code></pre></td></tr></table></figure><p>这样的形式，并且</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Ai = <span class="hljs-built_in">a1</span> <span class="hljs-keyword">OR </span><span class="hljs-built_in">a2</span> <span class="hljs-keyword">OR </span><span class="hljs-built_in">a3</span><br></code></pre></td></tr></table></figure><p>每一个ai就是一个基本的比较式子</p><p>如此我们就能得到WHERE后面的条件的格式了。</p><p>首先描述基本比较式子，可以是字段与常数之间的比较，也可以是字段与一个查询之间的比较</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_compare_expresion</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; compare : NAME BIGGER NAME</span><br><span class="hljs-string">                | NAME SMALLER NAME</span><br><span class="hljs-string">                | NAME EQUAL NAME&#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=node(<span class="hljs-string">&#x27;[COMPARE]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">2</span>]))<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">1</span>]))<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">3</span>]))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_compare_expresion_query</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; compare : NAME BIGGER query</span><br><span class="hljs-string">                | NAME SMALLER query</span><br><span class="hljs-string">                | NAME EQUAL query&#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=node(<span class="hljs-string">&#x27;[COMPARE]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">2</span>]))<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">1</span>]))<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><p>然后描述析取范式，也就是一个个基本比较式之间进行合并</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_compare_compare</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; or : compare OR compare&#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=node(<span class="hljs-string">&#x27;[or]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">1</span>])<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">3</span>])<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_or_compare</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; or : or OR compare&#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=t[<span class="hljs-number">1</span>]<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">3</span>])<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_xiqu_or</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; xiqu : or &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=node(<span class="hljs-string">&#x27;[OR]&#x27;</span>)<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> t[<span class="hljs-number">1</span>].getchildren():<br>        t[<span class="hljs-number">0</span>].add(x)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_xiqu_compare</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; xiqu : compare &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=node(<span class="hljs-string">&#x27;[OR]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>最后描述主合取范式，也就是析取范式之间进行合并</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_heuq</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; hequ : xiqu &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=node(<span class="hljs-string">&#x27;[AND]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">1</span>])<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_hequ_xiqu</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; hequ : hequ AND xiqu&#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=t[<span class="hljs-number">1</span>]<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">3</span>])<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_WHERE_condition</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; condition : WHERE hequ &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>] = node(<span class="hljs-string">&#x27;[WHERE]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>举例，对于查询语句</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM st WHERE Chinese &lt; <span class="hljs-number">100</span> OR Math&lt;<span class="hljs-number">100</span> AND English&gt;<span class="hljs-number">100</span> AND Total&gt;<span class="hljs-number">100</span> OR Math &gt;<span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><p>其结构如下</p><p><img src="https://s2.loli.net/2024/01/01/rdjJvbHo3tQPTgi.png" alt="2" style="zoom:67%;" /></p><p>如此就完成了条件查询</p><h4 id="嵌套查询">嵌套查询</h4><p>这一点其实比较好处理，因为对于每一个查询来说，它最终都会归结为一个节点。所以我们只要递归调用处理查询的函数，就能实现嵌套查询了</p><p>比如对于查询表达式</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> st <span class="hljs-keyword">WHERE</span> Math=(<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(Math) <span class="hljs-keyword">FROM</span> st)<br></code></pre></td></tr></table></figure><p>其结构如下所示</p><figure><img src="https://s2.loli.net/2024/01/01/CJIztExB7ZDdAHS.png" alt="3" /><figcaption aria-hidden="true">3</figcaption></figure><p>还是比较简单的</p><h4 id="关键字排序">关键字排序</h4><p>如果前面的都已经做完了的话，这一步相对来说还是比较简单的，我们只要加上对ORDER，By关键字的识别即可</p><p>对应的文法也很好写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_selsect_ordet</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; select : select order&#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=t[<span class="hljs-number">1</span>]<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">2</span>])<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_order</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; order : ORDER BY NAME&#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=node(<span class="hljs-string">&#x27;[ORDER]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">3</span>]))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_order_x</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; order : ORDER BY paixu&#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=node(<span class="hljs-string">&#x27;[ORDER]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">3</span>])<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_paixu</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; paixu : NAME DESC &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>] = node(t[<span class="hljs-number">1</span>])<br>    t[<span class="hljs-number">0</span>].rorder()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_order_NAME</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; order : order DOT NAME &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=t[<span class="hljs-number">1</span>]<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">3</span>]))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_order_paixu</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; order : order DOT paixu &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=t[<span class="hljs-number">1</span>]<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><p>这里还涉及DESC带来的逆序排序的问题，我们只要在node结构体中添加一个描述是否为逆序排序的flag即可</p><h3 id="具体实现">具体实现</h3><h4 id="对查询节点的分析">对查询节点的分析：</h4><p>找出语句中对应的查询字段，数字特征，查询的表，查询的条件，查询的排序与否以及对应关键字即可</p><p>这里查询的条件我也做了简化处理，因为都是对字段值的限制，所以每一个条件都用一个三元组来表示，分别表示字段名称，字段值的左界以及右界</p><p>得到这些信息之后直接去表里面找对应的信息即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Query_sql_set</span>(<span class="hljs-params">node</span>):<br>    st, dataset, condition = [], [], []<br>    Flag = <span class="hljs-number">0</span> <span class="hljs-comment"># 是查询集合还是查询满足条件的数字</span><br>    ordered = [<span class="hljs-number">0</span>,<span class="hljs-string">&quot;NONE&quot;</span>]<br>    <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> node.getchildren():<br>        <span class="hljs-keyword">if</span> ch.getdata() == <span class="hljs-string">&quot;[FIELD]&quot;</span>:<br>            st=ch.getchildren()<br>        <span class="hljs-keyword">if</span> ch.getdata() == <span class="hljs-string">&quot;[NUMBER]&quot;</span>:<br>            st = ch.getchildren()[<span class="hljs-number">0</span>].getchildren()[<span class="hljs-number">0</span>].getdata()<br>            Flag, <span class="hljs-built_in">type</span> = <span class="hljs-number">1</span>, ch.getchildren()[<span class="hljs-number">0</span>].getdata()[<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> ch.getdata() == <span class="hljs-string">&quot;[TABLE]&quot;</span>:<br>            dataset = ch.getchildren()[<span class="hljs-number">0</span>].getdata()<br>        <span class="hljs-keyword">if</span> ch.getdata() == <span class="hljs-string">&quot;[ORDER]&quot;</span>:<br>            ordered = [<span class="hljs-number">1</span>,ch.getchildren()]<br>        <span class="hljs-keyword">if</span> ch.getdata() == <span class="hljs-string">&quot;[WHERE]&quot;</span>:<br>            now=ch.getchildren()[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">for</span> Or <span class="hljs-keyword">in</span> now.getchildren(): <span class="hljs-comment"># 合取范式的每一个极小项</span><br>                Insert=[] <span class="hljs-comment"># 每一个元素是一个三元组，表示一个运算表达式，元素之间是或的关系</span><br>                <span class="hljs-keyword">for</span> compare <span class="hljs-keyword">in</span> Or.getchildren():<br>                    ins, val = [], compare.getchildren()<br>                    name, val_to_compare = val[<span class="hljs-number">1</span>].getdata(),get_val(val[<span class="hljs-number">2</span>])<br>                    <span class="hljs-keyword">if</span> val[<span class="hljs-number">0</span>].getdata() == <span class="hljs-string">&quot;=&quot;</span>:<br>                        ins = [name,val_to_compare,val_to_compare]<br>                    <span class="hljs-keyword">elif</span> val[<span class="hljs-number">0</span>].getdata() == <span class="hljs-string">&quot;&gt;&quot;</span>:<br>                        ins = [name,val_to_compare+EPS,INF]<br>                    <span class="hljs-keyword">else</span> :<br>                        ins = [name,-INF,val_to_compare-EPS]<br>                    Insert.append(ins)<br>                condition.append(Insert)<br>    name = dataset + <span class="hljs-string">&#x27;.csv&#x27;</span><br>    <span class="hljs-comment">#</span><br>    dtSet = pd.DataFrame(csv.reader(<span class="hljs-built_in">open</span>(name, <span class="hljs-string">&#x27;r&#x27;</span>)))<br>    <span class="hljs-comment">#</span><br>    <span class="hljs-keyword">if</span> Flag == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> naive_find(st,dtSet,condition,ordered)<br>    <span class="hljs-keyword">else</span> :<br>        <span class="hljs-keyword">return</span> naive_find_num(st,dtSet,condition,<span class="hljs-built_in">type</span>)<br></code></pre></td></tr></table></figure><h4 id="在表中对信息的查找与筛选">在表中对信息的查找与筛选</h4><p>只要注意主析取范式中对条件的交并之间的细节处理，这一块并不是很难写的内容，这里不再过多展示</p><h4 id="关键字排序-1">关键字排序</h4><p>按需模拟即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Order</span>(<span class="hljs-params">data,Key</span>):<br>    val = []<br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> Key:<br>        <span class="hljs-comment"># print(key.getdata(),key.getorder())</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(data[<span class="hljs-number">0</span>])):<br>            <span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>][i] == key.getdata():<br>                <span class="hljs-keyword">if</span> key.getorder() == <span class="hljs-number">0</span>:<br>                    <span class="hljs-comment"># 这里直接取负的话，0是保持不变的，所以需要整体平移一下</span><br>                    val.append(i+<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    val.append(-(i+<span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sort_key</span>(<span class="hljs-params">item</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">int</span>(item[k-<span class="hljs-number">1</span>]) <span class="hljs-keyword">if</span> k&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> -<span class="hljs-built_in">int</span>(item[k+<span class="hljs-number">1</span>]) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> val)<br>    data[<span class="hljs-number">1</span>:] = <span class="hljs-built_in">sorted</span>(data[<span class="hljs-number">1</span>:], key=sort_key)<br>    <span class="hljs-keyword">return</span> data<br></code></pre></td></tr></table></figure><p>如此我们就实现了一个简易的sql编译器</p><h2 id="结果展示">结果展示</h2><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">AVERAGE</span>(Math) FROM st<br></code></pre></td></tr></table></figure><figure><img src="https://s2.loli.net/2024/01/01/91LCBqOakdAxsDu.png" alt="7" /><figcaption aria-hidden="true">7</figcaption></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">No</span> <span class="hljs-keyword">FROM</span> st <span class="hljs-keyword">WHERE</span> Chinese=(<span class="hljs-keyword">SELECT</span> MAX(Chinese) <span class="hljs-keyword">FROM</span> st)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/01/01/9hYxBwUbGuk61rW.png" alt="4" style="zoom:67%;" /></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> st <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Chinese , <span class="hljs-keyword">No</span> <span class="hljs-keyword">DESC</span><br></code></pre></td></tr></table></figure><figure><img src="https://s2.loli.net/2024/01/01/z1mKVeAcI2p8uWn.png" alt="5" /><figcaption aria-hidden="true">5</figcaption></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM st WHERE Chinese &lt; <span class="hljs-number">100</span> OR Math&lt;<span class="hljs-number">100</span> AND English&gt;<span class="hljs-number">100</span> AND Total&gt;<span class="hljs-number">100</span> OR Math &gt;<span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/01/01/rNUnfjvbXY7MhBw.png" alt="6" style="zoom:67%;" /></p><h2 id="回顾">回顾</h2><p>整体还是很有意思的，但是遗憾的是只实现了很少一部分的查询语句，并且写的还是太臭了...此外在已实现的功能中也有诸多限制，比如多条件查询时将条件格式限定在了主合取范式，无法处理更复杂的情况，诸如此类</p><p>不过总体来说，还是有点收获的，我也算真正会用yacc了(吧)</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
      <tag>实验报告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理实验六-对表达式的解析</title>
    <link href="/2023/12/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E5%85%AD-%E5%AF%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/12/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E5%85%AD-%E5%AF%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言：</h2><p>对这玩意只能说是能用，只是会套别人的轮子，不过还是感觉很有意思，突然就想记录一下</p><h2 id="实验目的">实验目的：</h2><p>熟悉ply的基本使用，能够通过编写无二义性的语法以及利用yacc来实现对化学分子式的基本解析</p><h2 id="实验内容">实验内容：</h2><p>编写程序并且对化学分子式进行解析，得到其内部元素个数</p><p>以下是例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">atom_count(<span class="hljs-string">&quot;He&quot;</span>) == <span class="hljs-number">1</span><br>atom_count(<span class="hljs-string">&quot;H2&quot;</span>) == <span class="hljs-number">2</span><br>atom_count(<span class="hljs-string">&quot;H2SO4&quot;</span>) == <span class="hljs-number">7</span><br>atom_count(<span class="hljs-string">&quot;CH3COOH&quot;</span>) == <span class="hljs-number">8</span><br>atom_count(<span class="hljs-string">&quot;NaCl&quot;</span>) == <span class="hljs-number">2</span><br>atom_count(<span class="hljs-string">&quot;C60H60&quot;</span>) == <span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><h2 id="思路">思路：</h2><p>首先需要进行词法分析的构造</p><h3 id="词法分析">词法分析</h3><p>在本次实验中我们显然只需要对化学元素以及数字进行解析。事实上在一个化学分子式中确实不会出现除这两者之外的其它事物</p><ul><li>对化学元素的解析：在给定的化学元素周期表中，只要给出一个恰好包括所有元素的正则表达式即可</li><li>对数字的解析：不难得到</li></ul><p>由此我们给出词法分析的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># List of token names.   This is always required</span><br>tokens = (<br>    <span class="hljs-comment"># 本次实验我们只需要解析以下两个类型的词语</span><br>   <span class="hljs-string">&#x27;NUMBER&#x27;</span>,<span class="hljs-comment"># 数字</span><br>   <span class="hljs-string">&#x27;SYMBOL&#x27;</span> <span class="hljs-comment"># 化学元素</span><br>)<br><br><br><span class="hljs-comment"># A regular expression rule with some action code</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">t_NUMBER</span>(<span class="hljs-params">t</span>):<span class="hljs-comment">#对数字的识别</span><br>    <span class="hljs-comment"># 显然</span><br>    <span class="hljs-string">r&#x27;\d+&#x27;</span><br>    t.value = <span class="hljs-built_in">int</span>(t.value)<br>    <span class="hljs-keyword">return</span> t<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">t_SYMBOL</span>(<span class="hljs-params">t</span>):<span class="hljs-comment"># 对元素的识别</span><br>    <span class="hljs-comment"># 由元素周期表可得</span><br>    <span class="hljs-string">r&quot;&quot;&quot;</span><br><span class="hljs-string">    C[laroudsemf]?|Os?|N[eaibdpos]?|S[icernbmg]?|P[drmtboau]?|</span><br><span class="hljs-string">    H[eofgas]?|A[lrsgutcm]|B[eraik]?|Dy|E[urs]|F[erm]?|G[aed]|</span><br><span class="hljs-string">    I[nr]?|Kr?|L[iaur]|M[gnodt]|R[buhenaf]|T[icebmalh]|</span><br><span class="hljs-string">    U|V|W|Xe|Yb?|Z[nr]</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">return</span> t;<br><br><span class="hljs-comment"># A string containing ignored characters (spaces and tabs)</span><br>t_ignore  = <span class="hljs-string">&#x27; \t&#x27;</span><br><br><span class="hljs-comment"># Error handling rule</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">t_error</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;Illegal character &#x27;%s&#x27;&quot;</span> % t.value[<span class="hljs-number">0</span>])<br>    t.lexer.skip(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">## Build the lexer</span><br>lexer = lex.lex()<br></code></pre></td></tr></table></figure><h3 id="语法">语法</h3><p>考虑的基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">species_list -&gt; species_list species<br>species_list -&gt; species<br>species -&gt; SYMBOL<br>species -&gt; SYMBOL COUNT<br></code></pre></td></tr></table></figure><p>其中<spanclass="math inline">\(species\_lsit\)</span>表示一个化学分子式，<spanclass="math inline">\(species\)</span>表示一个基本的化学元素的表达式，<spanclass="math inline">\(SYMBOL\)</span>表示能够识别出来的化学元素，<spanclass="math inline">\(COUNT\)</span>就表示对应的次数，一个表达式由上述两者组成</p><p>此外，为了让最后的结果能够对不同元素的次数加以区分，我们建立了一个结构体来方便计数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Atom</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, symbol, count</span>):<br>        self.symbol = symbol<br>        self.count = count<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Atom(%r, %r)&quot;</span> % (self.symbol, self.count)<br><br></code></pre></td></tr></table></figure><p>从而不难得到语法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 给出的语法如下，用&#x27;&#x27;包装</span><br><span class="hljs-comment"># 第一条默认为初始语法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_splist_sp</span>(<span class="hljs-params">p</span>):<br>    <span class="hljs-string">&#x27;splist : splist sp&#x27;</span><br>    p[<span class="hljs-number">1</span>].append(p[<span class="hljs-number">2</span>])<br>    p[<span class="hljs-number">0</span>]=p[<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_splist_to_sp</span>(<span class="hljs-params">p</span>):<br>    <span class="hljs-string">&#x27;splist : sp&#x27;</span><br>    p[<span class="hljs-number">0</span>] = [p[<span class="hljs-number">1</span>]]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_sp_symbol</span>(<span class="hljs-params">p</span>):<br>    <span class="hljs-string">&#x27;sp : SYMBOL&#x27;</span><br>    p[<span class="hljs-number">0</span>] = Atom(p[<span class="hljs-number">1</span>],<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_sp_symbol_count</span>(<span class="hljs-params">p</span>):<br>    <span class="hljs-string">&#x27;sp : SYMBOL NUMBER&#x27;</span><br>    p[<span class="hljs-number">0</span>] = Atom(p[<span class="hljs-number">1</span>],p[<span class="hljs-number">2</span>])<br><br><span class="hljs-comment"># Error rule for syntax errors</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_error</span>(<span class="hljs-params">p</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Syntax error in input!&quot;</span>)<br></code></pre></td></tr></table></figure><p>当单独一个<span class="math inline">\(SYMBOL\)</span>或者<spanclass="math inline">\(SYMBOL\)</span>与<spanclass="math inline">\(COUNT\)</span>规约为一个<spanclass="math inline">\(species\)</span>时，我们直接将其包装为一个基本结构体。否则用一个以Atom为基本元素的数组来记录其内包含的元素及其个数</p><p>yacc采用LALR分析法，当我们编译这个程序的时候，就会在同一个目录下得到LALR生成的分析表parser.out，并且之后会根据其中的DFA来决定分析时的移进/归约操作</p><h2 id="实验结果改进">实验结果&amp;改进</h2><figure><img src="https://s2.loli.net/2023/12/23/rJRGCEhzL7WfvnQ.png"alt="image-20231223133245938" /><figcaption aria-hidden="true">image-20231223133245938</figcaption></figure><p>不过注意到这个记录方法还是存在一定不足，在<spanclass="math inline">\(CH3COOH\)</span>中<spanclass="math inline">\(C\)</span>出现了两次，但是两次分开记录了，最好可以合并在一起</p><p>由此我们可以采用字典来记录</p><p>以下是<spanclass="math inline">\(chemistry\_caculate.py\)</span>的改进后的语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#! /usr/bin/env python</span><br><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-keyword">import</span> ply.yacc <span class="hljs-keyword">as</span> yacc<br><span class="hljs-keyword">from</span> calclex <span class="hljs-keyword">import</span> tokens<br><br><span class="hljs-comment"># rules for species</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_splist_sp</span>(<span class="hljs-params">p</span>):<br>    <span class="hljs-string">&#x27;splist : splist sp&#x27;</span><br>    <span class="hljs-keyword">for</span> sym,cnt <span class="hljs-keyword">in</span> p[<span class="hljs-number">2</span>].items():<br>        <span class="hljs-keyword">if</span> sym <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> p[<span class="hljs-number">1</span>]:<br>            p[<span class="hljs-number">1</span>][sym]=cnt<br>        <span class="hljs-keyword">else</span>:<br>            p[<span class="hljs-number">1</span>][sym]+=cnt<br>    p[<span class="hljs-number">0</span>]=p[<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_splist_to_sp</span>(<span class="hljs-params">p</span>):<br>    <span class="hljs-string">&#x27;splist : sp&#x27;</span><br>    p[<span class="hljs-number">0</span>] = p[<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_sp_symbol</span>(<span class="hljs-params">p</span>):<br>    <span class="hljs-string">&#x27;sp : SYMBOL&#x27;</span><br>    p[<span class="hljs-number">0</span>] = &#123;&#125;<br>    p[<span class="hljs-number">0</span>][p[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_sp_symbol_count</span>(<span class="hljs-params">p</span>):<br>    <span class="hljs-string">&#x27;sp : SYMBOL NUMBER&#x27;</span><br>    p[<span class="hljs-number">0</span>] = &#123;&#125;<br>    p[<span class="hljs-number">0</span>][p[<span class="hljs-number">1</span>]] = p[<span class="hljs-number">2</span>]<br><br><span class="hljs-comment"># Error rule for syntax errors</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_error</span>(<span class="hljs-params">p</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Syntax error in input!&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>此时结果如下：</p><figure><img src="https://s2.loli.net/2023/12/23/wUP5zx4IpWlam3r.png"alt="image-20231223140716841" /><figcaption aria-hidden="true">image-20231223140716841</figcaption></figure><p>可以看到确实已经合并在一起了</p><p>更多细节参见文件中的PLY使用手册</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
      <tag>实验报告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高维前缀和学习笔记</title>
    <link href="/2023/12/22/%E9%AB%98%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/22/%E9%AB%98%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="正文">正文</h2><p>我们考虑一个关于求和的问题</p><p><span class="math inline">\(\forall i\)</span>,求<spanclass="math inline">\(∑_{j⊂i}a_j\)</span>,这里<spanclass="math inline">\(j\subset i\)</span>的定义可以很宽泛，我们可以将其定义为<spanclass="math inline">\(j|i\)</span>，也可以是j的二进制表示是i的二进制表示的子集等等</p><p>显然一种暴力的方法就是枚举i的所有子集，考虑优化的话，我们可以尝试前缀和，因为显然如果有<spanclass="math inline">\(j⊂z,z⊂i\)</span>,我们可以将j的贡献都先算在z上面再传给i，而不必一个个来</p><p>但是这样的话，就涉及到了高维的前缀和处理</p><hr /><p>先来看看一维前缀和是怎么写的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>a[i]+=a[i<span class="hljs-number">-1</span>];<br>&#125; <br></code></pre></td></tr></table></figure><p>然后是二维前缀和，这里我们一般用容斥来处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>&#123;<br>sum[i][j]+=sum[i<span class="hljs-number">-1</span>][j]+sum[i][j<span class="hljs-number">-1</span>]-sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>如果到了三维的话，也是可以容斥的，写起来就有点烦</p><p>实际上除了容斥，我们还有另外一种写前缀和的方法</p><p>二维</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>&#123;<br>sum[i][j]+=sum[i][j<span class="hljs-number">-1</span>];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>&#123;<br>sum[i][j]+=sum[i<span class="hljs-number">-1</span>][j];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个其实很好理解</p><p><imgsrc="https://img-blog.csdnimg.cn/a7735513952f4e6c97549c0cdcaf6120.png" /></p><p>我们先按绿色方向把每一层的前缀和都给做出来，然后再沿黄色方向做一遍前缀和，按顺序从小往大走的话，显然我们会把第一维（行）的前缀和算进去。</p><p>所以不难得到三维的前缀和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=q;++k)<br>&#123;<br>sum[i][j][k]+=sum[i<span class="hljs-number">-1</span>][j][k];<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=q;++k)<br>&#123;<br>sum[i][j][k]+=sum[i][j<span class="hljs-number">-1</span>][k];<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=q;++k)<br>&#123;<br>sum[i][j][k]+=sum[i][j][k<span class="hljs-number">-1</span>];<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么如果扩展到了n维会怎么样？</p><p>思路跟上面是一样的，就是一维一维的做前缀和</p><h3 id="二进制子集前缀和">二进制子集前缀和</h3><p>考虑一开始的问题： <span class="math inline">\(\forall i,0\leq i\leq2^n-1\)</span>，,求<span class="math inline">\(∑_{j⊂i}a_j\)</span>，其中 j属于i 定义为j的二进制表示是i的二进制表示的子集</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))<br>        &#123;<br>            dp[i]+=dp[i^(<span class="hljs-number">1</span>&lt;&lt;j)]<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为是正序枚举的，所以<spanclass="math inline">\(i^(1&lt;&lt;j)\)</span>是是当前这一维度，而此时i还在上一维，所以这样就实现了高维的前缀和。这样的时间复杂度是<spanclass="math inline">\(O(n2^n)\)</span>,而如果去枚举子集来做前缀和的话，时间复杂度是<spanclass="math inline">\(n^3\)</span>的。</p><p>我们来看一些具体的应用</p><p><a href="https://atcoder.jp/contests/arc100/tasks/arc100_c"title="ARC 100 E - Or Plus Max">ARC 100 E - Or Plus Max</a></p><p>大意： 给定一个长度为<spanclass="math inline">\(2^n\)</span>的数组，对于每一个<spanclass="math inline">\(k，1&lt;=k&lt;=2^n-1\)</span>，求出最大的<spanclass="math inline">\(ai+aj\)</span>，其中<spanclass="math inline">\(iOR j&lt;=k\)</span></p><p>思路： 关键就是如何处理<span class="math inline">\(i orj&lt;=k\)</span>,不难发现这蕴含的意思其实就是<spanclass="math inline">\(iorj\)</span>的结果是<spanclass="math inline">\(k\)</span>的二进制表示下的子集</p><p>所以我们直接跑高维前缀和，维护一下每一个<spanclass="math inline">\(k\)</span>对应的能够用的<ahref="https://so.csdn.net/so/search?q=%E6%9C%80%E5%A4%A7%E5%80%BC&amp;spm=1001.2101.3001.7020">最大值</a>以及次大值即可</p><p>code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br>ll n;<br>ll mas[N],sec[N],dp[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upt</span><span class="hljs-params">(ll id,ll val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(val&gt;=mas[id])<br>&#123;<br>sec[id]=mas[id];<br>mas[id]=val;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(val&gt;=sec[id])<br>&#123;<br>sec[id]=val;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);++i) cin&gt;&gt;mas[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);++i)<br>&#123;<br><span class="hljs-keyword">if</span>(i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))<br>&#123;<br><span class="hljs-built_in">upt</span>(i,mas[i^(<span class="hljs-number">1</span>&lt;&lt;j)]);<br><span class="hljs-built_in">upt</span>(i,sec[i^(<span class="hljs-number">1</span>&lt;&lt;j)]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);++i)<br>&#123;<br>dp[i]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>],mas[i]+sec[i]);<br>cout&lt;&lt;dp[i]&lt;&lt;endl;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);</span><br><span class="hljs-built_in">solve</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>再看一道</p><p>给定一个数组，问里面有多少个数字满足<span class="math inline">\(a_i\:and\: a_j=0\)</span></p><p>思路：</p><p>显然对于一个数<spanclass="math inline">\(a_i\)</span>，我们找到它的二进制表示的补集<spanclass="math inline">\(Q\)</span>，那么<spanclass="math inline">\(Q\)</span>的所有子集出现过的次数就是<spanclass="math inline">\(a_i\)</span>的贡献，所以我们还是可以通过高维前缀和来处理</p><p>代码不写了，题源也找不到，自己意会一下</p><p>那么上面都是二进制枚举子集的前缀和，如果是枚举超集的话，那其实叫后缀和会更加合理一些吧</p><h3 id="二进制超集后缀和">二进制超集后缀和</h3><p>代码也很好写，无非就是把原本为0的地方改成1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>((i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))==<span class="hljs-number">0</span>)<br>        &#123;<br>            dp[i]+=dp[i^(<span class="hljs-number">1</span>&lt;&lt;j)]<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://codeforces.com/problemset/problem/449/D"title="Jzzhu and Numbers">Jzzhu and Numbers</a></p><p>大意：</p><p><imgsrc="https://img-blog.csdnimg.cn/62ae6f7ae8f44b8cb1eacf30194104ec.png" /></p><p><span class="math inline">\(n,a_i&lt;=1e6\)</span></p><p>思路：<br />不考虑复杂度的话我们有一个非常套路的容斥做法。考虑性质Ai表示子集与之后第i位为1，那么我们的答案其实就是<span class="math display">\[|\Omega -A_1\bigcup A_2...\bigcup A_{20}|=\\\sum_{i=0}^{20}(-1)^i\sum_{1\leq j_1 &lt; j_2...&lt;j_i \leq 20}|A_{j_1}\bigcup A_{j_2}...A_{j_i}|\]</span> 显然就可以状压枚举，这样的时间复杂度是<spanclass="math inline">\(O(n*1e6)\)</span>，考虑优化。</p><p>注意到对于<span class="math inline">\(|A_{j_1}\bigcupA_{j_2}...A_{j_i}|\)</span>，我们记满足对应所有性质的元素的个数为<spanclass="math inline">\(k\)</span>，则该集合的大小就是<spanclass="math inline">\(2^k-1\)</span>,那么什么元素会满足这些性质呢？就是二进制为其超集的元素呗，其价值就是1.</p><p>所以我们只要做一遍超集后缀和即可，时间复杂度来到<spanclass="math inline">\(O(20*1e6)\)</span></p><p>code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>ll n,cnt=<span class="hljs-number">0</span>,a;<br>ll mas[N];<br>ll up=<span class="hljs-number">20</span>;<br>ll vis[<span class="hljs-number">30</span>];<br>ll dp[(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>)+<span class="hljs-number">10</span>];<br><span class="hljs-function">ll <span class="hljs-title">ksm</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll ans=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(y)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) ans=ans*x%mod;<br>        x=x*x%mod;<br>        y&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ll tot=<span class="hljs-number">0</span>;<br>    ll fl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        fl=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;up;++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!vis[j]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>((mas[i]&amp;(<span class="hljs-number">1</span>&lt;&lt;j))==<span class="hljs-number">0</span>)<br>            &#123;<br>                fl=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fl) tot++;<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> ((<span class="hljs-built_in">ksm</span>(<span class="hljs-number">2</span>,tot)<span class="hljs-number">-1</span>)%mod+mod)%mod;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;a,dp[a]++;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;up;++j)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;up);++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>((i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))==<span class="hljs-number">0</span>) dp[i]+=dp[i^(<span class="hljs-number">1</span>&lt;&lt;j)];<br>        &#125;<br>    &#125;<br>    ll ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s=<span class="hljs-number">0</span>;s&lt;(<span class="hljs-number">1</span>&lt;&lt;up);++s)<br>    &#123;<br>        cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;up;++i) <span class="hljs-keyword">if</span>(s&amp;(<span class="hljs-number">1</span>&lt;&lt;i)) cnt++;<br>        <span class="hljs-keyword">if</span>(cnt%<span class="hljs-number">2</span>) ans=((ans-<span class="hljs-built_in">ksm</span>(<span class="hljs-number">2</span>,dp[s])+<span class="hljs-number">1</span>)%mod+mod)%mod;<br>        <span class="hljs-keyword">else</span> ans=((ans+<span class="hljs-built_in">ksm</span>(<span class="hljs-number">2</span>,dp[s])<span class="hljs-number">-1</span>)%mod+mod)%mod;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p>然后我们看看一开始提出的第二种定义</p><p><span class="math inline">\(\forall i,0\leq i\leq2^n-1\)</span>，,求<span class="math inline">\(∑_{j⊂i}a_j\)</span>，其中$ ji$ 定义为<span class="math inline">\(j | i\)</span></p><p>显然<spanclass="math inline">\(j|i\)</span>蕴含的意思是，对于每一个质因子p，j蕴含的p的幂次不大于i蕴含的p的幂次，所以这里还是一个子集的关系，只不过集合的定义由二进制表示变成了素数分解</p><p>我们换一种写法</p><p><span class="math inline">\(\forall 1\leq i\leq n\)</span>,求<spanclass="math inline">\(∑_{j|i}a_j\)</span></p><p>我们只要按照埃氏筛的样子做一遍更新就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>    <span class="hljs-keyword">if</span>(!vis[i])<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j*i&lt;=n;++j) sum[i*j]+=sum[j],vis[i*j]=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要预处理的话也可以，唯一需要注意的，跟上文一样，这里我们的维度是由不同的素因子来确定的，所以我们要先枚举素因子来保证每一维的前缀和都更新全了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=totprime;++i)<br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;p[i]*j&lt;=n;++j)<br>    &#123;<br>        sum[p[i]*j]+=sum[j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么这种东西其实有一种更加正式的名字：</p><h3 id="狄利克雷前缀和">狄利克雷前缀和</h3><p><a href="https://www.luogu.com.cn/problem/P5495"title="Dirichlet 前缀和">Dirichlet 前缀和</a></p><p>大意：如上</p><p>思路：如上</p><p>code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll unsigned int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">2e7</span>+<span class="hljs-number">10</span>;<br>ll n,a;<br>ll seed;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">getnext</span><span class="hljs-params">()</span></span>&#123;<br>seed^=seed&lt;&lt;<span class="hljs-number">13</span>;<br>seed^=seed&gt;&gt;<span class="hljs-number">17</span>;<br>seed^=seed&lt;&lt;<span class="hljs-number">5</span>;<br><span class="hljs-keyword">return</span> seed;<br>&#125;<br> <br>ll b[N];<br><span class="hljs-type">bool</span> vis[N];<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;seed;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) b[i]=<span class="hljs-built_in">getnext</span>();<br>vis[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br><span class="hljs-keyword">if</span>(!vis[i])<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j*i&lt;=n;++j) b[i*j]+=b[j],vis[i*j]=<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans^=b[i];<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>事实上还有一种东西叫做</p><h3 id="狄利克雷后缀和">狄利克雷后缀和</h3><p><span class="math inline">\(∀1≤i≤n，求∑_{i|j}a_j\)</span></p><p>其实也不难理解，就是素因子分解下的枚举超集的后缀和，跟上面讲的二进制超集后缀和一个意思</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=totprime;++i)<br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n/p[i];j;--j)<br>    &#123;<br>        sum[j]+=sum[j*p[j]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是因为这里我们需要用到比自己大的值，所以内层需要倒序更新</p><p><a href="https://codeforces.com/contest/1614/problem/D2"title="cf 757 D2. Divan and Kostomuksha (hard version)">cf 757 D2. Divanand Kostomuksha (hard version)</a></p><p>大意： 给定一个数组<spanclass="math inline">\(a\)</span>，要求重排数组，使得数组的前缀<spanclass="math inline">\(gcd\)</span>之和最大</p><p>思路： 一个显然的小贪心：如果一开始的<spanclass="math inline">\(gcd\)</span>是<spanclass="math inline">\(x\)</span>的话，我们一定要尽可能多的保留<spanclass="math inline">\(gcd\)</span>为<spanclass="math inline">\(x\)</span>，因为后面的<spanclass="math inline">\(gcd\)</span>不会大于<spanclass="math inline">\(x\)</span>。要做到这一点，我们需要统计有多少个数字是<spanclass="math inline">\(x\)</span>的倍数</p><p>换句话说，我们需要统计<spanclass="math inline">\(cnt_i\)</span>，表示有多少个数字是<spanclass="math inline">\(i\)</span>的倍数，这其实就是一个狄利克雷后缀和</p><p>这里还有一个性质：<spanclass="math inline">\(cnt_j\)</span>一定不大于<spanclass="math inline">\(cnt_i\)</span>，这一点显然</p><p>那么我们如果以<span class="math inline">\(i\)</span>作为一开始的<spanclass="math inline">\(gcd\)</span>的话，会保留<spanclass="math inline">\(cnt_i\)</span>个前缀<spanclass="math inline">\(gcd\)</span>为<spanclass="math inline">\(i\)</span>的长度，如果以<spanclass="math inline">\(j\)</span>作为一开始的<spanclass="math inline">\(gcd\)</span>的话，会保留<spanclass="math inline">\(cnt_j\)</span>个前缀<spanclass="math inline">\(gcd\)</span>为<spanclass="math inline">\(j\)</span>的长度，这个长度肯定是不大于上一个的，所以我们可以从<spanclass="math inline">\(i\)</span>转移到<spanclass="math inline">\(j\)</span>，</p><p>设<span class="math inline">\(dp_i\)</span>表示一开始的<spanclass="math inline">\(gcd\)</span>为<spanclass="math inline">\(i\)</span>的情况下数组的最大价值</p><p><spanclass="math inline">\(dp_j=max(dp_j,1ll*cnt_j*(j-i)+dp_i);\)</span></p><p>一开始的初始条件是<span class="math inline">\(dp_1=1\)</span></p><p>另外这题数据范围有点大，需要预处理一下素数，然后按素数转移即可</p><p>code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">2e7</span>;<br>ll n,a;<br>ll cn=<span class="hljs-number">0</span>;<br>ll cnt[N+<span class="hljs-number">10</span>];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[N+<span class="hljs-number">10</span>];<br>ll p[N+<span class="hljs-number">10</span>];<br><span class="hljs-type">bool</span> vis[N+<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=N;++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!vis[i])<br>        &#123;<br>            p[++cn]=i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cn&amp;&amp;i*p[j]&lt;=N;++j)<br>        &#123;<br>            vis[i*p[j]]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    cin&gt;&gt;n;<br>    <span class="hljs-comment">//cout&lt;&lt;cn&lt;&lt;endl; </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;a;<br>        cnt[a]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cn;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=N/p[i];j;--j)<br>        &#123;<br>            cnt[j]+=cnt[j*p[i]];    <br>        &#125; <br>    &#125;<br>    dp[<span class="hljs-number">1</span>]=n;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;i*p[j]&lt;=N;++j)<br>        &#123;<br>            ll sd=i*p[j];<br>            dp[sd]=<span class="hljs-built_in">max</span>(dp[sd],<span class="hljs-number">1ll</span>*cnt[sd]*(sd-i)+dp[i]);<br>        &#125;<br>        ans=<span class="hljs-built_in">max</span>(ans,dp[i]);<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>动态规划</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多项式EXP运算的组合意义</title>
    <link href="/2023/12/21/%E5%A4%9A%E9%A1%B9%E5%BC%8FEXP%E8%BF%90%E7%AE%97%E7%9A%84%E7%BB%84%E5%90%88%E6%84%8F%E4%B9%89/"/>
    <url>/2023/12/21/%E5%A4%9A%E9%A1%B9%E5%BC%8FEXP%E8%BF%90%E7%AE%97%E7%9A%84%E7%BB%84%E5%90%88%E6%84%8F%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p>EGF一般用来处理多重集的排列问题，在其上可以定义多项式的exp运算，在处理一类问题的时候有独特的作用</p><p>我们考虑将n个有标号的元素分为k个<strong>非空</strong>无序集合的方案数，记其EGF为<spanclass="math inline">\(F_{k}\)</span>,再考虑<spanclass="math inline">\(f_i\)</span>表示在这个我们定义的集合中对集合元素的计数方式（也就是考虑元素在集合内的<strong>排列方式</strong>的个数，这是一个只跟集合大小有关的值），那么根据生成函数的定义，我们不难得到下式</p><p><spanclass="math inline">\(F_{k}(n)=\frac{n!}{k!}\sum_{\sum_{i=1}^{k}a_i=n}\prod_{j=1}^{k}\frac{f_{a_j}}{a_j!}\)</span>，最后除以<spanclass="math inline">\(k!\)</span>是因为这k个集合是无序的，而原本的多个多项式卷积显然是有序的</p><p>现在我们记<spanclass="math inline">\(\hat{F(x)}=\sum_{i=0}^{inf}f_i\frac{x^i}{i!}\)</span>,也就是原本的<spanclass="math inline">\(f_i\)</span>的EGF</p><p>再记<span class="math inline">\(G_k(x)\)</span>为<spanclass="math inline">\(F_k(n)\)</span>的EGF，则有</p><p><spanclass="math inline">\(G_k(x)=\sum_{n=0}^{inf}F_k(n)\frac{x^n}{n!}\)</span></p><p><spanclass="math inline">\(=\sum_{n=0}^{inf}\frac{n!}{k!}(\sum_{\sum_{i=1}^{k}a_i=n}\prod_{j=1}^{k}\frac{f_{a_j}}{a_j!})\frac{x^n}{n!}\)</span></p><p><spanclass="math inline">\(=\frac{1}{k!}\sum_{n=0}^{inf}(\sum_{\sum_{i=1}^{k}a_i=n}\prod_{j=1}^{k}\frac{f_{a_j}x^{a_j}}{a_j!})\)</span></p><p><span class="math inline">\(=\frac{1}{k!}(\hat{F(x)})^k\)</span></p><p>如果我们考虑所有<span class="math inline">\(k\geq 0\)</span>,就有</p><p><span class="math inline">\(\sum_{k\geq 0}G_k(x)=\sum_{k\geq0}\frac{(\hat{F(x)})^k}{k!}=exp\hat{F(x)}\)</span></p><p>我们惊奇地发现，<spanclass="math inline">\(G(x)\)</span>的指数生成函数居然就是<spanclass="math inline">\(f_x\)</span>的生成函数的exp！</p><p><strong>总结一下，多项式exp的组合意义就是：有标号元素构成的集合划分为任意个非空子集的总方案数。</strong></p><p>来几个具体的例子</p><hr /><p>考虑大小为n的排列的个数是<spanclass="math inline">\(n!\)</span>,其指数生成函数是<spanclass="math inline">\(P(x)=\sum_{n\geq 0}\frac{n!x^n}{n!}=\sum_{n\geq0}x^n=\frac{1}{1-x}\)</span></p><p>一个大小为n的圆排列个数是<spanclass="math inline">\((n-1)!\)</span>,其指数生成函数是<spanclass="math inline">\(G(x)=\sum_{n\geq1}\frac{(n-1)!x^n}{n!}=\sum_{n\geq1}\frac{x^n}{n}=-\ln(1-x)=ln(\frac{1}{1-x})\)</span></p><p>不难发现<span class="math inline">\(P(x)=expG(x)\)</span></p><p>仔细理解一下，众所周知，一个大小为n的排列一定可以拆成若干个环，每一个环内部的排列数就是一个圆排列的方案数，所以大小为n的排列的方案数就是把<spanclass="math inline">\(1,2...n\)</span>分成若干个非空集合，每一个集合的圆排列方案数之积，这与我们上面讲到的exp的组合意义相符合</p><hr /><p>第二类斯特林数<spanclass="math inline">\(\{n,k\}\)</span>的组合意义就是把n个数分成k个集合的方案数，这里一个集合的计数就是1，也就是说在上面推导过程中<spanclass="math inline">\(\hat{F(x)}=\{1,1,1....\}\)</span></p><p>其指数生成函数是<span class="math inline">\(G_{k}(x)=\sum_{n\geq0}S(n,k)\frac{x^n}{n!}=\frac{1}{k!}(exp(x)-1)^k\)</span></p><p>贝尔数的组合意义是把n个数分成若干个非空集合的方案数，其生成函数是<spanclass="math inline">\(\hat{B}(x)=exp(e^x-1)\)</span></p><p>不难理解，贝尔数与第二类斯特林数的区别就在于对分成的非空集合的个数的限制，那么<spanclass="math inline">\(\hat{B(x)}=\sum_{k\geq0}G_k(x)\)</span>也就是时分自然的，这也与上面的理论相符合</p><hr /><p>举一反三，我们考虑n个点带标号的生成树个数的EGF为<spanclass="math inline">\(\hat{F(x)}\)</span>,那么n个点带标号的森林的个数就是<spanclass="math inline">\(exp\hat{F(x)}\)</span>,意义就是将n个点分成若干个树的方案数</p><hr /><p><a href="https://www.luogu.com.cn/problem/P4841">[集训队作业2013]城市规划</a></p><p>求n个点的有标号简单无向<strong>连通</strong>图的数量</p><p>这个可能并不是那么好直接想出来，但是按照我们刚刚的理论，可以考虑先求出n个点的有标号简单无向图的数量（不要要求连通），然后直接对其EGF直接取<spanclass="math inline">\(\ln\)</span>就可以了</p><p>这个是非常好求的，就是一张完全图里面每一个点都有删或不删两种选择，其EGF就是<spanclass="math inline">\(\sum_{n\geq0}2^{\binom{n}{2}}\frac{x^n}{n!}\)</span></p><p>所以答案就是<span class="math inline">\([x^n]\ln(\sum_{n\geq0}2^{\binom{n}{2}}\frac{x^n}{n!})\)</span></p><h2 id="对上文的拓展环计数">对上文的拓展(环计数)</h2><p>上文考虑的情况是将n个元素分成若干个无序集合的情况，如果集合之间是有序的，那么就要把对应的方案数乘回去</p><p>比如如果我们是要将所有集合排成一个环，那么n个集合之间的关系方案数就是<spanclass="math inline">\((n-1)!\)</span></p><p>所以老样子，还是考虑<spanclass="math inline">\(G_k(x)\)</span>为将n个元素分成k个集合，集合之间组成一个k元环的方案数，集合内部计数方案的EGF为<spanclass="math inline">\(\hat{F(x)}\)</span>,则<spanclass="math inline">\(G_k(x)=\frac{(k-1)!}{k!}(\hat{F(x)})^k=\frac{1}{k}(\hat{F(x)})^k\)</span></p><p><span class="math inline">\(\sum_{k\geq 1}G_k(x)=\sum_{k\geq1}\frac{1}{k}(\hat{F(x)})^k=-\ln(1-\hat{F(x)})\)</span></p><hr /><blockquote><p>求包含n个顶点，n条边的连通无向图的个数。顶点有标号，要求不存在重边和自环</p></blockquote><p>首先不难发现图是一个基环树，图中存在一个大小<spanclass="math inline">\(\geq3\)</span>的环，并且环的每一个顶点都是一个有标号有根树的根。</p><p>那么此时思路就比较明显了，我们的目的就是把n个点分成<spanclass="math inline">\(\geq3\)</span>个集合，然后每一个大小为x的集合内部的计数就是大小为x的有标号有根树的计数，也就是<spanclass="math inline">\(x^{x-1}\)</span>。其EGF就是<spanclass="math inline">\(T(x)=\sum_{n\geq1}\frac{n^{n-1}x^n}{n!}\)</span></p><p>所以<span class="math inline">\(G_k(x)=\frac{1}{k}T(x)^k\)</span></p><p>那么答案就是<span class="math inline">\(\frac{1}{2}\sum_{k\geq3}G_k(x)=-\frac{1}{2}\ln(1-T(x))-\frac{T(x)}{2}-\frac{T(x)^2}{4}\)</span></p><p>最后乘上<spanclass="math inline">\(\frac{1}{2}\)</span>是因为这里的环是没有方向的，可以翻转</p>]]></content>
    
    
    <categories>
      
      <category>组合数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>学习笔记</tag>
      
      <tag>组合数学</tag>
      
      <tag>多项式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树与图上计数问题：Prufer序列与LGV引理</title>
    <link href="/2023/12/19/Prufer%E5%BA%8F%E5%88%97%E4%B8%8ELGV%E5%BC%95%E7%90%86/"/>
    <url>/2023/12/19/Prufer%E5%BA%8F%E5%88%97%E4%B8%8ELGV%E5%BC%95%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="树与图上的计数问题">树与图上的计数问题</h2><h3 id="prufer序列">Prufer序列</h3><p>起源于对<spanclass="math inline">\(Cayley\)</span>定理的证明，但是其功能远不止于此</p><ul><li><p><span class="math inline">\(Tree-&gt;Prufer:\)</span></p><p>①从树上选择编号最小的叶子节点，序列的下一位为其父节点的编号。</p><p>②删去该叶子节点。</p><p>③重复①和②，直到树只剩下两个节点，此时序列的长度刚好为 n−2 。</p></li><li><p><span class="math inline">\(Prufer—&gt;Tree:\)</span></p><p>①选择编号最小的叶子节点（即未出现在序列中的节点），其父节点就是序列的第i （ i 初始为1）个元素。</p><p>②由性质可得，其父节点的度数为其出现次数+1。将该叶子节点删去，其父节点度数-1。若度数变成1，则父节点也成为叶子节点。</p><p>③将 i 加一，然后重复①和②，直到序列的每一个元素都使用完毕。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++">ll p[N];<br>ll d[N];<span class="hljs-comment">//度数</span><br>ll f[N];<span class="hljs-comment">//连边</span><br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Prufer_To_Tree</span><span class="hljs-params">(ll n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//f记录1-n-1的连边情况</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-2</span>;++i) cin&gt;&gt;p[i],d[p[i]]++;<br>    p[n<span class="hljs-number">-1</span>]=n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>;i&lt;n;++i,++j)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(d[j]) j++;<br>        f[j]=p[i];<span class="hljs-comment">//把最小的叶往prufer序列第一个点上接 对应减掉度数</span><br><br>        <span class="hljs-keyword">while</span>(i&lt;n&amp;&amp;!--d[p[i]]&amp;&amp;p[i]&lt;j) f[p[i]]=p[i+<span class="hljs-number">1</span>],i++;<br>        <span class="hljs-comment">//如果序列第一个点减掉度数后产生了新的更小的叶 就往序列下一个点上接</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans^=<span class="hljs-number">1ll</span>*i*f[i];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Tree_To_Prufer</span><span class="hljs-params">(ll n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) cin&gt;&gt;f[i],d[f[i]]++;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-2</span>;++i,++j)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(d[j]) j++;<br>        p[i]=f[j];<br>        <span class="hljs-keyword">while</span>(i&lt;=n<span class="hljs-number">-2</span>&amp;&amp;!--d[p[i]]&amp;&amp;p[i]&lt;j) p[i+<span class="hljs-number">1</span>]=f[p[i]],i++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-2</span>;++i) ans^=<span class="hljs-number">1ll</span>*i*p[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>由此我们发现两者是一一对应的，也就是双射，所以大小为n的有标号无根树的个数等于长度为<spanclass="math inline">\(n-2\)</span>的prufer序列的个数，自然为<spanclass="math inline">\(n^{n-2}\)</span>，<spanclass="math inline">\(Cayley\)</span>定理得证</p><h4 id="prufer序列的性质">Prufer序列的性质</h4><p>由Prufer序列构造的过程，我们可以发现其具有两个显而易见的性质。</p><ul><li><p>构造完后剩下的两个节点里，一定有一个是编号最大的节点。</p></li><li><p><strong>对于一个 n 度的节点，其必定在序列中出现 n−1次</strong>。因为每次删去其子节点它都会出现一次，最后一次则是删除其本身。一次都未出现的是原树的叶子节点。</p></li></ul><h4 id="应用">应用</h4><p><strong>1、无向完全图的不同生成树数：</strong></p><p><span class="math inline">\(n^{n−2}\)</span> 。</p><p><strong>2、</strong> n <strong>个点的无根树计数：</strong></p><p>同上问题。</p><p><strong>3、</strong> n <strong>个点的有根树计数：</strong></p><p>对每棵无根树来说，每个点都可能是根，故总数为 <spanclass="math inline">\(n^{n−2}×n=n^{n−1}\)</span> 。</p><p><strong>4、</strong> n <strong>个点，每点度分别为</strong> <spanclass="math inline">\(d_i\)</span> <strong>的无根树计数：</strong></p><p>显然就是一个多重集，答案为<spanclass="math inline">\(\frac{(n-2)!}{\prod_{i=1}^{n}d_i-1}\)</span></p><p><strong>5、</strong> <strong>有标号的完全二分图<spanclass="math inline">\(K_{n,m}\)</span>的生成树个数为<spanclass="math inline">\(n^{m-1}m^{n-1}\)</span>:</strong></p><p>考虑将其生成树的prufer序列按照原本顺序分成<spanclass="math inline">\(f_i\leq n,f_i&gt;n\)</span>两部分。</p><p>对于<span class="math inline">\(f_i\leqn\)</span>的部分，一定是删去某个标号<spanclass="math inline">\(&gt;n\)</span>的点之后留下<spanclass="math inline">\(f_i\)</span>的，因为这是一张二分图。所以该部分的点一定恰好有<spanclass="math inline">\(m-1\)</span>个（右部有m个点，整张图删完之后一定在左右部各留下一个点，所以右部一共要删去<spanclass="math inline">\(m-1\)</span>个点）</p><p><span class="math inline">\(f_i&gt;n\)</span>部分同理。</p><p>所以一个此时还是可以用一个prufer序列与合法生成树对应，故方案数为<spanclass="math inline">\(n^{m-1}m^{n-1}\)</span></p><h4 id="tips">Tips:</h4><p>一般要特判n=1的情况</p><p><a href="https://ac.nowcoder.com/acm/contest/28665/E">ValuableForests</a></p><p>大意：</p><p>定义一个树的权值为其所有节点的度数的平方和，森林的权值为所有树的权值和。求大小为n的所有有标号森林的权值和</p><p>思路：</p><p><spanclass="math inline">\(f_i\)</span>表示大小为i的所有有标号森林的权值和，也就是答案</p><p>考虑对于最后一个点所在的树的大小为k的情况</p><p>则<spanclass="math inline">\(f_n=\sum_{k=1}^{n}\binom{n-1}{k-1}f_{n-k}m_k+\binom{n-1}{k-1}g_kh_{n-k}\)</span></p><p>其中<span class="math inline">\(m_i\)</span>表示大小为<spanclass="math inline">\(i\)</span>的有标号无根树的个数，<spanclass="math inline">\(g_i\)</span>表示大小为<spanclass="math inline">\(i\)</span>的所有有标号无根树的权值和，<spanclass="math inline">\(h_{n-k}\)</span>表示大小为<spanclass="math inline">\(n-k\)</span>的森林的数量。<spanclass="math inline">\(\binom{n-1}{k-1}\)</span>是因为枚举的k的含义是n所在树的大小，我要从剩下<spanclass="math inline">\(n-1\)</span>个点里面选<spanclass="math inline">\(k-1\)</span>个点。如果不这样枚举的树的组合就会算重。</p><p><span class="math inline">\(m_n\)</span>很简单：<spanclass="math inline">\(n=1\)</span>时<spanclass="math inline">\(m_1=1\)</span>，否则<spanclass="math inline">\(m_n=n^{n-2}\)</span></p><p>对于<spanclass="math inline">\(g_n\)</span>,我们枚举所有度数为i的贡献</p><p>转化到prufer序列中看这个问题，度数为i，表示出现了<spanclass="math inline">\(i-1\)</span>次，所以强制选定对应的数字以及位置，剩下的<spanclass="math inline">\(n-1\)</span>个数随便放</p><p><spanclass="math inline">\(g_n=\sum_{i=1}^{n-1}i^2n\binom{n-2}{i-1}{n-1}^{n-1-i}\)</span></p><p><span class="math inline">\(h_n\)</span>的更新思路和<spanclass="math inline">\(f\)</span>差不多，枚举最后一个点所在的树的大小即可</p><p><spanclass="math inline">\(h_n=\sum_{i=1}^{n}\binom{n-1}{i-1}h_{n-i}m_i\)</span></p><p><a href="https://codeforces.com/problemset/problem/156/D">cf156D</a></p><p>大意：</p><p>给定n个点以及m条连边，记最少添加T条边使得整张图连通，问有多少种恰好添加T条边的方案使得图连通</p><p>思路:</p><p>记当前连通块个数为k，则T=k-1</p><p>对于每一个连通块，其大小为<spanclass="math inline">\(a_i\)</span>，如果其度数为<spanclass="math inline">\(d_i\)</span>的话，我们可以在以连通块为单位的情况下得到生成树个数为<spanclass="math inline">\(\binom{k-2}{d1-1,d2-1...d_k-1}\)</span></p><p>对于每一个连通块，固定连边的标号顺序（比如第1条边来自标号最小的连通块，依次类推），那么此时总方案数为<spanclass="math inline">\(\binom{k-2}{d1-1,d2-1...d_k-1}*\prod_{i=1}^{k}a_i^{d_i}\)</span>,因为每一条边都可以有<spanclass="math inline">\(a_i\)</span>种选择</p><p>所以答案为<span class="math inline">\(\sum_{\sumd_i=k-2}\binom{k-2}{d1,d2...d_k}*\prod_{i=1}^{k}a_i^{d_i+1}=\sum_{\sumd_i=k-2}\frac{(k-2)!}{\prod_{i=1}^{k}d_i!}*\prod_{i=1}^{k}a_i^{d_i+1}=(k-2)!\prod_{i=1}^{k}a_i(\sum_{\sum_{i=1}^{k}d_i=k-2}\prod_{i=1}^{k}\frac{a_i^{d_i}}{d_i!})\)</span></p><p>注意到<span class="math inline">\((k-2)!\prod_{i=1}^{k}a_i\)</span>是一个常数，我们只用看后面</p><p>记生成函数<spanclass="math inline">\(f_x=\sum_{i=0}^{\inf}\frac{x_i}{i!}=e^x\)</span></p><p>不难发现后面其实是k个函数<spanclass="math inline">\(f_{a_i}\)</span>的卷积的某一项,故最终答案为<spanclass="math inline">\([x^{k-2}]\prod_{i=1}^{k}e^{a_ix}=[x^{k-2}]e^{nx}=\frac{n^{k-2}}{(k-2)!}\)</span></p><p>所以最终答案为<spanclass="math inline">\(n^{k-2}\prod_{i=1}^{k}a_i\)</span></p><h3 id="lgv引理">LGV引理</h3><p>在一个有向无环图G中，出发点<spanclass="math inline">\(A=\{a_1,a_2,...a_n\}\)</span>，目标点<spanclass="math inline">\(B=\{b_1,b_2,..b_n\}\)</span>。有向边<spanclass="math inline">\(e\)</span>的权值为<spanclass="math inline">\(w_e\)</span>，<spanclass="math inline">\(e(u,v)\)</span>为路径边权乘积之和，即<spanclass="math inline">\(e(u,v)=\sum_{P:a-&gt;b}\prod_{e\inP}w_e\)</span></p><p>则<span class="math inline">\(\begin{vmatrix}  e(a_1,b_1)&amp;e(a_1,b_2) &amp; ... &amp; e(a_1,b_n)\\  e(a_2,b_1)&amp; e(a_2,b_1)&amp; ... &amp; e(a_2,b_n)\\  ...&amp; ... &amp; &amp;...\\  e(a_n,b_1)&amp; e(a_n,b_2) &amp; ... &amp; e(a_n,b_n)\end{vmatrix}=\sum_{S:A-&gt;B}(-1)^{N(\sigma)}\prod_{i=1}^n\prod_{e\inS_i}w_e\)</span></p><p>其中<span class="math inline">\(\sigma\)</span>是一个n元置换，<spanclass="math inline">\(N(\sigma)\)</span>表示逆序对个数,<spanclass="math inline">\(S_i:a_i-&gt;b_i\)</span>是一组A到B的不相交路径。</p><p><strong>此处的不相交是指处处不存在相同的点在两条路径中同时存在，起终点也不行，所以A里的元素互不相同。如果初始条件并非如此，可能要转化一下</strong></p><p>在算法竞赛中，该引理在普通的DAg下没有过多的用处，因为其右式还是过于复杂。但是如果图满足所有边权为1（这样<spanclass="math inline">\(e(u,v)\equiv1\)</span>,就可以表示路径数量了），并且只存在唯一的一个$<spanclass="math inline">\(满足所有\)</span>a_i-&gt;b_i$不相交的话，此时右式只有一个因子，含义就是整张图的不相交路径组数，就可以用左式的行列式表示了</p><p><a href="https://ac.nowcoder.com/acm/contest/28665/F">MonotonicMatrix</a></p><p>大意：</p><p><spanclass="math inline">\(A_1(1,0),A_2(0,1),B_1(n,m+1),B_2(n+1,m)\)</span>,求<spanclass="math inline">\(A_1-&gt;B_1,A_2-&gt;B_2\)</span>的不相交路径数。其中每一步只能向上/向右</p><p>套板子即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> il inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2010</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>ll n,m;<br>ll c[N][N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ll n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<span class="hljs-built_in">j</span>&lt;=i;++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>) c[i][j]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> c[i][j]=(c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+c[i<span class="hljs-number">-1</span>][j])%mod;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">f</span><span class="hljs-params">(ll x1,ll y1,ll x2,ll y2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//(x1,y1)-&gt;(x2,y2)</span><br>    ll len1=x2-x1;<br>    ll len2=y2-y1;<br>    <span class="hljs-keyword">return</span> c[len1+len2][len2];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// cin&gt;&gt;n&gt;&gt;m;</span><br>    ll a=<span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,n,m+<span class="hljs-number">1</span>)*<span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,n+<span class="hljs-number">1</span>,m)%mod;<br>    ll b=<span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>,m)*<span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,n,m+<span class="hljs-number">1</span>)%mod;<br>    cout&lt;&lt;((a-b)%mod+mod)%mod&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//     freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">init</span>(<span class="hljs-number">2005</span>);<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)<br>    <span class="hljs-comment">// ll t;cin&gt;&gt;t;while(t--)</span><br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>组合数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>势函数与鞅的停时定理</title>
    <link href="/2023/12/19/%E5%8A%BF%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9E%85%E7%9A%84%E5%81%9C%E6%97%B6%E5%AE%9A%E7%90%86/"/>
    <url>/2023/12/19/%E5%8A%BF%E5%87%BD%E6%95%B0%E4%B8%8E%E9%9E%85%E7%9A%84%E5%81%9C%E6%97%B6%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="势函数和鞅的停时定理">势函数和鞅的停时定理</h2><h3 id="前置芝士">前置芝士</h3><p>鞅：</p><p>鞅是一类特殊的随机过程，假设我们从一开始就在观察一场赌博游戏，现在已经得到了前t秒的观测值，那么当第t+1秒观测值的期望等于第t秒的观测值时，我们称这是一个公平赌博游戏。</p><p>具体来说，对于一个随机过程<spanclass="math inline">\({A_1,A_2,...}\)</span>,如果<spanclass="math inline">\(E(A_{n+1}|A_0,A_2,..A_n)=A_n\)</span>,我们称该随机过程为鞅。</p><p>鞅的停时定理：</p><p>设时停时间（在<strong>不知道随机过程的中间状态下</strong>停止的时刻）为t，则<spanclass="math inline">\(E(t)=E(0)\)</span></p><p>这个E到底是什么，由具体的情境而定，但是只要一个随机过程是一个鞅，它就有该结论</p><h3 id="势函数">势函数</h3><p>接下来我们考虑一个很常见的问题：</p><p>对于一个随机过程<spanclass="math inline">\({A_1,A_2,...}\)</span>,如果<strong>其终止状态<spanclass="math inline">\(A_t\)</span>是确定的</strong>，求<spanclass="math inline">\(E[t]\)</span>,即时停时刻的期望（<strong>注意这里我们不要求该随机过程是一个鞅</strong>）</p><p>为此，我们引入一个势函数<spanclass="math inline">\(\phi(X)\)</span></p><p>并且<span class="math inline">\(\phi(x)\)</span>满足如下性质：</p><ul><li><span class="math inline">\(\forall n&lt;t,E(\phi(A_{n+1})-\phi(A_n)|A_0,A_1,...A_n)=-1\)</span>,即势能不断降低</li><li><span class="math inline">\(E(\phi(A_t))=C\)</span>,是一个常值</li></ul><p>那么如果我们令<spanclass="math inline">\(X_t=\phi(A_t)+t\)</span>,则<spanclass="math inline">\(E(X_{n+1}-X_n|x_0,x_1...x_n)=E(\phi(A_{n+1})-\phi(A_n)+1|x_0,x_1...x_n)=E(\phi(A_{n+1})-\phi(A_n)|x_0,x_1...x_n)+1=0\)</span></p><p>我们发现随机过程<spanclass="math inline">\(X_t\)</span>就是一个鞅了</p><p>那么由鞅的停时原理，<spanclass="math inline">\(E(X_t)=E(X_0)\)</span>,即<spanclass="math inline">\(E(\phi(A_t)+t)=E(\phi(A_0)+0)\)</span>,也即<spanclass="math inline">\(E(\phi(A_t))+E(t)=E(\phi(A_0))\)</span></p><p>所以我们得到<strong><spanclass="math inline">\(E(t)=E(\phi(A_0))-E(\phi(A_t))\)</span></strong>,根据我们之前定义的性质，<spanclass="math inline">\(E(\phi)A_t\)</span>为一个常值，而<spanclass="math inline">\(E(\phi(A_0))\)</span>显然也是一个常值，所以只要能找到这个满足条件的势函数，就能很方便的求出<spanclass="math inline">\(E(t)\)</span></p><p>这里我们只是在随机过程<spanclass="math inline">\(X_t\)</span>中应用了停时定理，对原本的随机过程<spanclass="math inline">\(A_t\)</span>并没有做什么限制</p><p>接下来结合具体的题目来讨论一下如何构造这样的一个势函数</p><p><ahref="https://codeforces.com/contest/1349/problem/D">CF1349D</a></p><p>大意：</p><p>有n个人在玩传球游戏，一开始第<spanclass="math inline">\(i\)</span>个人有<spanclass="math inline">\(a_i\)</span>个球。每一次传球，等概率随机<strong>选中一个球</strong>，设其当前拥有者为<spanclass="math inline">\(i\)</span>，<spanclass="math inline">\(i\)</span>将这个球等概率随机传给另一个人<spanclass="math inline">\(j(j\neqi)\)</span>。当某一个人拥有所有球时，停止游戏。问游戏停止时的期望传球次数。</p><p>记球的总数为m</p><p>不妨记状态<spanclass="math inline">\(A_t=(a_{t,1},a_{t,2}...a_{t,n})\)</span>,一个n维向量，分别表示在时刻t，第i个人手中球的数量，显然它唯一地表示了某一个时刻的全局状态</p><p>也就是说，我们现在就把这个游戏过程抽象成了一个随机过程<spanclass="math inline">\(A_0,A_1....\)</span>,并且其停时为t。那么按照之前所说，我们需要去定义一个势函数<spanclass="math inline">\(\phi(A_t)\)</span>,为了计算方便，我们可以将<spanclass="math inline">\(\phi\)</span>具体到A的每一维向量，不妨记为<spanclass="math inline">\(\phi(A_t)=\sum_{i=1}^{n}f(a_{t,i})\)</span>,这里f是什么我们并不知道，但是如果我们知道了f，其实也就是相当于构造出了这个势能函数</p><p>这里再把我们定义的<spanclass="math inline">\(\phi\)</span>的性质再放一下</p><hr /><p><span class="math inline">\(\phi(x)\)</span>满足如下性质：</p><ul><li><span class="math inline">\(\forall n&lt;t,E(\phi(A_{n+1})-\phi(A_n)|A_0,A_1,...A_n)=-1\)</span>,即势能不断降低</li><li><span class="math inline">\(E(\phi(A_t))=C\)</span>,是一个常值</li></ul><hr /><p>那么我们首先来考虑第一个性质，为了方便，不妨先考虑<spanclass="math inline">\(E(\phi(A_{n+1})|A_0,A_1,...A_n)\)</span></p><p>发现传球过程就是一个<spanclass="math inline">\(Markov\)</span>过程，并且该时刻的状态只与上一个时刻的状态有关,所以<spanclass="math inline">\(E(\phi(A_{n+1})|A_0,A_1,...A_n)=E(\phi(A_{n+1})|A_n)\)</span></p><p>考虑一次转移的所有可能</p><p>i传球给j的概率是<span class="math inline">\(\Large\frac{a_{t,i}}{m}\frac{1}{n-1}\)</span></p><p><span class="math inline">\(\largeE(\phi(A_{n+1})|A_n)=\sum_{i=1}^{n}\sum_{j\neqi}\frac{a_{t,i}}{m}\frac{1}{n-1}[f(a_{t,i}-1)+f(a_{t,j}+1)+\sum_{k\notin(i,j)}f(a_{t,k})]\)</span></p><p><span class="math inline">\(\large=\sum_{i=1}^{n}\frac{a_{t,i}}{m}f(a_{t,i}-1)+\frac{m-a_{t,i}}{m(n-1)}f(a_{t,i}+1)+\frac{(m-a_{t,i})(n-2)}{m(n-1)}f(a_{t,i})\)</span></p><p>根据我们定义的性质<spanclass="math inline">\(E(\phi(A_{n+1})-\phi(A_n)|A_0,A_1,...A_n)=-1\)</span></p><p><spanclass="math inline">\(E(\phi(A_{n+1})-\phi(A_n)|A_0,A_1,...A_n)=E(\phi(A_{n+1})-\phi(A_n)|A_n)\)</span></p><p><span class="math inline">\(\large=(\sum_{i=1}^{n}\frac{a_{t,i}}{m}f(a_{t,i}-1)+\frac{m-a_{t,i}}{m(n-1)}f(a_{t,i}+1)+\frac{(m-a_{t,i})(n-2)}{m(n-1)}f(a_{t,i}))-\sumf(a_{t,i})=-1\)</span></p><p>所以<span class="math inline">\(\large \sumf(a_{t,i})=(\sum_{i=1}^{n}\frac{a_{t,i}}{m}f(a_{t,i}-1)+\frac{m-a_{t,i}}{m(n-1)}f(a_{t,i}+1)+\frac{(m-a_{t,i})(n-2)}{m(n-1)}f(a_{t,i}))+1\)</span></p><p>那么我们可以把末尾的1分配到每一个和式里面去，这样左右的形式就统一了</p><p>所以<span class="math inline">\(\large \sumf(a_{t,i})=\sum_{i=1}^{n}[\frac{a_{t,i}}{m}f(a_{t,i}-1)+\frac{m-a_{t,i}}{m(n-1)}f(a_{t,i}+1)+\frac{(m-a_{t,i})(n-2)}{m(n-1)}f(a_{t,i})+\frac{a_{t,i}}{m}]\)</span></p><p>那么不妨记<span class="math inline">\(\largef(a)=\frac{a}{m}f(a-1)+\frac{m-a}{m(n-1)}f(a+1)+\frac{(m-a)(n-2)}{m(n-1)}f(a)+\frac{a}{m}\)</span></p><p>这样和式还是成立的，我们也成功抽象出了f函数</p><p>再转化一下，<span class="math inline">\(\largef(a+1)=\frac{m+an-2a}{m-a}f(a)-\frac{a(n-1)}{m-a}(f(a-1)+1)\)</span></p><p>代入边界条件<span class="math inline">\(a=0\)</span>时，有<spanclass="math inline">\(f(1)=f(0)\)</span>,所以我们可以设<spanclass="math inline">\(f(1)=f(0)=0\)</span>,毕竟势函数的初值并不重要</p><p>这样就得到了f，也就是相当于得到了势函数<spanclass="math inline">\(\phi(x_t)=\sum_{i}f(x_{t,i})\)</span></p><p>然后考虑势函数的第二个性质：<spanclass="math inline">\(E(\phi(A_t))=C\)</span>是一个常值</p><p>显然<spanclass="math inline">\(E(\phi(A_t))=\sum_{i}f(a_{t,i})=f(m)+(n-1)f(0)\)</span>是一个常值</p><p>所以根据我们的结论，<spanclass="math inline">\(E(t)=E(\phi(A_0))-E(\phi(A_t))=\sum_{i}f(a_{0,i})-f(m)-(n-1)f(0)=\sum_{i}f(a_{0,i})-f(m)\)</span></p><p>这样我们就非常方便的得到了停时的期望</p><p>不妨来看一个近一点的例子</p><p><ahref="http://acm.hdu.edu.cn/contest/problem?cid=1102&amp;pid=1008">杭电多校09Coins</a></p><p>大意：</p><p>n个人，每个人手中初始有<spanclass="math inline">\(a_i\)</span>个硬币，每次随机选择两个人，第一个人给第二个人一个硬币，如果某个人手中没有硬币了，则立即退出游戏，不再回来。当某一个人拥有全部硬币时，游戏结束</p><p>问停时的期望</p><p>题意与上一题十分相像，但是该题存在人数不固定的情况，所以我们描述游戏局面的时候要稍微改变一下</p><p>还是令<span class="math inline">\(m=\sum a_i\)</span></p><p>令<spanclass="math inline">\(A_t=(a_{t,1},a_{t,2}...a_{t,h_t})\)</span>来描述第t个时刻的局面，其中<spanclass="math inline">\(h_t\)</span>表示当前的剩余人数，显然它不是一个固定的值。但是我们能保证<spanclass="math inline">\(\forall i\leq h_t,a_{t,i}&gt;0\)</span></p><p>仿照上一题的思路，我们令<spanclass="math inline">\(\phi(A_t)=\sum_{i=1}^{n}f(a_{t,i})\)</span>作为势函数，尝试确定f</p><p><span class="math inline">\(\largeE(\phi(A_{n+1})|A_n)=\sum_{i=1}^{h_t}\sum_{j\neqi}\frac{1}{h_t(h_t-1)}[f(a_{t,i}-1)+f(a_{t,j}+1)+\sum_{k\notin(i,j)}f(a_{t,k})]\)</span></p><p><span class="math inline">\(\large=\sum_{i=1}^{h_t}\frac{1}{h_t}f(a_{t,i}-1)+\frac{1}{h_t}f(a_{t,i}+1)+\frac{h_t}{h_t-2}f(a_{t,i})\)</span></p><p>代入<span class="math inline">\(\largeE(\phi(A_{n+1})-\phi(A_n)|A_0,A_1,...A_n)=-1\)</span>,也就是<spanclass="math inline">\(\largeE(\phi(A_{n+1})-\phi(A_n)|A_n)=-1\)</span>(显然这里当前局面也只与上一个局面有关)，有</p><p><span class="math inline">\(\large \sum_{i=1}^{h_t}f(a_{t,i})=[\sum_{i=1}^{h_t}\frac{1}{h_t}f(a_{t,i}-1)+\frac{1}{h_t}f(a_{t,i}+1)+\frac{h_t}{h_t-2}f(a_{t,i})]+1\)</span></p><p><span class="math inline">\(\large=\sum_{i=1}^{h_t}(\frac{1}{h_t}f(a_{t,i}-1)+\frac{1}{h_t}f(a_{t,i}+1)+\frac{h_t}{h_t-2}f(a_{t,i})+\frac{1}{h_t})\)</span></p><p>抽象出<span class="math inline">\(\largef(a)=\frac{1}{h}f(a-1)+\frac{1}{h}f(a+1)+\frac{h}{h-2}f(a)+\frac{1}{h}\)</span></p><p><span class="math inline">\(f(a+1)-f(a)=f(a)-f(a-1)-1\)</span></p><p>令<spanclass="math inline">\(g(a)=f(a)-f(a-1),有g(a)=g(0)-a\)</span>，则<spanclass="math inline">\(f(a)=f(0)+ag(0)-\frac{a(a+1)}{2}\)</span></p><p>取<span class="math inline">\(f(0)=g(0)=0\)</span>,则<spanclass="math inline">\(f(a)=-\frac{a(a+1)}{2}\)</span></p><p>所以<spanclass="math inline">\(E(t)=E(\phi(A_0))-E(\phi(A_t))=\sum_{i=1}^{n}f(a_{0,i})-f(m)\)</span></p><p>未完待续</p>]]></content>
    
    
    <categories>
      
      <category>鞅论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>学习笔记</tag>
      
      <tag>鞅论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分图博弈学习笔记</title>
    <link href="/2023/12/19/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8D%9A%E5%BC%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/19/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8D%9A%E5%BC%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="二分图博弈">二分图博弈</h1><p>二分图博弈是少有的直接跟图论挂钩的一种博弈模型</p><p>一个博弈是二分图博弈应当满足一下条件：</p><blockquote><ul><li>博弈人数为两人，轮流操作</li><li>博弈状态转移可以表示成一张二分图</li><li>不可访问已经访问过的状态</li><li>无法转移者负</li></ul></blockquote><p>拥有二分图这么良好的性质，该博弈模型自然而然的有一个很简单的结论：如果先手状态，我们记为P，<strong>一定</strong>在二分图的最大匹配中，那么先手必胜。否则先手必败。</p><p>那么我们来看看证明：</p><p>假设当前P不在最大匹配中，那么先手移动之后P一定会到达一个匹配点，否则我们就有了一个新的匹配，与最大匹配这一点矛盾。所以此时我们的局面是当前处于匹配点上，后手先行动。后手走的下一个点也一定是匹配点，否则就跟之前的路径形成了一条增广路，同样矛盾。所以接下来双方都是在匹配点上转移。显然最终移动步数为偶数，故此时后手必胜。</p><p>若P在最大匹配中，则只要仿照上述策略，就是一个必胜的局面。</p><p>如果P没有可以转移的局面，同样也是不在最大匹配中，当然也是必败。</p><hr /><blockquote><p>由此，对于一个二分图博弈，只要我们能够判断先手所在局面是否处在二分图的最大匹配上，即可判断必胜状态。</p></blockquote><p>如何判断一个点是否一定在最大匹配上？比较经典的套路就是先将其从图中移除，然后再加进来，看看是否还能对匹配有贡献。如果有的话，说明其一定处在最大匹配上。</p><p>具体实现，我们可以采用网络流。在建图的时候先不将P与源点或者汇点连接，这样跑网络流的时候就不会将其考虑进去。然后把P与源点/汇点连接，利用残量网络，再做一遍网络流。如果值非0，就是有贡献的。</p><p>但是该方法仅适用于单起点博弈。如果需要判断的局面过多，显然时间复杂度无法接受。</p><p>如果想要找出所有局面中的必胜局面，我们有更好的办法。</p><p>找出所有必胜局面，也就是找出所有<strong>一定</strong>处在最大匹配的点，相当于找出所有<strong>不一定</strong>在最大匹配上的点。</p><figure><img src="https://s2.loli.net/2023/12/19/XSdNGtm3z2luUCq.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><imgsrc="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="alt="点击并拖拽以移动" />编辑</p><p>非匹配边1-&gt;5和2-&gt;5匹配边<strong>可以互换最大匹配数不变</strong>，所以点1,2都<strong>不一定</strong>在最大匹配中。在该图的残量网络中，1-&gt;5的流量为1，匹配边5-&gt;2的反向流量为1，因此我们判断两条边可以互换。将与源点相连的边颜色col设为1，汇点设为0，dfs即可。这是判断与左部点的，判断右部点同理。</p><p><strong>但是，但是，并不是所有满足二分图博弈模型的题目都一定得通过网络流来求解，因为不同博弈模型本身有其独特的性质，可能可以通过其他途径求解，比如*<em><ahref="https://ac.nowcoder.com/acm/contest/57356/I">23牛客多校2 I Linkwith Gomoku</a>*</em></strong></p><p>然后就到了喜闻乐见的例题时间</p><p>[<a href="https://www.luogu.com.cn/problem/P4617">COCI2017-2018#5]Planinarenje</a></p><p>大意： <img src="https://s2.loli.net/2023/12/19/Ep9SIFb1a7Dk4UJ.png"alt="img" /><imgsrc="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="alt="点击并拖拽以移动" />​</p><p>模板题</p><p>不难发现，判负的条件与一方无法行动是等价的，所以该问题完美符合二分图博弈模型。然后又因为要对所有先手局面判断是否必胜，那么我们应该采用第二种方法。</p><p>code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll maxn=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>,maxm=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MaximumFlow</span><br>&#123;<br>    <span class="hljs-comment">//maxn 最多点数 maxm 最多边数</span><br>    <span class="hljs-type">int</span> h[maxn],e[maxm],ne[maxm],f[maxm],idx;<br>    <span class="hljs-type">int</span> d[maxn],cur[maxn];<br>    <span class="hljs-type">int</span> n,m,S,T,mxn;<br>    ll col[maxn],ans[maxn];<br>    ll flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> _s,<span class="hljs-type">int</span> <span class="hljs-type">_t</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        mxn=n,idx=<span class="hljs-number">0</span>,S=_s,T=<span class="hljs-type">_t</span>;<span class="hljs-comment">//mxn表示最大点的大小（包括S，T），用于初始化处理，_s表示源点，_T表示汇点</span><br>        <span class="hljs-comment">// memset(h,-1,sizeof h);</span><br>        <span class="hljs-keyword">while</span>(n&gt;=<span class="hljs-number">0</span>)<br>            h[n--]=<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ne[idx]=h[a],e[idx]=b,f[idx]=c,h[a]=idx++;<br>        ne[idx]=h[b],e[idx]=a,f[idx]=<span class="hljs-number">0</span>,h[b]=idx++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// memset(d,-1,sizeof d);</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=mxn;++i) d[i]=<span class="hljs-number">-1</span>;<br>        d[S]=<span class="hljs-number">0</span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt;q;<br>        q.<span class="hljs-built_in">push</span>(S);<br>        cur[S]=h[S];<br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> t=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])<br>            &#123;<br>                <span class="hljs-type">int</span> j=e[i];<br>                <span class="hljs-keyword">if</span>(d[j]==<span class="hljs-number">-1</span>&amp;&amp;f[i])<br>                &#123;<br>                    d[j]=d[t]+<span class="hljs-number">1</span>;<br>                    cur[j]=h[j];<br>                    <span class="hljs-keyword">if</span>(j==T)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> limit)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(u==T)<span class="hljs-keyword">return</span> limit;<br>        <span class="hljs-type">int</span> flow=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=cur[u];i!=<span class="hljs-number">-1</span>&amp;&amp;flow&lt;limit;i=ne[i])<br>        &#123;<br>            cur[u]=i;<br>            <span class="hljs-type">int</span> j=e[i];<br>            <span class="hljs-keyword">if</span>(d[j]==d[u]+<span class="hljs-number">1</span>&amp;&amp;f[i])<br>            &#123;<br>                <span class="hljs-type">int</span> t=<span class="hljs-built_in">find</span>(j,<span class="hljs-built_in">min</span>(f[i],limit-flow));<br>                <span class="hljs-keyword">if</span>(!t)d[j]=<span class="hljs-number">-1</span>;<br>                f[i]-=t,f[i^<span class="hljs-number">1</span>]+=t,flow+=t;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> flow;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> r=<span class="hljs-number">0</span>,flow;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>())<span class="hljs-keyword">while</span>(flow=<span class="hljs-built_in">find</span>(S,inf))r+=flow;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// vis[u]=1;</span><br>        <span class="hljs-keyword">if</span>(col[u]==t)<br>        &#123;<br>            flag=<span class="hljs-number">1</span>;<br>            ans[u]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i!=<span class="hljs-number">-1</span>;i=ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j=e[i];<br>            <span class="hljs-keyword">if</span>(f[i]==t&amp;&amp;!ans[j])<br>            &#123;<br>                <span class="hljs-built_in">dfs</span>(j,t);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">judge</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">dinic</span>();<br>        <span class="hljs-built_in">dfs</span>(S,<span class="hljs-number">1</span>);<span class="hljs-built_in">dfs</span>(T,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br><br>&#125;f;<br>ll n,m;<br>ll S,T;<br>ll a,b;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    S=n*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;T=n*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>;<br>    f.<span class="hljs-built_in">init</span>(T+<span class="hljs-number">1</span>,S,T);<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        f.<span class="hljs-built_in">addedge</span>(a,b+n,<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        f.<span class="hljs-built_in">addedge</span>(S,i,<span class="hljs-number">1</span>);<br>        f.col[i]=<span class="hljs-number">1</span>;<br>        f.<span class="hljs-built_in">addedge</span>(i+n,T,<span class="hljs-number">1</span>);<br>    &#125;<br>    f.<span class="hljs-built_in">judge</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(f.ans[i]==<span class="hljs-number">0</span>) cout&lt;&lt;<span class="hljs-string">&quot;Slavko&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;Mirko&quot;</span>&lt;&lt;endl;<br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="alt="点击并拖拽以移动" /><figcaption aria-hidden="true">点击并拖拽以移动</figcaption></figure><p><ahref="https://codeforces.com/gym/102832/problem/H">20ccpc长春H</a></p><p>大意：有m个数位的数字锁，存在若干状态不允许访问，也不允许访问之前访问过的节点，每次操作改变某一位，无法操作者负。给定锁的初始状态，问必胜状态。</p><p>思路：显然锁的状态是一张二分图，因为数位和奇偶性相同的状态显然无法一次到达。那么我们只要把非法的状态不加入图中，然后采用第一种判断方法就可以了。</p><p>code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll int</span><br><span class="hljs-type">const</span> ll INF=<span class="hljs-number">1e8</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e8</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>,maxm=<span class="hljs-number">9e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MaximumFlow</span><br>&#123;<br><br>    <span class="hljs-type">int</span> h[maxn],e[maxm],ne[maxm],f[maxm],idx;<br>    <span class="hljs-type">int</span> d[N],cur[N];<br>    <span class="hljs-type">int</span> n,m,S,T,mxn;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> _s,<span class="hljs-type">int</span> <span class="hljs-type">_t</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        mxn=n,idx=<span class="hljs-number">0</span>,S=_s,T=<span class="hljs-type">_t</span>;<br>        <span class="hljs-comment">// memset(h,-1,sizeof h);</span><br>        <span class="hljs-keyword">while</span>(n&gt;=<span class="hljs-number">0</span>)h[n--]=<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ne[idx]=h[a],e[idx]=b,f[idx]=c,h[a]=idx++;<br>        ne[idx]=h[b],e[idx]=a,f[idx]=<span class="hljs-number">0</span>,h[b]=idx++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> d);<br>        d[S]=<span class="hljs-number">0</span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt;q;<br>        q.<span class="hljs-built_in">push</span>(S);<br>        cur[S]=h[S];<br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> t=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])<br>            &#123;<br>                <span class="hljs-type">int</span> j=e[i];<br>                <span class="hljs-keyword">if</span>(d[j]==<span class="hljs-number">-1</span>&amp;&amp;f[i])<br>                &#123;<br>                    d[j]=d[t]+<span class="hljs-number">1</span>;<br>                    cur[j]=h[j];<br>                    <span class="hljs-keyword">if</span>(j==T)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> limit)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(u==T)<span class="hljs-keyword">return</span> limit;<br>        <span class="hljs-type">int</span> flow=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=cur[u];i!=<span class="hljs-number">-1</span>&amp;&amp;flow&lt;limit;i=ne[i])<br>        &#123;<br>            cur[u]=i;<br>            <span class="hljs-type">int</span> j=e[i];<br>            <span class="hljs-keyword">if</span>(d[j]==d[u]+<span class="hljs-number">1</span>&amp;&amp;f[i])<br>            &#123;<br>                <span class="hljs-type">int</span> t=<span class="hljs-built_in">find</span>(j,<span class="hljs-built_in">min</span>(f[i],limit-flow));<br>                <span class="hljs-keyword">if</span>(!t)d[j]=<span class="hljs-number">-1</span>;<br>                f[i]-=t,f[i^<span class="hljs-number">1</span>]+=t,flow+=t;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> flow;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> r=<span class="hljs-number">0</span>,flow;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>())<span class="hljs-keyword">while</span>(flow=<span class="hljs-built_in">find</span>(S,inf))r+=flow;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;f;<br>ll n,m,pwd;<br>ll vis[N];<br>ll c[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">100</span>,<span class="hljs-number">1000</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">100000</span>&#125;;<br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x)<br>    &#123;<br>        sum+=x%<span class="hljs-number">10</span>;<br>        x/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum%<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;m&gt;&gt;n&gt;&gt;pwd;<br>    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> vis);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        ll a;cin&gt;&gt;a;vis[a]=<span class="hljs-number">1</span>;<br>    &#125;<br>    ll up=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) up*=<span class="hljs-number">10</span>;<br>    ll S=up,T=up+<span class="hljs-number">1</span>;<br>    f.<span class="hljs-built_in">init</span>(up+<span class="hljs-number">5</span>,S,T);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;up;++i)<br>    &#123;<br>        <span class="hljs-comment">//判断pwd是否一定在二分图的最大匹配中，一开始不将其与S或T连边</span><br>        <span class="hljs-comment">//但是与网络其他节点相连。跑完网络流之后将pwd与对应起点/终点相连。</span><br>        <span class="hljs-comment">//利用残量网络再跑一遍网络流。如果值大于0，代表其一定在二分图的最大匹配中</span><br>        <span class="hljs-keyword">if</span>(vis[i]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(i))<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i!=pwd) f.<span class="hljs-built_in">addedge</span>(i,T,<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i!=pwd) f.<span class="hljs-built_in">addedge</span>(S,i,<span class="hljs-number">1</span>);<br><br>        ll x;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j)<br>        &#123;<br>            x=i;<br>            <span class="hljs-type">int</span> num=i;<br>            x/=c[j];<br>            x%=<span class="hljs-number">10</span>;<br>            num=num-x*c[j];<br>            ll t1=num+((x+<span class="hljs-number">1</span>)%<span class="hljs-number">10</span>)*c[j];<br>            f.<span class="hljs-built_in">addedge</span>(i,t1,<span class="hljs-number">1</span>);<br>            t1=num+((x<span class="hljs-number">-1</span>+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>)*c[j];<br>            f.<span class="hljs-built_in">addedge</span>(i,t1,<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    f.<span class="hljs-built_in">dinic</span>();<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(pwd)) f.<span class="hljs-built_in">addedge</span>(pwd,T,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">else</span> f.<span class="hljs-built_in">addedge</span>(S,pwd,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(f.<span class="hljs-built_in">dinic</span>()) cout&lt;&lt;<span class="hljs-string">&quot;Alice&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;Bob&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    ll t;cin&gt;&gt;t;<span class="hljs-keyword">while</span>(t--)<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="alt="点击并拖拽以移动" /><figcaption aria-hidden="true">点击并拖拽以移动</figcaption></figure><p>[<a href="https://www.luogu.com.cn/problem/P1971">NOI2011]兔兔与蛋蛋游戏</a></p><p>大意：</p><p>n行m列的棋盘，每一格有一个黑/白棋，还有一个位置是空的</p><p>每一局游戏总是兔兔先操作，之后双方轮流操作，具体操作为：</p><ul><li>兔兔每次操作时，选择一枚与空格相邻的白色棋子，将它移进空格。</li><li>蛋蛋每次操作时，选择一枚与空格相邻的黑色棋子，将它移进空格。</li></ul><p>第一个不能按照规则操作的人输掉游戏。</p><p>思路： 有幸做出人生第二道黑题（敲下来有阻塞，但没想象中那么费劲）</p><p>我们稍微转化一下，将黑白棋的移动看成空格的移动。先手操作的时候，空格只能与白棋交换，此空格相当于黑棋。后手操作的时候，空格只能与黑棋交换，此时空格相当于白棋。所以相当于轮流在黑白棋之间切换，每次只能与不同颜色的点交换位置，显然是一张二分图。此外有一个性质比较隐蔽，那就是我们无法访问之前访问过的局面。因为黑白棋是轮流操作的，黑棋走过的点白棋是无法走的，反之同理。由此，我们成功转化成了二分图博弈，</p><p>这题要求我们输出所有操作失误的步骤。其实就是操作前后的都处于必胜状态的点。（仔细想想，不难理解）。每次操作之后整张图都不一样了，我们要判断的起始点也不一样了，所以我们每次要重新建图，因为图比较小，所以该方法是可行的。</p><p>code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">110</span>;<br><span class="hljs-type">const</span> ll INF=<span class="hljs-number">0x3f3f3f3f</span>,inf=INF;<br><span class="hljs-type">const</span> ll maxn=<span class="hljs-number">4000</span>,maxm=maxn*<span class="hljs-number">20</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MaximumFlow</span><br>&#123;<br>    <span class="hljs-comment">//maxn 最多点数 maxm 最多边数</span><br>    <span class="hljs-type">int</span> h[maxn],e[maxm],ne[maxm],f[maxm],idx;<br>    <span class="hljs-type">int</span> d[maxn],cur[maxn];<br>    <span class="hljs-type">int</span> n,m,S,T,mxn;<br>    ll mp_vis[maxn];<br>    ll col[maxn],ans[maxn];<br>    ll flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> _s,<span class="hljs-type">int</span> <span class="hljs-type">_t</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        mxn=n,idx=<span class="hljs-number">0</span>,S=_s,T=<span class="hljs-type">_t</span>;<span class="hljs-comment">//mxn表示最大点的大小（包括S，T），用于初始化处理，_s表示源点，_T表示汇点</span><br>        <span class="hljs-comment">// memset(h,-1,sizeof h);</span><br>        <span class="hljs-keyword">while</span>(n&gt;=<span class="hljs-number">0</span>)<br>            h[n--]=<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ne[idx]=h[a],e[idx]=b,f[idx]=c,h[a]=idx++;<br>        ne[idx]=h[b],e[idx]=a,f[idx]=<span class="hljs-number">0</span>,h[b]=idx++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// memset(d,-1,sizeof d);</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=mxn;++i) d[i]=<span class="hljs-number">-1</span>;<br>        d[S]=<span class="hljs-number">0</span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt;q;<br>        q.<span class="hljs-built_in">push</span>(S);<br>        cur[S]=h[S];<br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> t=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])<br>            &#123;<br>                <span class="hljs-type">int</span> j=e[i];<br>                <span class="hljs-keyword">if</span>(d[j]==<span class="hljs-number">-1</span>&amp;&amp;f[i])<br>                &#123;<br>                    d[j]=d[t]+<span class="hljs-number">1</span>;<br>                    cur[j]=h[j];<br>                    <span class="hljs-keyword">if</span>(j==T)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> limit)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(u==T)<span class="hljs-keyword">return</span> limit;<br>        <span class="hljs-type">int</span> flow=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=cur[u];i!=<span class="hljs-number">-1</span>&amp;&amp;flow&lt;limit;i=ne[i])<br>        &#123;<br>            cur[u]=i;<br>            <span class="hljs-type">int</span> j=e[i];<br>            <span class="hljs-keyword">if</span>(d[j]==d[u]+<span class="hljs-number">1</span>&amp;&amp;f[i])<br>            &#123;<br>                <span class="hljs-type">int</span> t=<span class="hljs-built_in">find</span>(j,<span class="hljs-built_in">min</span>(f[i],limit-flow));<br>                <span class="hljs-keyword">if</span>(!t)d[j]=<span class="hljs-number">-1</span>;<br>                f[i]-=t,f[i^<span class="hljs-number">1</span>]+=t,flow+=t;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> flow;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> r=<span class="hljs-number">0</span>,flow;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>())<span class="hljs-keyword">while</span>(flow=<span class="hljs-built_in">find</span>(S,inf))r+=flow;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i!=<span class="hljs-number">-1</span>;i=ne[i])<br>        &#123;<br>            ll Y=e[i];<br>            <span class="hljs-keyword">if</span>(Y==y) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;f;<br>ll n,m;<br><span class="hljs-type">char</span> mp[N][N];<br>ll px,py;<br>ll S,T;<br>vector&lt;ll&gt; ans;<br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> y+(x<span class="hljs-number">-1</span>)*m;<br>&#125;<br>ll dir[][<span class="hljs-number">4</span>]=&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">inmap</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x&gt;=<span class="hljs-number">1</span>&amp;&amp;y&gt;=<span class="hljs-number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&lt;=m;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">jd</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x==px&amp;&amp;y==py) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//是当前操作点</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">gt</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//奇数点与汇点相连</span><br>    <span class="hljs-comment">//偶数点与源点相连</span><br>    f.<span class="hljs-built_in">init</span>(n*m+<span class="hljs-number">5</span>,S,T);<span class="hljs-comment">//每次要将起始点与源点/汇点断开连接，重新建图，反正图也不大</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">jd</span>(i,j)) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//去掉操作起始点</span><br>            <span class="hljs-keyword">if</span>((i+j)%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            f.<span class="hljs-built_in">addedge</span>(<span class="hljs-built_in">gt</span>(i,j),T,<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>((i+j)%<span class="hljs-number">2</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//去掉操作起始点</span><br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">jd</span>(i,j)) f.<span class="hljs-built_in">addedge</span>(S,<span class="hljs-built_in">gt</span>(i,j),<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;++k)<br>            &#123;<br>                ll xx=i+dir[k][<span class="hljs-number">0</span>];<br>                ll yy=j+dir[k][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">inmap</span>(xx,yy)) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(mp[xx][yy]==mp[i][j]) <span class="hljs-keyword">continue</span>;<br>                f.<span class="hljs-built_in">addedge</span>(<span class="hljs-built_in">gt</span>(i,j),<span class="hljs-built_in">gt</span>(xx,yy),<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    f.<span class="hljs-built_in">dinic</span>();<br>    <span class="hljs-keyword">if</span>((px+py)%<span class="hljs-number">2</span>) f.<span class="hljs-built_in">addedge</span>(<span class="hljs-built_in">gt</span>(px,py),T,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">else</span> f.<span class="hljs-built_in">addedge</span>(S,<span class="hljs-built_in">gt</span>(px,py),<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> f.<span class="hljs-built_in">dinic</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>        &#123;<br>            cin&gt;&gt;mp[i][j];<br>            <span class="hljs-keyword">if</span>(mp[i][j]==<span class="hljs-string">&#x27;.&#x27;</span>)<br>            &#123;<br>                px=i;py=j;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">////////////////////////</span><br><br><br>    S=n*m+<span class="hljs-number">1</span>,T=n*m+<span class="hljs-number">2</span>;<br>    ll op;cin&gt;&gt;op;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> dx=<span class="hljs-number">1</span>;dx&lt;=op;++dx)<br>    &#123;<br>        ll a,b;cin&gt;&gt;a&gt;&gt;b;<br>        mp[px][py]=<span class="hljs-string">&#x27;X&#x27;</span>;<span class="hljs-comment">//因为先手操作之后不能返回当前局面，所以要将这个位置置为X</span><br>        ll pre_1=<span class="hljs-built_in">gt</span>();<br>        mp[px][py]=<span class="hljs-string">&#x27;.&#x27;</span>;<span class="hljs-comment">//</span><br>        <span class="hljs-built_in">swap</span>(mp[px][py],mp[a][b]);<br>        px=a;py=b;<br><br>        mp[px][py]=<span class="hljs-string">&#x27;O&#x27;</span>;<span class="hljs-comment">//与上面改成X是同理的</span><br>        ll pre_2=<span class="hljs-built_in">gt</span>();<br>        mp[px][py]=<span class="hljs-string">&#x27;.&#x27;</span>;<span class="hljs-comment">//</span><br>        <span class="hljs-comment">// cout&lt;&lt;dx&lt;&lt;&#x27; &#x27;&lt;&lt;px&lt;&lt;&#x27; &#x27;&lt;&lt;py&lt;&lt;&#x27; &#x27;&lt;&lt;pre_1&lt;&lt;&#x27; &#x27;&lt;&lt;pre_2&lt;&lt;endl;</span><br>        <span class="hljs-keyword">if</span>(pre_1&amp;&amp;pre_2)<br>        &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(dx);<br>            <span class="hljs-comment">//如果前后都是必胜态，那么该操作失误</span><br>        &#125;<br>        <span class="hljs-comment">///</span><br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-built_in">swap</span>(mp[px][py],mp[a][b]);<br>        px=a;py=b;<br>    &#125;<br><br>    cout&lt;&lt;ans.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:ans) cout&lt;&lt;i&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博弈论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>学习笔记</tag>
      
      <tag>博弈论</tag>
      
      <tag>图论</tag>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>各类基于决策单调性的dp优化</title>
    <link href="/2023/12/19/%E5%90%84%E7%B1%BB%E5%9F%BA%E4%BA%8E%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7%E7%9A%84dp%E4%BC%98%E5%8C%96/"/>
    <url>/2023/12/19/%E5%90%84%E7%B1%BB%E5%9F%BA%E4%BA%8E%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7%E7%9A%84dp%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="基于决策单调性的dp优化">基于决策单调性的dp优化</h2><h3 id="对于决策单调性的一般解释">对于决策单调性的一般解释</h3><p>对于一个常见的一维<spanclass="math inline">\(dp:dp_i=min/max\{dp_j+w(j,i)\}\)</span>,显然每一个点的dp值只能从<spanclass="math inline">\(\{j|j&lt;i\}\)</span>的<spanclass="math inline">\(dp_j\)</span>转移而来，我们记每一个点<spanclass="math inline">\(i\)</span>的最优决策转移点为<spanclass="math inline">\(p_i\)</span>.如果我们从1-n遍历i，<spanclass="math inline">\(p_i\)</span>也随之单调变化，那么这个dp就具有决策单调性了.大部分决策单调性体现在决策点单调递增，但是也有决策点单调递减的情况(都是建立在枚举的点是从小到大的情况下)</p><h3 id="关于决策单调性的证明">关于决策单调性的证明</h3><p>该部分讲解如无特殊声明，都是建立在求<strong>最小化</strong>问题的基础上，如果要求最大化的话，将对应不等号取反即可</p><h4 id="四边形不等式">四边形不等式</h4><h5 id="一维dp">一维dp</h5><p>对应方程形式<span class="math inline">\(F\)</span> :<spanclass="math inline">\(\largedp_i=min_{j&lt;i}\{dp_j+w(j,i)\}\)</span></p><p>我们考虑<span class="math inline">\(p_1\leq p_2\leq p_3\leqp_4\)</span></p><p>则<strong>最小化情况</strong>下的<strong>四边形不等式</strong>表示为：<spanclass="math inline">\(w(p_1,p_3)+w(p_2,p_4)\leqw(p_1,p_4)+w(p_2,p_3)\)</span></p><p>特别的，如果等号永远成立，称为<strong>四边形恒等式</strong></p><p>一般记为：<strong>交叉<spanclass="math inline">\(\leq\)</span>包含</strong></p><blockquote><p>定理1：如果对于dp式F,其w满足四边形不等式，则F满足决策单调性</p></blockquote><ul><li><p><span class="math inline">\(Proof:\)</span></p><p>反证法。记<spanclass="math inline">\(dp_i\)</span>的最优决策点为<spanclass="math inline">\(p_i\)</span>,假设<spanclass="math inline">\(y&lt;x\)</span>且<spanclass="math inline">\(p_x&lt;p_y\)</span>.根据<spanclass="math inline">\(F\)</span>的定义有：<spanclass="math inline">\(dp_x=dp_{p_x}+w(p_x,x)\leqdp_{p_y}+w(p_y,x)(1)\)</span></p><p>不难发现<spanclass="math inline">\(p_x&lt;p_y&lt;y&lt;x\)</span>,故由四边形不等式：<spanclass="math inline">\(w(p_x,y)+w(p_y,x)\leqw(p_x,x)+w(p_y,y)(2)\)</span></p><p><span class="math inline">\(1,2\)</span>两式相加得到:<spanclass="math inline">\(dp_{p_x}+w(p_x,y)\leqdp_{p_y}+w(p_y,y)\)</span></p><p>则对于<span class="math inline">\(y\)</span>来说，<spanclass="math inline">\(p_x\)</span>是一个比<spanclass="math inline">\(p_y\)</span>更优的决策点，与条件矛盾。</p><p>故<span class="math inline">\(y&lt;x\)</span>意味着<spanclass="math inline">\(p_y\leq p_x\)</span>，单调性得证</p></li></ul><h5 id="区间dp">区间dp</h5><p>一般来说高维dp的决策单调性体现在某一个维度，相对一维dp来说也会更加难发现，但是一种区间dp具有较好的性质</p><p>对应方程形式<span class="math inline">\(F\)</span> <spanclass="math inline">\(\large:dp_{i,j}=min_{k=i}^{j-1}\{dp_{i,k}+dp_{k+1,j}+w(i,j)\}\)</span></p><p>这里先介绍一个跟四边形不等式非常像的<strong>区间包含不等式</strong>：考虑<spanclass="math inline">\(p_1\leq p_2\leq p_3\leq p_4\)</span>,则<spanclass="math inline">\(w(p_1,p_4)\geq w(p_2,p_3)\)</span></p><blockquote><p>引理1：如果对于dp式F，其w同时满足四边形不等式以及区间包含不等式，则F也满足四边形不等式</p></blockquote><ul><li><p><span class="math inline">\(Proof:\)</span></p><p><a href="https://oi-wiki.org/dp/opt/quadrangle/">OIWIKI</a></p></li></ul><blockquote><p>定理2：如果对于dp式F，其满足四边形不等式，记<spanclass="math inline">\(p_{i,j}为dp_{i,j}\)</span>的最优决策点，则<spanclass="math inline">\(\forall i&lt;j,p_{i,j-1}\leq p_{i,j}\leqp_{i+1,j}\)</span></p></blockquote><ul><li><p><span class="math inline">\(Proof:\)</span></p><p><a href="https://oi-wiki.org/dp/opt/quadrangle/">OIWIKI</a></p></li></ul><p>基于此，我们对于<spanclass="math inline">\(F\)</span>就能给出一个复杂度为<spanclass="math inline">\(O(n^2)\)</span>的优化。</p><p>如果在计算<span class="math inline">\(f_{i,j}\)</span>的同时记录<spanclass="math inline">\(p_{i,j}\)</span>，则对决策点<spanclass="math inline">\(K\)</span>的枚举量为<spanclass="math inline">\(\sum_{1\leq i&lt;j\leq n}p_{i+1,j}-p_{i,j-1}=\sum_{i=1}^{n}p_{i,n}-p_{1,i}\leq n^2\)</span></p><p>例题：</p><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=3506">HDU MonkeyParty</a></p><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=3516">HDU TreeConstruction</a></p><p>这里给出Monkey Party的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">2020</span>;<br>ll n;<br>ll mas[N];<br>ll dp[N][N];<br>ll s[N][N];<br>ll sum[N];<br><span class="hljs-function">ll <span class="hljs-title">w</span><span class="hljs-params">(ll l,ll r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> sum[r]-sum[l<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">while</span>(cin&gt;&gt;n)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;mas[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>+n;i&lt;=n+n;++i) mas[i]=mas[i-n];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+n;++i) sum[i]=sum[i<span class="hljs-number">-1</span>]+mas[i];<br><span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dp);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+n;++i) dp[i][i]=<span class="hljs-number">0</span>,s[i][i]=i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">2</span>;len&lt;=n;len++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n-len+<span class="hljs-number">1</span>;i++)&#123;<br>                <span class="hljs-type">int</span> j=i+len<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=s[i][j<span class="hljs-number">-1</span>];k&lt;=s[i+<span class="hljs-number">1</span>][j];k++)&#123;<br>                    <span class="hljs-keyword">if</span>(dp[i][j]&gt;dp[i][k]+dp[k+<span class="hljs-number">1</span>][j]+sum[j]-sum[i<span class="hljs-number">-1</span>])&#123;<br>                        dp[i][j]=dp[i][k]+dp[k+<span class="hljs-number">1</span>][j]+sum[j]-sum[i<span class="hljs-number">-1</span>];<br>                        s[i][j]=k;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>ll ans=<span class="hljs-number">1e17</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>;l&lt;=n;++l)<br>&#123;<br>ans=<span class="hljs-built_in">min</span>(ans,dp[l][l+n<span class="hljs-number">-1</span>]);<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h5 id="一种二维dp">一种二维dp</h5><p>这一块存疑</p><p>也是一种非常常见的dp式<span class="math inline">\(f\)</span> <spanclass="math inline">\(:dp_{i,j}=min_{k&lt;i}\{dp_{k,j-1}+w(k,i)\}\)</span></p><p>理论上它与上一块的区间dp是不同类型的，但是仿佛只要<spanclass="math inline">\(w\)</span>满足引理1，<spanclass="math inline">\(F\)</span>也有同样的结论。我没看到过严格证明，OIWIKI上也没找到对应介绍，但是大家好像都默认这是正确的，而且本人目前没找到反例</p><p>反正用定理2来优化该dp的话，时间复杂度是<spanclass="math inline">\(O(n^2)\)</span>的</p><p>例题：</p><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=3480">HDUDivision</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll int</span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">10005</span>;<br>ll t,n,m;<br>ll dp[N][<span class="hljs-number">5010</span>];<br>ll mas[N];<br><span class="hljs-function">ll <span class="hljs-title">f</span><span class="hljs-params">(ll l,ll r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (mas[r]-mas[l])*(mas[r]-mas[l]);<br>&#125; <br>ll d[N][<span class="hljs-number">5010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;t;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s=<span class="hljs-number">1</span>;s&lt;=t;++s)<br>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;mas[i];<br><span class="hljs-built_in">sort</span>(mas+<span class="hljs-number">1</span>,mas+<span class="hljs-number">1</span>+n);<br><span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dp);<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>&#123;<br>d[n+<span class="hljs-number">1</span>][j]=n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i;--i)<br>&#123;<br>ll tmp=<span class="hljs-number">0x3f3f3f3f</span>;<br>ll p;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=d[i][j<span class="hljs-number">-1</span>];k&lt;=d[i+<span class="hljs-number">1</span>][j];++k)<br>&#123;<br><span class="hljs-keyword">if</span>(tmp&gt;dp[k][j<span class="hljs-number">-1</span>]+<span class="hljs-built_in">f</span>(k+<span class="hljs-number">1</span>,i))<br>&#123;<br>tmp=dp[k][j<span class="hljs-number">-1</span>]+<span class="hljs-built_in">f</span>(k+<span class="hljs-number">1</span>,i);<br>p=k;<br>&#125;<br>&#125;<br>dp[i][j]=tmp;<br>d[i][j]=p;<br>&#125;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;Case &quot;</span>&lt;&lt;s&lt;&lt;<span class="hljs-string">&quot;: &quot;</span>&lt;&lt;dp[n][m]&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h5 id="一些满足四边形不等式的函数类">一些满足四边形不等式的函数类</h5><ul><li>若<spanclass="math inline">\(w_{1(i,j)},w_{2(i,j)}\)</span>均满足四边形不等式（或区间包含不等式），则<spanclass="math inline">\(\forall c_1,c_2\geq 0\)</span>,<spanclass="math inline">\(c_1w_{1(i,j)}+c_2w_{2(i,j)}\)</span>也对应地满足四边形不等式（或区间包含不等式）</li><li>若存在函数<span class="math inline">\(f,g\)</span>，使得<spanclass="math inline">\(w_{l,r}=f_r-g_l\)</span>,则<spanclass="math inline">\(w\)</span>满足<strong>四边形恒等式</strong>（等号永远成立）。当<spanclass="math inline">\(f,g\)</span>单调增的时候，<spanclass="math inline">\(w\)</span>还满足区间包含不等式</li><li>设<spanclass="math inline">\(h_x\)</span>是一个单调增的下凸函数，若<spanclass="math inline">\(w\)</span>满足四边形不等式以及区间包含不等式，则<spanclass="math inline">\(h(w(x))\)</span>也满足四边形不等式以及区间包含不等式</li><li>设<span class="math inline">\(h_x\)</span>是一个下凸函数,若<spanclass="math inline">\(w\)</span>满足<strong>四边形恒等式</strong>以及区间包含不等式，则<spanclass="math inline">\(h(w(x))\)</span>满足四边形不等式</li></ul><p>具体证明详见<ahref="https://oi-wiki.org/dp/opt/quadrangle/">OIWIKI</a></p><p>这里以<a href="https://www.luogu.com.cn/problem/P1912">NOI 2009诗人小G</a>的dp递推式来试着用这些结论证一下决策单调性</p><p><span class="math inline">\(dp_i=min_{0\leqj&lt;i}\{dp_j+|s_i-s_j-1-L|^P\}\)</span>,其中<spanclass="math inline">\(s_i=i+\sum_{k=1}^{i}a_k\)</span>,<spanclass="math inline">\(a_k&gt;0\)</span>为常值</p><p>这里<spanclass="math inline">\(w_{j,i}=|s_i-s_j-1-L|^P\)</span>,我们不妨记<spanclass="math inline">\(m_{j,i}=s_i-s_j-1-L\)</span>,则<spanclass="math inline">\(w_{j,i}=|m_{j,i}|^P\)</span></p><p>我们考虑利用第2条结论：记<spanclass="math inline">\(f_i=s_i-1-L,g_i=s_i\)</span>,显然<spanclass="math inline">\(m_{j,i}=f_i-g_j\)</span>,故<spanclass="math inline">\(m_{j,i}\)</span>满足四边形不等式,又<spanclass="math inline">\(f_i,g_i\)</span>显然单增，故<spanclass="math inline">\(m_{j,i}\)</span>满足区间包含不等式</p><p>又函数<spanclass="math inline">\(|x|^P\)</span>显然是一个下凸函数，故由第4条结论可知，<spanclass="math inline">\(w_{j,i}=m_{j,i}\)</span>也满足四边形不等式。再由定理1，该dp式满足决策单调性。证毕。</p><p>可以看到如果式子能记住的话，在面对一些比较复杂的递推式的时候能够较从容地推出决策单调性，如果直接用四边形不等式的定义硬证这题的话，还是需要不少分类讨论和强大的推柿子能力的（啊...只会套公式的屑）</p><h4 id="与图形相结合">与图形相结合</h4><p>来自一位大佬的<ahref="https://www.luogu.com.cn/problem/solution/P1912">奇妙讨论</a>,从另一个视角帮助我们理解了决策单调性</p><p>这里讨论一维最优化dp，也就是<span class="math inline">\(F\)</span><span class="math inline">\(:dp_i=min_{j\leqi}\{dp_j+w(j,i)\}\)</span></p><p>决策单调性意味着决策点是单调的，换句话说，每一个点能够作为最优决策点的范围是一段连续区间</p><p><img src="https://s2.loli.net/2023/12/19/Ju8HYI5Z7Ge3hcb.png" alt="image-20230904215014871" style="zoom:100%;" /></p><p>在绿色区间内的点都是被<spanclass="math inline">\(dp_{j_1}\)</span>更新，在黄色区间内的点都是被<spanclass="math inline">\(dp_{j_2}\)</span>更新，不会出现黄色区间内有某个点是被<spanclass="math inline">\(dp_{j_1}\)</span>更新的情况，否则就违背了决策单调性的定义</p><p>从几何视角来看这一事实。我们考虑<spanclass="math inline">\(g_j(i)\)</span>，表示<spanclass="math inline">\(dp_j+w(j,i)\)</span>,则<spanclass="math inline">\(dp_i\)</span>可以重新表示为<spanclass="math inline">\(dp_i=min_{j\leqi}\{g_j(i)\}\)</span>。我们可以将<spanclass="math inline">\(g_j(i)\)</span>看成<spanclass="math inline">\(j\)</span>为常值，<spanclass="math inline">\(i\)</span>为自变量的一个函数，那么<spanclass="math inline">\(dp_i\)</span>本质上就是在所有函数<spanclass="math inline">\(g_j(i)\)</span>里取最小值来转移</p><p>还是以上图为例，绿色区间内的点对应函数<spanclass="math inline">\(g_{j_1}(i)\)</span>,黄色区间内对应函数<spanclass="math inline">\(g_{j_2}(i)\)</span>,我们可以得到一个结论：两个函数只能有一个交点，否则就会出现前一段是<spanclass="math inline">\(g_{j_1}(i)\)</span>更小,中间是<spanclass="math inline">\(g_{j_2}(i)\)</span>,后面又变成<spanclass="math inline">\(g_{j_1}(i)\)</span>更小的局面，那就违背了决策单调性的定义。反过来，如果只有一个交点的话，这两段区间就满足决策单调性</p><p>整体来看，我们可以得到：<strong>如果所有<spanclass="math inline">\(g_j(i)\)</span>两两之间都至多只有一个交点的话，<spanclass="math inline">\(F\)</span>是满足决策单调性的</strong>。个人感觉该命题的逆命题并不成立，毕竟实际在转移的时候只用考虑最小值的变化，值较大的函数之间是如何纠缠的我们并不关系。所以该结论应该只适用于证明决策单调性，而不能证否决策单调性</p><p>接下来我们考虑，如果<spanclass="math inline">\(g_j(i)\)</span>之间至多只有一个交点，需要满足什么性质</p><p>该大佬给出的两个条件是：</p><ul><li><spanclass="math inline">\(g_j(i)\)</span>之间可以通过平移相互变换</li><li><spanclass="math inline">\(g_j(i)\)</span>的导函数在定义域内单调增/减（凸性唯一）</li></ul><p>以下分别是不满足对应条件的反例</p><p><img src="https://s2.loli.net/2023/12/19/xuIRkf4nhUZlaJr.png" alt="image-20230904215014871" style="zoom:100%;" /></p><p><img src="https://s2.loli.net/2023/12/19/uT5wJd3liy2AYzs.png" alt="image-20230904215014871" style="zoom:100%;" /></p><p>这两个条件不一定充分，只是感觉上可能也够了</p><p>然后大佬给出的一些总结：</p><ul><li><p>如果导函数递增，求最大值，或导函数递减，求最小值用单调栈</p></li><li><p>如果导函数递增，求最小值，或导函数递减，求最大值用单调队列</p></li></ul><p>具体怎么用单调栈，单调队列，我会在后面有所涉及</p><h3 id="决策单调性的常见优化手段">决策单调性的常见优化手段</h3><h4 id="二分队列">二分队列</h4><p>这应该算是最常见的一种利用决策单调性来优化dp的手段了。它只能用于决策点单调增的情况。</p><p>考虑之前的一个结论：每一个决策点的更新范围是一段连续区间。这意味着相邻两个决策点的更新范围之间存在着一个分界线<spanclass="math inline">\(K\)</span>,当<spanclass="math inline">\(i&lt;=k\)</span>的时候，由前一个点<spanclass="math inline">\(j_1\)</span>更新，之后就由后一个点<spanclass="math inline">\(j_2\)</span>更新,并且<spanclass="math inline">\(j_1\)</span>就再也没有机会了。那么我们就可以维护一个单调队列来实现每次<spanclass="math inline">\(O(logn)\)</span>的更新</p><p>具体来说，我们的单调队列中的每一个元素是一个三元组<spanclass="math inline">\(\{P,l_p,r_p\}\)</span>,分别表示当前的决策点<spanclass="math inline">\(P\)</span>,它能更新区间的左界<spanclass="math inline">\(l_p\)</span>,它能更新区间的右界<spanclass="math inline">\(r_p\)</span>。那么当我们尝试更新<spanclass="math inline">\(dp_i\)</span>的时候，</p><ul><li><p>弹出队头。因为队列里的点的对应决策区间是单调的，所以我们可以直接将<spanclass="math inline">\(r_p&lt;i\)</span>的队头三元组不断弹出。</p></li><li><p>用队头的<span class="math inline">\(P\)</span>更新<spanclass="math inline">\(dp_i\)</span></p></li><li><p>将三元组<spanclass="math inline">\(\{i,l_i,r_i\}\)</span>放入队列尾部。那么怎么求<spanclass="math inline">\(l_i,r_i\)</span>?在求<spanclass="math inline">\(l_i\)</span>之前，我们要意识到一个事实：我们所求的<spanclass="math inline">\(l_p,r_p\)</span>都是建立在已经遍历到的点的信息上而建立的，换句话说，随着后面新的点<spanclass="math inline">\(i\)</span>加入，它的决策区间有可能会完全包含某一个点<spanclass="math inline">\(P\)</span>的决策区间。这一点很好理解：原本<spanclass="math inline">\(l_i,r_i\)</span>就是由<spanclass="math inline">\(i\)</span>更新的，但是因为我们还没有遍历到<spanclass="math inline">\(i\)</span>,所以这段区间就会先被其它点占据。所以我们在求<spanclass="math inline">\(l_i\)</span>之前，要先将队尾那些完全不会比<spanclass="math inline">\(i\)</span>优的点踢出。具体如何判断？我们只要看一下在<spanclass="math inline">\(l_p\)</span>处<spanclass="math inline">\(i\)</span>是否比<spanclass="math inline">\(P\)</span>更优即可。如果是，显然<spanclass="math inline">\(P\)</span>就再也没有机会比<spanclass="math inline">\(i\)</span>更优了，因为<spanclass="math inline">\(p&lt;i\)</span>。</p><p>该操作之后<span class="math inline">\(i\)</span>就不能将队尾的<spanclass="math inline">\(P\)</span>的区间完全覆盖了，我们就可以利用单调性二分一下两者的决策区间的边界，作为<spanclass="math inline">\(l_i\)</span>.至于<spanclass="math inline">\(r_i\)</span>,我们直接设成<spanclass="math inline">\(n\)</span>即可。毕竟此时后面的点还没加入，我们只能用<spanclass="math inline">\(i\)</span>来更新它们。</p></li></ul><p>贴个模板</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs stata">void Optimize()<br>&#123;<br>    <span class="hljs-comment">//该模板适用于最小化问题，若求最大化，自行将对应不等号取反即可</span><br>    <span class="hljs-comment">//cal()</span><br>    hd=1,tl=0;<br>    <span class="hljs-keyword">que</span>[++tl]=0;<span class="hljs-keyword">ls</span>[0]=1,rs[0]=<span class="hljs-keyword">n</span>;<br>    <span class="hljs-keyword">for</span>(int i=1;i&lt;=<span class="hljs-keyword">n</span>;++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;rs[<span class="hljs-keyword">que</span>[hd]]&lt;i) hd++;<span class="hljs-comment">//弹出无用点</span><br>        dp[i]=cal(<span class="hljs-keyword">que</span>[hd],i);<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;cal(i,<span class="hljs-keyword">ls</span>[<span class="hljs-keyword">que</span>[tl]])&lt;=cal(<span class="hljs-keyword">que</span>[tl],<span class="hljs-keyword">ls</span>[<span class="hljs-keyword">que</span>[tl]])) tl--;<span class="hljs-comment">//弹出无用点，若要求最大这里要改方向</span><br>        ll <span class="hljs-keyword">l</span>=<span class="hljs-keyword">ls</span>[<span class="hljs-keyword">que</span>[tl]],r=<span class="hljs-keyword">n</span>+1;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">l</span>&lt;=r)<br>        &#123;<br>            ll mid=(<span class="hljs-keyword">l</span>+r)&gt;&gt;1;<br>            <span class="hljs-keyword">if</span>(cal(i,mid)&lt;=cal(<span class="hljs-keyword">que</span>[tl],mid)) r=mid-1;<span class="hljs-comment">//若要求最大这里要改方向</span><br>            <span class="hljs-comment">//二分查找i与que[tl]的转移分界点，也就是最小的满足i优于que[tl]的点</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">l</span>=mid+1;<br>        &#125;<br>        p_ans=r+1;<br>        <span class="hljs-keyword">if</span>(p_ans&gt;<span class="hljs-keyword">n</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//i并没有用</span><br>        rs[<span class="hljs-keyword">que</span>[tl]]=p_ans-1;<br>        <span class="hljs-keyword">que</span>[++tl]=i;<span class="hljs-comment">//插入队列</span><br>        <span class="hljs-keyword">ls</span>[i]=p_ans,rs[i]=<span class="hljs-keyword">n</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Tips:二分决策区间边界的时候，右界设置为n+1,因为i有可能完全不如P优，要防一手</p></blockquote><p>如果<span class="math inline">\(w(j,i)\)</span>我们能够以<spanclass="math inline">\(O(1)\)</span>的复杂度求出的话，该方法的时间复杂度式<spanclass="math inline">\(O(nlog)\)</span>的</p><p>例题：</p><p><a href="https://www.luogu.com.cn/problem/P1912">NOI 2009诗人小G</a></p><p>dp式并不难列出，关于其决策单调性我们已经在上一块里证明过了，所以这里直接用二分队列即可</p><p>数据范围有点大，记得开long double</p><p>code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ld long double</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IL inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">100010</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">998244353</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> X=<span class="hljs-number">0</span>; <span class="hljs-type">bool</span> flag=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">0</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="hljs-number">1</span>)+(X&lt;&lt;<span class="hljs-number">3</span>)+ch-<span class="hljs-string">&#x27;0&#x27;</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> X;<br>    <span class="hljs-keyword">return</span> ~(X<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-type">int</span> n,L,P;<br><span class="hljs-type">char</span> s[N][<span class="hljs-number">50</span>];<br>ld mas[N];<br><span class="hljs-type">int</span> ls[N],rs[N],pre[N];<span class="hljs-comment">//记录最优决策点</span><br><span class="hljs-type">int</span> que[N];<br><span class="hljs-type">int</span> hd,tl,p_ans;<br>ld dp[N];<br><span class="hljs-function">ld <span class="hljs-title">ksm</span><span class="hljs-params">(ld x,ll y)</span></span><br><span class="hljs-function"></span>&#123;<br>    ld ans=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(y)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) ans=ans*x;<br>        x=x*x;<br>        y&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function">ld <span class="hljs-title">cal</span><span class="hljs-params">(ll k,ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> dp[k]+<span class="hljs-built_in">ksm</span>(<span class="hljs-built_in">abs</span>(mas[x]-mas[k]<span class="hljs-number">-1</span>-L),P);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    n=<span class="hljs-built_in">read</span>();L=<span class="hljs-built_in">read</span>();P=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s[i]);<br>    <span class="hljs-comment">// for(int i=1;i&lt;=n;++i) cin&gt;&gt;s[i];</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        mas[i]=mas[i<span class="hljs-number">-1</span>]+<span class="hljs-built_in">strlen</span>(s[i])+<span class="hljs-number">1</span>;<br>    &#125;<br>    hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>    que[++tl]=<span class="hljs-number">0</span>;ls[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>,rs[<span class="hljs-number">0</span>]=n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;rs[que[hd]]&lt;i) hd++;<br>        dp[i]=<span class="hljs-built_in">cal</span>(que[hd],i);<br>        pre[i]=que[hd];<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">cal</span>(i,ls[que[tl]])&lt;=<span class="hljs-built_in">cal</span>(que[tl],ls[que[tl]])) tl--;<br>        ll l=ls[que[tl]],r=n+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;=r)<br>        &#123;<br>            ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cal</span>(i,mid)&lt;=<span class="hljs-built_in">cal</span>(que[tl],mid)) r=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-comment">//二分查找i与que[tl]的转移分界点，也就是最小的满足i优于que[tl]的点</span><br>            <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        p_ans=r+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(p_ans&gt;n) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//i并没有用</span><br>        rs[que[tl]]=p_ans<span class="hljs-number">-1</span>;<br>        que[++tl]=i;<span class="hljs-comment">//插入队列</span><br>        ls[i]=p_ans,rs[i]=n;<br>    &#125;<br>    <span class="hljs-comment">///////</span><br><br>    <span class="hljs-keyword">if</span>(dp[n]&gt;inf)<br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Too hard to arrange&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(ll)dp[n]);<br>        vector&lt;string&gt; ans;<br>        ll pos=n;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>        &#123;<br>            ll x=pre[pos]+<span class="hljs-number">1</span>;<br>            string ss=<span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;pos;++i) ss+=s[i],ss+=<span class="hljs-string">&quot; &quot;</span>;<br>            ss+=s[pos];<br>            ans.<span class="hljs-built_in">push_back</span>(ss);<br>            pos=pre[pos];<br>            <span class="hljs-keyword">if</span>(pos==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:ans) cout&lt;&lt;i&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;--------------------&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);</span><br>    ll t;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--)<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二分栈">二分栈</h4><p>一般用于最优决策点是不增的情况。在原本的二分队列的做法中，我们从队列的首部取出最优决策点，从队列的尾部放入决策点。那么如果决策点是不增的，意味着我们需要从队列的尾部取最优决策点。这样取和放的操作都是在队列的尾部，我们只要用一个栈来实现就好了。同样的，相邻的两个决策点更新的区间会有一个边界，我们不妨记为<spanclass="math inline">\(k_{l,r}\)</span>,当尝试加入<spanclass="math inline">\(i\)</span>的时候，记队列倒数第一个元素为<spanclass="math inline">\(p_1\)</span>,倒数第二个元素为<spanclass="math inline">\(p_2\)</span>,那么如果<spanclass="math inline">\(k_{p_1,p_2}\leq k_{p_2,i}\)</span>,那么<spanclass="math inline">\(p_2\)</span>就可以踢掉了，因为它不管在什么时候都不会是<spanclass="math inline">\(i,p_1,p_2\)</span>中的最优解。然后将<spanclass="math inline">\(i\)</span>加入队列之后再按照<spanclass="math inline">\(k_{p_1,p_2}\)</span>是否<spanclass="math inline">\(\leq i\)</span>来踢即可</p><p><a href="https://www.luogu.com.cn/problem/P5504">JSOI2001柠檬</a></p><p>思路：</p><p>首先不难发现最优选择下每一段的首尾的颜色就是这段的<spanclass="math inline">\(s_0\)</span>，否则我们就可以将首尾的没用的点分出去自称一段，贡献一定更优</p><p>所以我们可以按照不同的颜色来分开处理</p><p><span class="math inline">\(dp_i=max_{col_j=col_i,j\leqi}\{dp_{j-1}+w(j,i)\}\)</span>,其中<spanclass="math inline">\(w(j,i)=(sum_i-sum_j+1)^2\)</span></p><p>这里我们画图就能发现决策点是单调不增的（按照上文与图形结合的方法），所以可以使用二分栈。但是这题的决策单调性是在相同颜色的点之间才存在的，所以我们要分开来做二分栈</p><p>然后每一个点不会从0转移，所以一开始也不用把0放进去</p><p>code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> il inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bc(idx) vt[idx].size()-1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bd(idx) vt[idx].size()-2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> g(a,b) vt[a][b]</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">200000</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br>ll n;<br>ll mas[N];<br>vector&lt;ll&gt; vt[N];<br>ll dp[N];<br>ll ls[N],rs[N];<br>map&lt;ll,ll&gt; mp;<br>ll sum[N];<br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll k,ll num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> dp[k<span class="hljs-number">-1</span>]+mas[k]*num*num;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">gtf</span><span class="hljs-params">(ll a,ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll l=<span class="hljs-number">1</span>,r=n;<br>    <span class="hljs-keyword">while</span>(l&lt;=r)<br>    &#123;<br>        ll mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(a,mid-sum[a]+<span class="hljs-number">1</span>)&gt;=<span class="hljs-built_in">gt</span>(b,mid-sum[b]+<span class="hljs-number">1</span>)) r=mid<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;mas[i];<br>        mp[mas[i]]++;<br>        sum[i]=mp[mas[i]];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        ll idx=mas[i];<br>        <span class="hljs-keyword">while</span>(vt[idx].<span class="hljs-built_in">size</span>()&gt;=<span class="hljs-number">2</span>&amp;&amp; <span class="hljs-built_in">gtf</span>(<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bd</span>(idx)),<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bc</span>(idx)))&lt;=<span class="hljs-built_in">gtf</span>(<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bc</span>(idx)),i)) vt[idx].<span class="hljs-built_in">pop_back</span>();<br>        vt[idx].<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">while</span>(vt[idx].<span class="hljs-built_in">size</span>()&gt;=<span class="hljs-number">2</span>&amp;&amp; <span class="hljs-built_in">gtf</span>(<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bd</span>(idx)),<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bc</span>(idx)))&lt;=sum[i]) vt[idx].<span class="hljs-built_in">pop_back</span>();<br>        dp[i]=<span class="hljs-built_in">gt</span>(<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bc</span>(idx)),sum[i]-sum[<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bc</span>(idx))]+<span class="hljs-number">1</span>);<br>    &#125;<br>    cout&lt;&lt;dp[n]&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="分治">分治</h4><p>分治的方法主要用于同一层之间的点相互之间线性无关的情况。</p><p>比如<span class="math inline">\(F_1\)</span> <spanclass="math inline">\(:dp_{i,j}=min\{dp_{i-1,k}+w(k,i)\}\)</span>.<spanclass="math inline">\(F_2\)</span> <spanclass="math inline">\(:dp_i=min\{a_k+w(k,i)\}\)</span></p><p>可以看到同一层之间的点不会相互转移</p><p>那么如果同一层的点满足决策单调性的话，也就是意味着决策点是单调的，我们就可以采用分治的策略来优化转移的过程</p><p>假设当前需要转移的区间是<spanclass="math inline">\([L,R]\)</span>,决策点的选择区间是<spanclass="math inline">\([p_l,p_r]\)</span>(显然一开始转移区间和决策点的选择区间都为<spanclass="math inline">\([1,n]\)</span>)，设<spanclass="math inline">\(mid=\frac{L+R}{2}\)</span>,我们可以先暴力求出<spanclass="math inline">\(mid\)</span>的最优决策点<spanclass="math inline">\(pos\)</span>,那么<spanclass="math inline">\([L,mid-1]\)</span>的决策点选择区间就是<spanclass="math inline">\([p_l,pos]\)</span>,<spanclass="math inline">\([mid+1,R]\)</span>的决策点选择区间就是<spanclass="math inline">\([pos,p_r]\)</span>，那么这样分治下去就好了。</p><p>如果我们可以<spanclass="math inline">\(O(1)\)</span>求代价的话，对<spanclass="math inline">\(mid\)</span>求<spanclass="math inline">\(pos\)</span>的时间复杂度就只有<spanclass="math inline">\(O(n)\)</span>,再加上每次要处理的区间长度会变成原本的一半，所以处理区间为n的复杂度是<spanclass="math inline">\(f(n)=O(n)+O(f(n/2))\)</span>,总复杂度是<spanclass="math inline">\(O(nlogn)\)</span></p><p>一个板子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solve</span><span class="hljs-params">(ll l,ll r,ll pl,ll pr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//当前分治处理区间是[l,r],最佳决策区间是[pl,pr]</span><br>ll mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>ll pos;<span class="hljs-comment">//mid的最佳决策点</span><br>dp[mid]=<span class="hljs-built_in">gt</span>(pos=pl,mid);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pl+<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">min</span>(mid<span class="hljs-number">-1</span>,pr);++i)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(i,mid)&lt;dp[mid]) dp[mid]=<span class="hljs-built_in">gt</span>(pos=i,mid);<br>&#125;<br><span class="hljs-keyword">if</span>(l&lt;mid) <span class="hljs-built_in">Solve</span>(l,mid<span class="hljs-number">-1</span>,pl,pos);<br><span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">Solve</span>(mid+<span class="hljs-number">1</span>,r,pos,pr);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P5503">JSOI2016灯塔</a></p><p>大意：</p><p>给定<span class="math inline">\(h_i\)</span>，对于每一个<spanclass="math inline">\(i\)</span>,要求<span class="math inline">\(\forallj,p_i\geq h_j-h_i+\sqrt{|i-j|}\)</span>,求最小的<spanclass="math inline">\(p_i\)</span></p><p>思路：</p><p>不妨先将绝对值去掉，那么<spanclass="math inline">\(p_i=\left\{\begin{matrix}min\{h_j+\sqrt{i-j}-h_i\} &amp; j&lt;i\\ min\{h_j+\sqrt{j-i}-h_i\} &amp;j&gt;i \end{matrix}\right.\)</span></p><p>那么我们只要处理第一个式子就好了，第二个式子只要把整个数组反一下即可</p><p>可以发现<spanclass="math inline">\(p_i=min\{h_j+\sqrt{i-j}-h_i\}\)</span>满足决策单调性，并且<spanclass="math inline">\(p_i\)</span>之间相互无关，所以直接分治就解决了</p><p>code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IL inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">5e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> ep=<span class="hljs-number">1e-9</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">998244353</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br>ll n;<br>ll mas[N];<br><span class="hljs-type">double</span> dp1[N],dp2[N];<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">gt</span><span class="hljs-params">(ll p,ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> mas[p]+<span class="hljs-built_in">sqrt</span>(x-p)-mas[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solve</span><span class="hljs-params">(ll l,ll r,ll pl,ll pr,<span class="hljs-type">double</span> *dp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// if(l&gt;r||pl&gt;pr) return;</span><br>    ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    ll pos=pl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pl;i&lt;=<span class="hljs-built_in">min</span>(mid,pr);++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(i,mid)-dp[mid]&gt;=-ep) dp[mid]=<span class="hljs-built_in">gt</span>(pos=i,mid);<span class="hljs-comment">//要取&gt;=0</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(l&lt;mid) <span class="hljs-built_in">Solve</span>(l,mid<span class="hljs-number">-1</span>,pl,pos,dp);<br>    <span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">Solve</span>(mid+<span class="hljs-number">1</span>,r,pos,pr,dp);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;mas[i];<br>    <span class="hljs-built_in">Solve</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,n,dp1);<br>    <span class="hljs-built_in">reverse</span>(mas+<span class="hljs-number">1</span>,mas+<span class="hljs-number">1</span>+n);<br>    <span class="hljs-built_in">Solve</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,n,dp2);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-type">double</span> x=<span class="hljs-built_in">fmax</span>(dp1[i],dp2[n-i+<span class="hljs-number">1</span>]);<br>        cout&lt;&lt;(ll)<span class="hljs-built_in">ceil</span>(x)&lt;&lt;endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// ll t;t=read();while(t--)</span><br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P4072">SDOI2016征途</a></p><p><a href="https://www.luogu.com.cn/problem/CF321E">CF321 E</a></p><h5 id="类莫队做法">类莫队做法</h5><p>注意到分治要保证时间复杂度的前提是每次求<spanclass="math inline">\(w\)</span>代价的复杂度是<spanclass="math inline">\(O(1)\)</span>的</p><p>但是有一类<spanclass="math inline">\(w\)</span>比较特殊：关于区间的信息的记录，比如区间数字种类数等。这种问题我们一般可以离线下来用莫队处理，那么仿照莫队用左右端点的连续移动就可以做到<spanclass="math inline">\(O(1)\)</span>转移了，因为我们的决策点的选择范围也刚好是一个连续的区间，所以这样的话复杂度是正确的</p><p><a href="https://www.luogu.com.cn/problem/CF868F">CF868 F</a></p><p><a href="https://www.luogu.com.cn/problem/P5574">CmdOI2019任务分配问题</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IL inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">3e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> ep=<span class="hljs-number">1e-9</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">998244353</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tree</span><br>&#123;<br>    ll tr[N];<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> low(x) x&amp;(-x)</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(x&lt;N)<br>        &#123;<br>            tr[x]+=y;<br>            x+=<span class="hljs-built_in">low</span>(x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">sum</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ll ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x)<br>        &#123;<br>            ans+=tr[x];<br>            x-=<span class="hljs-built_in">low</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;T;<br>ll n,k;<br>ll mas[N];<br>ll dp[N],pp[N];<br><span class="hljs-keyword">namespace</span> Mo<br>&#123;<br>    <span class="hljs-type">int</span> L=<span class="hljs-number">1</span>,R=<span class="hljs-number">0</span>;<br>    ll ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> col[N];<br>    ll cnt[N];<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add1</span><span class="hljs-params">(ll pos,ll op)</span><span class="hljs-comment">//区间左边</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)<br>        &#123;<br>            ans+=T.<span class="hljs-built_in">sum</span>(n+<span class="hljs-number">1</span>)-T.<span class="hljs-built_in">sum</span>(col[pos]);<br>            T.<span class="hljs-built_in">add</span>(col[pos],<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ans-=T.<span class="hljs-built_in">sum</span>(n+<span class="hljs-number">1</span>)-T.<span class="hljs-built_in">sum</span>(col[pos]);<br>            T.<span class="hljs-built_in">add</span>(col[pos],<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add2</span><span class="hljs-params">(ll pos,ll op)</span><span class="hljs-comment">//区间右边</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)<br>        &#123;<br>            ans+=T.<span class="hljs-built_in">sum</span>(col[pos]<span class="hljs-number">-1</span>);<br>            T.<span class="hljs-built_in">add</span>(col[pos],<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ans-=T.<span class="hljs-built_in">sum</span>(col[pos]<span class="hljs-number">-1</span>);<br>            T.<span class="hljs-built_in">add</span>(col[pos],<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll l,ll r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        l++;<br>        <span class="hljs-keyword">while</span>(L&lt;l) <span class="hljs-built_in">add1</span>(L++,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span>(L&gt;l) <span class="hljs-built_in">add1</span>(--L,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span>(R&gt;r) <span class="hljs-built_in">add2</span>(R--,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span>(R&lt;r) <span class="hljs-built_in">add2</span>(++R,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> pp[l<span class="hljs-number">-1</span>]+ans;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solve</span><span class="hljs-params">(ll l,ll r,ll pl,ll pr)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    ll pos;<br>    dp[mid]=Mo::<span class="hljs-built_in">gt</span>(pos=pl,mid);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pl+<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">min</span>(mid<span class="hljs-number">-1</span>,pr);++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(dp[mid]&gt;Mo::<span class="hljs-built_in">gt</span>(i,mid)) dp[mid]=Mo::<span class="hljs-built_in">gt</span>(pos=i,mid);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(l&lt;mid) <span class="hljs-built_in">Solve</span>(l,mid<span class="hljs-number">-1</span>,pl,pos);<br>    <span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">Solve</span>(mid+<span class="hljs-number">1</span>,r,pos,pr);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;Mo::col[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) pp[i]=Mo::<span class="hljs-built_in">gt</span>(<span class="hljs-number">0</span>,i);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;k;++i)<br>    &#123;<br>        <span class="hljs-built_in">Solve</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">0</span>,n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) pp[j]=dp[j];<br>    &#125;<br>    cout&lt;&lt;pp[n]&lt;&lt;endl;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// ll t;t=read();while(t--)</span><br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="smawk">SMAWK</h4><p>SMAWK的用途跟分治一样，用于处理同一层之间没有转移关系的情况，但是复杂度会更优，可以达到<spanclass="math inline">\(O(n)\)</span></p><p>我们考虑从另一个角度来理解决策单调性</p><blockquote><p><strong>定义1</strong>若矩阵A满足∀i,j∈[0,k],pos(i)&lt;pos(j)则称A为单调矩阵。若A的任意子矩阵均为单调矩阵，则称A为完全单调矩阵</p></blockquote><p>重新定义四边形不等式</p><blockquote><p>定义2 对于n*m的矩阵A，若<span class="math inline">\(\forall1&lt;i_1&lt;i_2\leq n,1\leq j_1,\leq j_2\leq m\)</span>,均有<spanclass="math inline">\(A_{i_1,j_1}+A_{i_2,j_2}\leqA_{i_1,j_2}+A_{i_2,j_1}\)</span>,则称A满足四边形不等式</p></blockquote><p>快速判断矩阵是否满足四边形不等式：</p><blockquote><p>定理1 对于n*m的矩阵A，若<span class="math inline">\(\forall1&lt;i&lt;n,1\leq j&lt;m\)</span>,均有<spanclass="math inline">\(A_{i,j}+A_{i+1,j+1}\leqA_{i,j+1}+A_{i+1,j}\)</span>,则称A满足四边形不等式</p></blockquote><blockquote><p>定理2 若矩阵A满足四边形不等式，则A以及<spanclass="math inline">\(A^{T}\)</span>是完全单调矩阵</p></blockquote><p>接下来考虑<spanclass="math inline">\(dp_i=min_{j&lt;i}\{a_j+w(j,i)\}\)</span>,放到矩阵上，当<spanclass="math inline">\(j&lt;i\)</span>时，<spanclass="math inline">\(A_{i,j}=dp_j+w(j,i),j\geq i\)</span>时，令<spanclass="math inline">\(A_{i,j}=inf\)</span>，那么求<spanclass="math inline">\(dp_i\)</span>其实就是在第i行找最小值对应的列j.如果矩阵是一个单调矩阵，也就是dp满足决策单调性，我们就可以采用SMAWK</p><p>SMAWK的核心内容是reduce的过程，当列数m远大于n的时候，我们的枚举量会多很多，但是其实一行只会对应一个最优列，所以大量列是多余的，reduce过程就是在去除这些冗余列</p><p>当然，为了保证一行只有一个答案，我们要限定取每一行最左边/最右边的最小值<strong>（这一点在与WQS二分结合的时候很重要）</strong></p><p>其步骤如下：</p><ul><li><p>1初始定义 <em>k</em> = 1；</p></li><li><p>2当 <em>n</em> <em>≥</em> <em>m</em> 时结束过程；否则比较 <spanclass="math inline">\(A_{k,k}\)</span> 和 <spanclass="math inline">\(A_{k,k+1}\)</span></p></li><li><p>3若 <span class="math inline">\(A_{k,k}\geqA_{k,k+1}\)</span>，删除第 <em>k</em> 列，<em>k</em> <em>←</em>max(<em>k</em> <em>−</em> 1<em>,</em> 1)，回到步骤 2；</p></li><li><p>4若 <span class="math inline">\(A_{k,k}&lt; A_{k,k+1}\)</span> 且<em>k</em> = <em>n</em>，删除第 <em>n</em> + 1 列，回到步骤 2；</p></li><li><p>5若 <span class="math inline">\(A_{k,k}&lt; A_{k,k+1}\)</span> 且<em>k</em> = <em>n</em>，<em>k</em> <em>←</em> <em>k</em> + 1，回到步骤2。</p></li></ul><p>每一步的原因还是很显然的，这里不多赘述了。复杂度是<spanclass="math inline">\(O(m+n)\)</span></p><p>为了保证线性复杂度的正确性，可以用链表实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    ll val,opt;<br>    Node *lst,*nxt;<br>    <span class="hljs-built_in">Node</span>()&#123;val=opt=<span class="hljs-number">0</span>;lst=nxt=<span class="hljs-literal">NULL</span>;&#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">List</span><br>&#123;<br>    ll len;<span class="hljs-comment">//列表长度</span><br>    Node *s,*e;<br>    <span class="hljs-built_in">List</span>()<br>    &#123;<br>        len=<span class="hljs-number">0</span>;<br>        s=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();s-&gt;opt=<span class="hljs-number">1</span>;<br>        e=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();e-&gt;opt=<span class="hljs-number">-1</span>;<br>        s-&gt;nxt=e;e-&gt;lst=s;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//将x加入尾部</span><br>        Node *n=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        n-&gt;val=x;<br>        Node *a=e-&gt;lst;<span class="hljs-comment">//尾部元素</span><br>        a-&gt;nxt=n;n-&gt;lst=a;<br>        n-&gt;nxt=e;e-&gt;lst=n;<br>        len++;<span class="hljs-comment">//长度</span><br>    &#125;<br>    <span class="hljs-built_in">List</span>(<span class="hljs-type">const</span> List &amp;a)<br>    &#123;<br>        <span class="hljs-comment">//Copy</span><br>        len=<span class="hljs-number">0</span>;<br>        s=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();s-&gt;opt=<span class="hljs-number">1</span>;<br>        e=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();e-&gt;opt=<span class="hljs-number">-1</span>;<br>        s-&gt;nxt=e;e-&gt;lst=s;<br>        Node *n=a.s-&gt;nxt;<br>        <span class="hljs-keyword">while</span>(n-&gt;opt!=<span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-built_in">append</span>(n-&gt;val);<br>            n=n-&gt;nxt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">Node* <span class="hljs-title">del</span><span class="hljs-params">(Node *n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        --len;<br>        Node *a=n-&gt;lst,*b=n-&gt;nxt;<br>        a-&gt;nxt=b,b-&gt;lst=a;<br>        <span class="hljs-built_in">delete</span>(n);<br>        <span class="hljs-keyword">return</span> a;<span class="hljs-comment">//前一个节点</span><br>    &#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">submat</span><br>&#123;<br>    List r,c;<br>    <span class="hljs-comment">//row,column</span><br>&#125;A;<br><span class="hljs-function">submat <span class="hljs-title">Reduce</span><span class="hljs-params">(<span class="hljs-type">const</span> submat &amp;A)</span></span><br><span class="hljs-function"></span>&#123;<br>    submat B;<br>    B.r=(List)A.r;B.c=(List)A.c;<br>    <span class="hljs-type">int</span> n=A.r.len;<span class="hljs-comment">//行数</span><br>    <span class="hljs-type">int</span> m=A.c.len;<span class="hljs-comment">//列数</span><br>    Node *nr=B.r.s-&gt;nxt;<span class="hljs-comment">//第一个节点</span><br>    Node *nc=B.c.s-&gt;nxt;<br>    ll k=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(n&lt;m)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(nr-&gt;val,nc-&gt;val)&gt;<span class="hljs-built_in">get</span>(nr-&gt;val,nc-&gt;nxt-&gt;val))<br>        &#123;<br>            nc=B.c.<span class="hljs-built_in">del</span>(nc);<br>            m--;<br>            <span class="hljs-keyword">if</span>(k&gt;<span class="hljs-number">1</span>)<br>            &#123;<br>                --k;<br>                nr=nr-&gt;lst;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">//k=1</span><br>                nr=B.r.s-&gt;nxt;nc=B.c.s-&gt;nxt;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k==n)<br>        &#123;<br>            B.c.<span class="hljs-built_in">del</span>(nc-&gt;nxt);m--;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            k++;<br>            nr=nr-&gt;nxt;nc=nc-&gt;nxt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> B;<br>&#125;<br></code></pre></td></tr></table></figure><p>reduce之后我们就真正开始SMAWK了</p><p>SMAWK(A) 表示计算 <em>n</em> <em>×</em> <em>m</em> 的完全单调矩阵<em>A</em> 的<strong>每行最小值</strong>所在</p><p>列。步骤如下：</p><ul><li>1若 min(<em>n,</em> <em>m</em>) = 1 直接计算答案；</li><li>2对Areduce，得到矩阵B,并且我们取其所有偶数行组成一个新矩阵C</li><li>4递归SMAWK(C),得到C的每一行的最小值所在位置</li><li>4对于B中的奇数行，其答案在相邻两行的答案之间，那么之间暴力遍历一下即可。该步骤的复杂度为<spanclass="math inline">\(O(m)\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SMAWK</span><span class="hljs-params">(submat A)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n=A.r.len;<span class="hljs-comment">//行数</span><br>    <span class="hljs-type">int</span> m=A.c.len;<span class="hljs-comment">//列数</span><br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>    &#123;<br>        ll x=A.r.s-&gt;nxt-&gt;val;<span class="hljs-comment">//只有一行</span><br>        Node *nc=A.c.s-&gt;nxt;<br>        ll maxn=<span class="hljs-number">0</span>;<br>        ll maxp=<span class="hljs-number">0</span>;<span class="hljs-comment">//最值位置</span><br>        <span class="hljs-keyword">while</span>(nc-&gt;opt!=<span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(x,nc-&gt;val)&gt;=maxn)<br>            &#123;<br>                maxp=nc-&gt;val,maxn=<span class="hljs-built_in">get</span>(x,nc-&gt;val);<br>            &#125;<br>            nc=nc-&gt;nxt;<br>        &#125;<br>        ans[x]=maxp;<span class="hljs-comment">//存储最大值所在位置</span><br>        <span class="hljs-comment">///</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(m==<span class="hljs-number">1</span>)<br>    &#123;<br>        ll y=A.c.s-&gt;nxt-&gt;val;<br>        Node *nr=A.r.s-&gt;nxt;<span class="hljs-comment">//第一行</span><br>        <span class="hljs-keyword">while</span>(nr-&gt;opt!=<span class="hljs-number">-1</span>)<br>        &#123;<br>            ans[nr-&gt;val]=y;<br>            nr=nr-&gt;nxt;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    submat B=<span class="hljs-built_in">Reduce</span>(A);<br>    submat C;C.c=<span class="hljs-built_in">List</span>(B.c);<span class="hljs-comment">//首先保存每一列的信息</span><br>    Node *nr=B.r.s-&gt;nxt;<span class="hljs-comment">//行第一个元素</span><br>    <span class="hljs-type">bool</span> fl=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(nr-&gt;opt!=<span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(fl) C.r.<span class="hljs-built_in">append</span>(nr-&gt;val);<span class="hljs-comment">//C保存偶数行</span><br>        nr=nr-&gt;nxt;<br>        fl^=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//得到一个只有偶数行，列不变的矩阵</span><br>    <span class="hljs-built_in">SMAWK</span>(C);<span class="hljs-comment">//递归</span><br>    nr=B.r.s-&gt;nxt;fl=<span class="hljs-number">0</span>;<br>    Node *nc=B.c.s-&gt;nxt;<span class="hljs-comment">//列指针</span><br>    <span class="hljs-keyword">while</span>(nr-&gt;opt!=<span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!fl)<br>        &#123;<br>            ll z=ans[nr-&gt;nxt-&gt;val];<span class="hljs-comment">//已经处理过了，这里是有值的</span><br>            ll x=nr-&gt;val;<br>            ll maxn=<span class="hljs-number">0</span>,maxp=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(z==<span class="hljs-number">0</span>) z=inf;<br>            <span class="hljs-keyword">while</span>(nc-&gt;opt!=<span class="hljs-number">-1</span> &amp;&amp; nc-&gt;val&lt;=z)<br>            &#123;<br>                <span class="hljs-comment">//枚举列</span><br>                <span class="hljs-comment">//返回的是最右边的最小值</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(x,nc-&gt;val)&gt;=maxn)<br>                &#123;<br>                    maxn=<span class="hljs-built_in">get</span>(x,nc-&gt;val);<br>                    maxp=nc-&gt;val;<br>                &#125;<br>                nc=nc-&gt;nxt;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nc-&gt;lst-&gt;val==z) nc=nc-&gt;lst;<br>            ans[x]=maxp;<br>        &#125;<br>        nr=nr-&gt;nxt;<br>        fl^=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>理论上是可以平替分治的，但是写起来太烦了。。。</p><p>有一份短一点的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//求每行最左边最小值</span><br><span class="hljs-type">int</span> pre[N],suf[N],M[N],n,m,ans=<span class="hljs-number">1e18</span>,P=<span class="hljs-number">0</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;L,H;<br>map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;Mp[N];<br><span class="hljs-function">ll <span class="hljs-title">get</span><span class="hljs-params">(ll a,ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//返回第a行第b列的元素</span><br>&#125; <br><span class="hljs-type">int</span> pre[N],suf[N],M[N],P=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (pre[x]!=<span class="hljs-number">-1</span>)<br>        suf[pre[x]]=suf[x]; <span class="hljs-keyword">else</span> P=suf[x];<br>    pre[suf[x]]=pre[x];<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">reduce</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;X,vector&lt;<span class="hljs-type">int</span>&gt;Y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;Y.<span class="hljs-built_in">size</span>();i++) pre[i]=i<span class="hljs-number">-1</span>,suf[i]=i+<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,y=<span class="hljs-number">0</span>;<br>    P=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> nmsl=Y.<span class="hljs-built_in">size</span>()-X.<span class="hljs-built_in">size</span>();nmsl&gt;<span class="hljs-number">0</span>;nmsl--)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>(X[x],Y[y])&lt;<span class="hljs-built_in">get</span>(X[x],Y[suf[y]]))<br>        &#123;<br>            y=suf[y];<br>            <span class="hljs-built_in">del</span>(pre[y]);<br>            <span class="hljs-keyword">if</span> (x) y=pre[y],x--;<br>        &#125; <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (x==X.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>) <span class="hljs-built_in">del</span>(suf[y]);<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                y=suf[y];<br>                x++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt;ret;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=P;i!=Y.<span class="hljs-built_in">size</span>();i=suf[i])  ret.<span class="hljs-built_in">push_back</span>(Y[i]);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solve</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;X,vector&lt;<span class="hljs-type">int</span>&gt;Y)</span></span><br><span class="hljs-function"></span>&#123;<br>    Y=<span class="hljs-built_in">reduce</span>(X,Y);<br>    <span class="hljs-keyword">if</span> (X.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)<br>    &#123;<br>        M[X[<span class="hljs-number">0</span>]]=Y[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt;Z;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;X.<span class="hljs-built_in">size</span>();i++)<br>        <span class="hljs-keyword">if</span> (!(i%<span class="hljs-number">2</span>)) Z.<span class="hljs-built_in">push_back</span>(X[i]);<br>    <span class="hljs-built_in">Solve</span>(Z,Y);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;X.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!(i%<span class="hljs-number">2</span>)) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> l=<span class="hljs-built_in">lower_bound</span>(Y.<span class="hljs-built_in">begin</span>(),Y.<span class="hljs-built_in">end</span>(),M[X[i<span class="hljs-number">-1</span>]])-Y.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-type">int</span> r=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i==X.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>) r=Y.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            r=<span class="hljs-built_in">lower_bound</span>(Y.<span class="hljs-built_in">begin</span>(),Y.<span class="hljs-built_in">end</span>(),M[X[i+<span class="hljs-number">1</span>]])-Y.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>        M[X[i]]=Y[l];<br>        <span class="hljs-keyword">while</span> (l&lt;r)<br>        &#123;<br>            l++;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>(X[i],Y[l])&gt;<span class="hljs-built_in">get</span>(X[i],M[X[i]])) M[X[i]]=Y[l];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br>H.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++) L.<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-built_in">Solve</span>(H,L);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="wqs二分">WQS二分+</h4><p>可以与其它方法结合在一起，达到一个非常优秀的时间复杂度</p><p>关于WQS二分本身的内容这里就不多赘述了，可以去看其它文章理解一下，这里主要讲一下如何将其应用在决策单调性中</p><p>考虑一类问题：将一个序列强制分为k段，每一段<spanclass="math inline">\([l,r]\)</span>有一个价值<spanclass="math inline">\(w(l,r)\)</span>,问总价值最小的分段</p><p>假设将序列分为k段的最优价值为<spanclass="math inline">\(f_k\)</span>，<strong>如果</strong>所有的<spanclass="math inline">\((k,f_k)\)</span>组成一个凸函数，那么我们就可以使用WQS二分了。外层枚举斜率，内层就去掉了分段的限制，就可以使用二分队列/斜率优化/分治等措施了。</p><p>现在问题还是很多的，比如凸性的证明，WQS二分的边界问题，内部求最优值时更新的取等问题等。一个一个来</p><h5 id="wqs多解情况">WQS多解情况</h5><p>多解情况是指答案K与多个点在一条线段上，此时我们无法直接通过枚举斜率来做到只切到点K，所以我们需要在枚举的同时让得到的方案具有完全的偏序，来保证我们枚举斜率的时候，知道当前斜率对应的答案是哪一点的答案，是线段左端点的，还是右端点的，从而保证后面二分调整mid的时候不会弄混淆。很重要的一点是，我们需要的只是正确的斜率，不需要保证当前斜率做出来的最优点一定是K,因为<spanclass="math inline">\(f_k=mid*k+b\)</span>,其中斜率<spanclass="math inline">\(mid\)</span>和截距<spanclass="math inline">\(b\)</span>都是二分之后确定的值，在同一线段上的点做出的<spanclass="math inline">\(mid,b\)</span>都是一样的。</p><p>那么为了做到严格偏序，我们需要对每一个属性都定义大小</p><p><ahref="https://blog.csdn.net/Emm_Titan/article/details/124035796?spm=1001.2014.3001.5502">这篇博客</a>讲的很清晰，我可能讲的有点抽象，可以去再看看</p><p><img src="https://s2.loli.net/2023/12/19/3lAUxiLe4rvwNRa.png" alt="image-20230916171500911" style="zoom:100%;" /></p><h5id="满足四边形不等式的序列划分问题的答案凸性以及wqs二分的方案构造">满足四边形不等式的序列划分问题的答案凸性以及WQS二分的方案构造</h5><p>这里我们尝试证明满足四边形不等式的序列划分问题都具有凸性</p><blockquote><p>不妨先来看另一个问题：给定一张n个点的DAG，点<spanclass="math inline">\(i\)</span>与点<spanclass="math inline">\(j\)</span>当<spanclass="math inline">\(i&lt;j\)</span>时有权值<spanclass="math inline">\(w(i,j)\)</span>,问从1走到n的经过k条边的最短路</p></blockquote><p>简单转化一下，这个问题的dp方程就是我们熟悉的:<spanclass="math inline">\(dp_{i,j}=min\{dp_{k,j-1}+w(k,i)\}\)</span>,<spanclass="math inline">\(dp_{i,j}\)</span>表示走到i，经过j条边的最短路</p><p>设<span class="math inline">\(f_k\)</span>表示经过k条边的最短路</p><p>下面我们尝试证明：当权值矩阵w满足四边形不等式的时候，<spanclass="math inline">\(f_k\)</span>是一个下凸函数。换句话说，<spanclass="math inline">\(\forall k\in[2,n-2]\)</span>，<spanclass="math inline">\(f_{k+1}-f_k&gt;f_k-f_{k-1}\)</span></p><blockquote><p>引理：<em>∀</em>1 <em>≤</em> <em>s</em> <em>&lt;</em> <em>r</em><em>&lt;</em> <em>t</em> <em>≤</em> <em>n</em> <em>−</em> 1<em>,</em><em>f</em>(<em>s</em>) + <em>f</em>(<em>t</em>) <em>≥</em><em>f</em>(<em>r</em>) + <em>f</em>(<em>s</em> + <em>t</em> <em>−</em><em>r</em>)</p></blockquote><p>如果我们能够证明该引理的话，带入<spanclass="math inline">\(s=k-1,r=k,t=k+1\)</span>,则命题得证</p><p>下面尝试证明引理：</p><hr /><p>不妨记<span class="math inline">\(f_s\)</span>对应的最优方案是<spanclass="math inline">\(p_1,p_2...p_{s+1}\)</span>,<spanclass="math inline">\(f_t\)</span>对应的最优方案是<spanclass="math inline">\(q_1,q_2,..q_{t+1}\)</span></p><p>记<spanclass="math inline">\(v=r-s&gt;0\)</span>,如果我们能够找到<spanclass="math inline">\(i \in [1,s]\)</span>,满足<spanclass="math inline">\(p_i\leq q_{i+v}&lt;q_{i+v+1}\leq p_{i+1}(i+v+1\leqs+v+1\leq t)\)</span>,就能够构造路径<spanclass="math inline">\(R_1:\)</span><spanclass="math inline">\(p_1,...p_i,q_{i+v+1},q_{i+v+2},..q_{t+1}\)</span>,以及路径<spanclass="math inline">\(R_2:\)</span><spanclass="math inline">\(q_1,...q_{i+v},p_{i+1},p_{i+2},...p_{s+1}\)</span>(也就是把两段路径的后半段交换了一下，并且保证一定交换了一部分)</p><p>两段路径的<strong>长度</strong>分别是<spanclass="math inline">\(i-1+(t+1-i-v-1)+1=t-v=t-r+s\)</span>,以及<spanclass="math inline">\(i-1+v+(s+1-i-1)+1=s+v=r\)</span>,</p><p>那么由f的定义,<spanclass="math inline">\(R_1\)</span>的<strong>路径长度</strong><spanclass="math inline">\(len（R_1) \geq f_{t-r+s}\)</span>,<spanclass="math inline">\(R_2\)</span>的<strong>路径长度</strong><spanclass="math inline">\(len(R_2)\geq f_{r}\)</span>,</p><p>由四边形不等式<spanclass="math inline">\(w(p_i,q_{i+v+1})+w(q_{i+v},p_{i+1})\leqw(q_{i+v}+q_{i+v+1})+w(p_i,p_{i+1})\)</span></p><p>故<span class="math inline">\(f_s+f_t\geq len(R_1)+len(R_2)\geqf_{t-r+s}+f_r\)</span></p><p>第一个不等式是因为<spanclass="math inline">\(R_1,R_2\)</span>与原本路径的区别只有中间衔接的一段</p><p>由上，我们只要证明存在这样的一个<spanclass="math inline">\(i\)</span>即可。</p><figure><img src="https://s2.loli.net/2023/12/19/r69QhC8pR2SqgJM.png"alt="image-20230916142205317" /><figcaption aria-hidden="true">image-20230916142205317</figcaption></figure><p>不妨记路径P将<spanclass="math inline">\((1,n]\)</span>分成了s个部分，其中第i个部分是<spanclass="math inline">\((p_i,p_{i+1}]\)</span></p><p>我们记<span class="math inline">\(a_i\)</span>表示<spanclass="math inline">\(q_{i+v}\)</span>在哪一段，那么如果存在<spanclass="math inline">\(i\)</span>,<spanclass="math inline">\(a_i=a_i+1=k\)</span>,我们就找到答案为k了。</p><p>记<span class="math inline">\(b_i=a_i-i\)</span>,显然<spanclass="math inline">\(b_1\geq 0,b_{s+1}\leq -1\)</span>，后者是因为<spanclass="math inline">\(a_{s+1}-(s+1)\leqs-(s+1)=-1\)</span>,此外显然<spanclass="math inline">\(b_i-b_{i-1}=0\)</span>或<spanclass="math inline">\(-1\)</span>,故<spanclass="math inline">\(b_i-b_{i-1}\geq -1\)</span></p><p>由此序列b中一定存在一个-1,取最靠前的-1，记为<spanclass="math inline">\(b_{i+1}\)</span>.它前面一定是<spanclass="math inline">\(b_i=0\)</span>,故<spanclass="math inline">\(a_i=a_{i+1}\)</span></p><p>这样我们就找到了一个合法的<spanclass="math inline">\(i\)</span>,引理得证，故命题得证 Q.E.D</p><hr /><p>这段证明还是非常玄妙(玄幻)的。当然它对于我们的方案构造也有帮助</p><p>WQS二分中有时候会存在要求为k，但是<spanclass="math inline">\(k&gt;l,k&lt;r\)</span>且<spanclass="math inline">\(l,r,k\)</span>在一条线段上的情况，这时候我们一般通过限定边数尽可能多/少来保证取到线段的端点。但是想要构造方案的话就会不知所措了</p><p>我们记答案斜率为mid,这条包含答案k的线段的端点为<spanclass="math inline">\((l,f_l),(r,f_r)\)</span>,则<spanclass="math inline">\(\forall i\in[l,r],f_i=f_l+mid*(i-l)\)</span></p><p>我们可以先把<spanclass="math inline">\(l,r\)</span>对应的最优方案找出来，长度分别为<spanclass="math inline">\(l,r\)</span>,那么按照上述证明中的构造方式我们得到长度为<spanclass="math inline">\(k,l+r-k\)</span>的路径<spanclass="math inline">\(R_1,R_2\)</span>,记其<strong>路径长度</strong>分别为<spanclass="math inline">\(len(R_1)=a,len(R_2)=b\)</span>,有<spanclass="math inline">\(a\geq f_l+mid*(k-l),b\geqf_l+mid*(l+r-k-l)\)</span></p><p>且有<spanclass="math inline">\(2f_l+mid*(k-l)+mid*(l+r-k-l)=2f_l+mid*(r-l)\leqa+b\leq f_l+f_r=2f_l+mid*(r-l)\)</span></p><p>第二个不等号的原因见证明片段</p><p>发现<span class="math inline">\(a+b\)</span>被边界夹住了，故<spanclass="math inline">\(a= f_l+mid*(k-l)\)</span>,由此a就是<spanclass="math inline">\(f_{k}\)</span>,我们就得到了长度为k的构造方案</p><p>以上内容参考 <a href="https://www.osti.gov/biblio/10146169">论文</a>《The <em>d</em>-Edge Shortest-Path Problem for a MongeGrapll》，以及APIO2021《决策单调性与四边形不等式》</p><hr /><h5 id="wqs外层二分时的边界">WQS外层二分时的边界</h5><p>一般来说直接取<spanclass="math inline">\([-inf,inf]\)</span>即可，或者稍微算一下卡住边界</p><p>不管是这样的</p><p><img src="https://s2.loli.net/2023/12/19/knMY3pRujfh4ZiU.png" alt="image-20230916170032830" style="zoom:60%;" /></p><p>还是这样的</p><p><img src="https://s2.loli.net/2023/12/19/irx2etJHF1LEcWR.png" alt="image-20230916170003304" style="zoom:60%;" /></p><p>只要边界范围足够就不会有问题。但是有一类分段问题，图像长这样</p><p><img src="https://s2.loli.net/2023/12/19/QXIrSU7uc1BfaWv.png" alt="image-20230916170405876" style="zoom:70%;" /></p><p>分段为0的时候，总价值为0，然后开始分段之后价值随分段减少。不考虑0的话，后面的一段也是满足凸函数的，那么这个对我们的边界会有影响吗？个人感觉没有，因为我们只要保证wqs二分之后在做最优决策的时候保证不让段数为0即可</p><p>比如这题就是这个情况<ahref="https://www.luogu.com.cn/problem/CF321E">CF321 E</a>(在分治部分此题作为练习出现，当然它也可以WQS二分，毕竟它满足四边形不等式，而我们已经证明了该类问题的凸性)</p><p>那么到这里，理论部分就差不多完善了，我们就可以看看应用了</p><p>不妨就看看这题<a href="https://www.luogu.com.cn/problem/CF321E">CF321E</a></p><p>按照套路，我们外层枚举斜率，内层就是每一段的贡献要减去一个<spanclass="math inline">\(mid\)</span>,问最优分段数及其对应的总贡献。dp式满足决策单调性，可以直接上单调队列，复杂度是<spanclass="math inline">\(O(nlogn^2)\)</span>,外层<spanclass="math inline">\(O(log)\)</span>,内层<spanclass="math inline">\(O(nlog)\)</span>，可以看到比普通的<spanclass="math inline">\(O(n^2log)\)</span>分治要优化了不少</p><p>code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> il inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">4010</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br>ll n,m;<br>ll mp[N][N];<br>ll cnt[N];<br>ll sum[N][N];<br>ll dp[N];<br>ll que[N];<br>ll ls[N],rs[N];<br>ll ANS;<br><span class="hljs-function">ll <span class="hljs-title">cal</span><span class="hljs-params">(ll l,ll r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//l+1-&gt;r</span><br>    <span class="hljs-keyword">return</span> sum[r][r]-sum[l][r]-sum[r][l]+sum[l][l];<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll k,ll x,ll val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> dp[k]+<span class="hljs-built_in">cal</span>(k,x)-val;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>    que[++tl]=<span class="hljs-number">0</span>;ls[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>,rs[<span class="hljs-number">0</span>]=n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cnt[i]=<span class="hljs-number">0</span>,ls[i]=rs[i]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;rs[que[hd]]&lt;i) hd++;<br>        dp[i]=<span class="hljs-built_in">gt</span>(que[hd],i,x);<br>        cnt[i]=cnt[que[hd]]+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">gt</span>(i,ls[que[tl]],x)&lt;<span class="hljs-built_in">gt</span>(que[tl],ls[que[tl]],x)) tl--;<br>        ll L=ls[que[tl]],R=n+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(L&lt;=R)<br>        &#123;<br>            ll mid=(L+R)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(i,mid,x)&lt;=<span class="hljs-built_in">gt</span>(que[tl],mid,x)) R=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> L=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;que[tl]&lt;&lt;&#x27; &#x27;&lt;&lt;R+1&lt;&lt;&quot; &quot;&lt;&lt;gt(i,R+1,x)&lt;&lt;&quot; &quot;&lt;&lt;gt()</span><br>        ll p_ans=R+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(p_ans&gt;n) <span class="hljs-keyword">continue</span>;<br>        rs[que[tl]]=p_ans<span class="hljs-number">-1</span>;<br>        que[++tl]=i;<br>        ls[i]=p_ans,rs[i]=n;<br>    &#125;<br>    ANS=dp[n];<br><span class="hljs-comment">//     cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;cnt[n]&lt;&lt;&quot; &quot;&lt;&lt;ANS&lt;&lt;&quot; &quot;&lt;&lt;ANS+m*x&lt;&lt;endl;</span><br>    <span class="hljs-keyword">return</span> cnt[n]&gt;=m;<br>    <span class="hljs-comment">//尽可能分多段，尽可能选靠后的点转移</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)<br>        &#123;<br>            cin&gt;&gt;mp[i][j];<br>            <span class="hljs-keyword">if</span>(i&gt;j) mp[i][j]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)<br>        &#123;<br>            sum[i][j]=sum[i][j<span class="hljs-number">-1</span>]+sum[i<span class="hljs-number">-1</span>][j]+mp[i][j]-sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>        &#125;<br>    &#125;<br>    ll l=<span class="hljs-number">-1e18</span>,r=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;=r)<br>    &#123;<br>        ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(mid)) r=mid<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">judge</span>(r+<span class="hljs-number">1</span>);<br>    cout&lt;&lt;ANS+m*(r+<span class="hljs-number">1</span>)&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P6246">IOI2000 邮局加强版</a></p><p><a href="https://www.luogu.com.cn/problem/P4072">SDOI2016征途</a></p><p>套路都差不多，套一个WQS的事，内层看情况用不同的优化手段</p><p><a href="https://www.luogu.com.cn/problem/P5308">Akvizna</a></p><p>你面临 <em>n</em> 名参赛者的挑战，最终要将他们全部战胜。每一轮中，都会淘汰一些选手；你会得到这一轮奖金池中 被淘汰者 除以这一轮对手总数 比例的奖金。</p><p>例如某一轮有 10 个对手，淘汰了 3 个，那么你将获得奖金池中 3/10的奖金。</p><p>假设每一轮的奖金池均为一元，<code>Mirko</code> 希望通过恰好<em>k</em> 轮赢得比赛，那么他最多可能获得多少奖金呢？</p><p>你只需要输出答案保留 9 位小数即可。</p><p>这题略阴间，二分的时候不枚举小数的话过不了，肥肠卡精度，不过思维难度一般</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-12</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-type">const</span> ll N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">double</span> dp[N];<br><span class="hljs-type">double</span> ANS;<br><span class="hljs-type">double</span> inv[N];<br>ll cnt[N];<span class="hljs-comment">//分的段数</span><br>ll que[N];<br>ll ls[N],rs[N];<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">gt</span><span class="hljs-params">(ll k,ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> dp[k]+(<span class="hljs-type">double</span>)((x-k)*<span class="hljs-number">1.0</span>*inv[n-k]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>    que[++tl]=<span class="hljs-number">0</span>;ls[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>,rs[<span class="hljs-number">0</span>]=n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cnt[i]=<span class="hljs-number">0</span>,ls[i]=rs[i]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;rs[que[hd]]&lt;i) hd++;<br>        cnt[i]=cnt[que[hd]]+<span class="hljs-number">1</span>;<br>        dp[i]=<span class="hljs-built_in">gt</span>(que[hd],i)-x;<br>        <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;que[hd]&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i]&lt;&lt;endl;</span><br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">gt</span>(i,ls[que[tl]])&gt;=<span class="hljs-built_in">gt</span>(que[tl],ls[que[tl]])) tl--;<br>        ll L=ls[que[tl]],R=n+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(L&lt;=R)<br>        &#123;<br>            ll mid=(L+R)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(i,mid)&gt;=<span class="hljs-built_in">gt</span>(que[tl],mid)) R=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> L=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        ll p_ans=R+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(p_ans&gt;n) <span class="hljs-keyword">continue</span>;<br>        rs[que[tl]]=p_ans<span class="hljs-number">-1</span>;<br>        que[++tl]=i;<br>        ls[i]=p_ans,rs[i]=n;<br>    &#125;<br>    ANS=dp[n];<br>    <span class="hljs-comment">// cout&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;cnt[n]&lt;&lt;&#x27; &#x27;&lt;&lt;ANS&lt;&lt;&#x27; &#x27;&lt;&lt;ANS+m*x&lt;&lt;endl;</span><br>    <span class="hljs-keyword">return</span> cnt[n]&lt;=m;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) inv[i]=<span class="hljs-number">1.0</span>/(i*<span class="hljs-number">1.0</span>);<br>    <span class="hljs-comment">// for(int i=1;i&lt;=n;++i)</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     for(int j=1;j&lt;=min(i,m);++j)</span><br>    <span class="hljs-comment">//     &#123;</span><br>    <span class="hljs-comment">//         for(int k=j-1;k&lt;i;++k)</span><br>    <span class="hljs-comment">//         &#123;</span><br>    <span class="hljs-comment">//             dp[i][j]=max(dp[i][j],dp[k][j-1]+(double)((i-k)*1.0/(n-k)));</span><br>    <span class="hljs-comment">//         &#125;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// judge(0);</span><br>    <span class="hljs-comment">// for(double i=-2;i&lt;=2;i+=0.1) judge(i);</span><br>    <span class="hljs-type">double</span> l=<span class="hljs-number">-100</span>,r=<span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">while</span>(l+eps&lt;=r)<br>    &#123;<br>        <span class="hljs-type">double</span> mid=(l+r)/<span class="hljs-number">2.0</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(mid)) r=mid;<br>        <span class="hljs-keyword">else</span> l=mid;<br>    &#125;<br>    <span class="hljs-built_in">judge</span>(r);<br>    <span class="hljs-comment">// cout&lt;&lt;r+1&lt;&lt;endl;</span><br>    cout&lt;&lt;fixed&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">9</span>)&lt;&lt;ANS+m*<span class="hljs-number">1.0</span>*(r)&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="tips">Tips：</h5><p>做WQS二分一定要注意问题函数是一个上凸包还是下凸包</p><p>注意左右边界</p><p>有时候也是也是要二分小数的！</p><h4 id="斜率优化">斜率优化</h4><p>基本的斜率优化本人已经在<ahref="https://blog.csdn.net/sophilex/article/details/132634582?spm=1001.2014.3001.5502">另一篇博客</a>中讲的很详细了，从入门到精通应该都有了。</p><p>然后更多的应用大概就是与WQS二分结合了吧</p><p>注意点好像也没啥，毕竟WQS二分之后内部就是一个纯纯的一维dp</p><p><a href="https://www.luogu.com.cn/problem/P4072">SDOI2016征途</a></p><p><a href="https://www.luogu.com.cn/problem/P5308">Akvizna</a></p><p>值得一提的还有这道题<ahref="https://www.luogu.com.cn/problem/P5504">JSOI2001 柠檬</a></p><p>之前在二分栈里提过它，但其实它也可以用斜率优化做，但是因为斜率实际上是递减的，所以内部维护凸包的时候是用一个栈（因为最优点在最后了，放入点也是在最后），这个还是比较少见的</p><p>code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ld long double</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IL inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">100010</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">998244353</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> X=<span class="hljs-number">0</span>; <span class="hljs-type">bool</span> flag=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">0</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="hljs-number">1</span>)+(X&lt;&lt;<span class="hljs-number">3</span>)+ch-<span class="hljs-string">&#x27;0&#x27;</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> X;<br>    <span class="hljs-keyword">return</span> ~(X<span class="hljs-number">-1</span>);<br>&#125;<br>ll n,a;<br>ll dp[N];<br>vector&lt;ll&gt; col[N],st[N];<span class="hljs-comment">//栈</span><br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll x,ll c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> dp[col[c][x]<span class="hljs-number">-1</span>]+c*x*x<span class="hljs-number">-2</span>*x*c;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Slope</span><span class="hljs-params">(ll a,ll b,ll col)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a==b) <span class="hljs-keyword">return</span> inf;<br>    <span class="hljs-type">double</span> x=<span class="hljs-built_in">gt</span>(a,col)-<span class="hljs-built_in">gt</span>(b,col);x=x*<span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">double</span> y=a-b;y*=<span class="hljs-number">1.0</span>;<br>    <span class="hljs-keyword">return</span> x/y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10000</span>;++i) col[i].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;a;<br>        ll len=col[a].<span class="hljs-built_in">size</span>();<br>        col[a].<span class="hljs-built_in">push_back</span>(i);<span class="hljs-comment">//放入id</span><br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">1</span>) st[a].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//st存的是横坐标（颜色前缀和）</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//维护上凸包</span><br>            <span class="hljs-keyword">while</span>(st[a].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;<span class="hljs-built_in">Slope</span>(st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>],st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>],a)&lt;=<span class="hljs-number">2</span>*a*len) st[a].<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//sum_i=len</span><br>            ll id=st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>            dp[i]=dp[col[a][id]<span class="hljs-number">-1</span>]+a*(<span class="hljs-number">1</span>+len-id)*(<span class="hljs-number">1</span>+len-id);<br>            <span class="hljs-keyword">while</span>(st[a].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;<span class="hljs-built_in">Slope</span>(st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>],st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>],a)&lt;=<span class="hljs-built_in">Slope</span>(st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>],len,a)) st[a].<span class="hljs-built_in">pop_back</span>();<br>            st[a].<span class="hljs-built_in">push_back</span>(len);<br>        &#125;<br>        dp[i]=<span class="hljs-built_in">max</span>(dp[i],dp[i<span class="hljs-number">-1</span>]+a);<br>    &#125;<br>    cout&lt;&lt;dp[n]&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// ll t;t=read();while(t--)</span><br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一些特殊情况">一些特殊情况</h4><p>可以看到，如果题目已经有了决策单调性，大部分情况下还是比较套路的，但是有些时候问题在全局上不满足决策单调性并不意味着局部也没有。</p><p>还是<a href="https://www.luogu.com.cn/problem/P5504">JSOI2001柠檬</a>这道题，它就是在同种颜色内部满足决策单调性（这么一看这真是道好题啊，哪哪都这么与众不同）</p><p>以及<a href="https://codeforces.com/gym/101002/attachments">2016NAIPH</a></p><p>大意：</p><p>有n个物品，每个物品有一个体积<spanclass="math inline">\(w_i\)</span>和价值<spanclass="math inline">\(v_i\)</span>，现在要求对<spanclass="math inline">\(V∈[1,m]\)</span>，求出体积为<spanclass="math inline">\(V\)</span>的 背包能够装下的最大价值</p><p><spanclass="math inline">\(1≤n≤1000000;1≤m≤100000;1≤w_i≤300;1≤v_i≤10^9\)</span></p><p>其实就是对每一个<spanclass="math inline">\(V\)</span>，做一个多重背包</p><p>思路：</p><p>发现每一个物品的体积都比较小，所以可以按照体积分类。那么对于同一种体积的物品，我们肯定贪心选择价值最大的，所以可以排个序</p><p>考虑<span class="math inline">\(dp_{i,j}\)</span>表示使用体积<spanclass="math inline">\(\leqi\)</span>的物品，总体积为j的最大价值。我们可以将所有需要更新的体积按照%i来重新编号。比如当前i是2，m是9，我们就可以将<spanclass="math inline">\(0,2,4,6,8\)</span>化为一类各自重新编号为<spanclass="math inline">\(0,1,2,3,4\)</span>，<spanclass="math inline">\(1,3,5,7,9\)</span>划为一类，编号同理</p><p>这样的好处就是我们对于每一个i，j的范围也只有<spanclass="math inline">\([0,i]\)</span>这么大了，以及同一组体积内部的差恰好为i，那么物品就可以直接按照价值大小贪心塞了。</p><p>那么此时dp的意义就变了。如果当前是在更新%i=a的体积，则<spanclass="math inline">\(dp_{i,j}\)</span>表示使用体积<spanclass="math inline">\(\leq i\)</span>的物品，总体积为<spanclass="math inline">\(j*i+a\)</span>的最大值</p><p>%i=a时，<span class="math inline">\(dp_{i,j}=max_{k\leqj}\{dp_{i-1,k}+w(k,j)\}\)</span>,其中<spanclass="math inline">\(w(k,j)\)</span>表示体积=i的物品中最大的<spanclass="math inline">\(j-k\)</span>个物品的价值和，记为前缀和<spanclass="math inline">\(vt_{i,j-k}\)</span></p><p>简单证一下四边形不等式:</p><p>考虑<span class="math inline">\(i,i+1,j,j+1,i+1&lt;j\)</span></p><p><span class="math inline">\(w(i,j)+w(i+1,j+1)=2vt_{j-i}\)</span></p><p><spanclass="math inline">\(w(i+1,j)+w(i,j+1)=vt_{j-i-1}+vt_{j-i+1}=2vt_{j-i}+a_{j-i+1}-a_{j-i-1}\leqw(i,j)+w(i+1,j+1)\)</span></p><p>得证</p><p>那么直接分治即可</p><p>code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-11</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-type">const</span> ll N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br>ll n,m;<br>vector&lt;ll&gt; vt[<span class="hljs-number">310</span>];<br>ll dp[N],pp[N];<br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll id,ll x,ll mod,ll res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> pp[id*mod+res]+vt[mod][x-id<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(ll a,ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a&gt;b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solve</span><span class="hljs-params">(ll l,ll r,ll pl,ll pr,ll mod,ll res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span>;<br>    ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    ll pos=mid;<br>    dp[mid*mod+res]=pp[mid*mod+res];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">min</span>(mid<span class="hljs-number">-1</span>,pr);i&gt;=pl;--i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(mid-i&gt;(<span class="hljs-type">int</span>)vt[mod].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(i,mid,mod,res)&gt;dp[mid*mod+res]) dp[mid*mod+res]=<span class="hljs-built_in">gt</span>(pos=i,mid,mod,res);<br>    &#125;<br>    <span class="hljs-built_in">Solve</span>(l,mid<span class="hljs-number">-1</span>,pl,pos,mod,res);<br>    <span class="hljs-built_in">Solve</span>(mid+<span class="hljs-number">1</span>,r,pos,pr,mod,res);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        ll a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        vt[a].<span class="hljs-built_in">push_back</span>(b);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">300</span>;++i)<br>    &#123;<br>        <span class="hljs-built_in">sort</span>(vt[i].<span class="hljs-built_in">begin</span>(),vt[i].<span class="hljs-built_in">end</span>(),cmp);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;(<span class="hljs-type">int</span>)vt[i].<span class="hljs-built_in">size</span>();++j) vt[i][j]+=vt[i][j<span class="hljs-number">-1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">300</span>;++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!vt[i].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//枚举物品体积的类别</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;++j)<br>        &#123;<br>            <span class="hljs-comment">//枚举%i=j的体积</span><br>            <span class="hljs-built_in">Solve</span>(<span class="hljs-number">0</span>,(m-j)/i,<span class="hljs-number">0</span>,(m-j)/i,i,j);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j<span class="hljs-number">-1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) pp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) cout&lt;&lt;pp[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>本来想用SMAWK写的，但是一直MLE，不懂，求懂的佬教教</p><p>当然这题的决策单调性也是分组才有的，很抽象，感觉本人是不可能看出来的（哭</p><p>总结：</p><p>大工程，希望对自己&amp;大家有用:heartpulse:</p><p>参考文章</p><p><a href="https://oi-wiki.org/">OIWIKI</a></p><p><a href="https://www.osti.gov/biblio/10146169">Bein, W W, Larmore, LL, and Park, J K. <em>The d-edge shortest-path problem for a Mongegraph</em>. United States: N. p., 1992. Web.</a></p><p><a href="https://www.osti.gov/biblio/10175042">Bein, W W, Brucker, P,and Park, J K. <em>Applications of an algebraic Monge property</em>.United States: N. p., 1993. Web.</a></p><p><ahref="https://cp-algorithms.com/dynamic_programming/divide-and-conquer-dp.html">Divideand Conquer DP</a></p><p><ahref="https://www.luogu.com.cn/blog/MCAdam/jue-ce-dan-diao-xing">决策单调性- MCAdam</a></p><p><ahref="https://www.luogu.com.cn/blog/flashblog/solution-p1912">关于决策单调性与图像的结合</a></p><p>彭思进 《决策单调性与四边形不等式》</p>]]></content>
    
    
    <categories>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>动态规划</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斜率优化dp总结</title>
    <link href="/2023/12/19/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp%E6%80%BB%E7%BB%93/"/>
    <url>/2023/12/19/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="斜率优化dp">斜率优化dp</h2><h3 id="前言">前言：</h3><p>我们学过不少优化类的算法了，大部分都是基于凸函数的性质给出的优化，比如SlopeTrick，Wqs二分，又比如今天的斜率优化（不知道什么时候会有空把SlopeTrick写掉）</p><h3 id="正文">正文：</h3><p>我们考虑一类比较常见的dp方程：<spanclass="math inline">\(dp_i=min/max_{j}(a_i*b_j+c_j+d_i)\)</span>,其中<strong><spanclass="math inline">\(b_j是单调增的\)</span></strong><spanclass="math inline">\(（事实上b_j\)</span>不单调增也可以用斜率优化处理，但是这里我们为了简化先考虑这样一种特殊情况）。同时，为了方便，接下来我们先以min为讨论对象，实际上max是同理的，读者可以自己对应手推一遍</p><p>一般的暴力递推，复杂度是<spanclass="math inline">\(O(N^2)\)</span>的。</p><p>我们考虑改变一下式子的形式：<spanclass="math inline">\(dp_i=min_{j}\{a_i*b_j+c_j\}+d_i\)</span>,此时对于固定的<spanclass="math inline">\(i\)</span>,外面的<spanclass="math inline">\(d_i\)</span>是固定的，所以我们真正要考虑的其实是<spanclass="math inline">\(a_i*b_j+c_j\)</span>这样一个式子的最小值，它其实就是一个一次函数<spanclass="math inline">\(kx+b\)</span>的形式，其中<spanclass="math inline">\(k=b_j,b=c_j\)</span>。我们不妨记<spanclass="math inline">\(f_{i,j}=a_i*b_j+c_j\)</span></p><h4 id="凸包">凸包</h4><p>我们不妨来看一下，如果两个点<spanclass="math inline">\(x&lt;y\)</span>，对于某一个i满足<spanclass="math inline">\(f(i,y)\leq f(i,x)\)</span>,也就是说<spanclass="math inline">\(y\)</span>是比<spanclass="math inline">\(x\)</span>更加优的一个决策点，它们之间会有什么关系</p><p><span class="math inline">\(f(i,y)=a_i*b_y+c_y\leqf(i,x)=a_i*b_x+c_x\)</span></p><p>即：<span class="math inline">\(\large \frac{c_y-c_x}{b_y-b_x}\leq-a_i\)</span>(注意之前我们假定<spanclass="math inline">\(b_i\)</span>是单增的)</p><blockquote><p>这里是在做一个参变分离，注意这里我们其实是将x,y的信息视为已知量，而将i作为变量</p></blockquote><p>放到二维坐标系下考虑，就是<spanclass="math inline">\((b_x,c_x),(b_y,c_y)\)</span>两个点的连线的斜率<spanclass="math inline">\(\leq -a_i\)</span></p><p><img src="https://s2.loli.net/2023/12/19/Y2egrsEdxcBw9U8.png" alt="image-20230901175709520" style="zoom:100%;" /></p><p>换句话说，这里如果x是y之前的比较优的一个点，在y出现之后它就被淘汰了，判断的条件我们记为<spanclass="math inline">\(k_{xy}&lt;=K(X)\)</span>,其中<spanclass="math inline">\(K(X)=-a_i\)</span>。</p><p>接着我们将考虑的点数扩大到三个点<span class="math inline">\(x\leq y\leq z\)</span>,这里我们不妨先限定<span class="math inline">\(K_{yz}\leqK_{xy}\)</span></p><p><img src="https://s2.loli.net/2023/12/19/KeSIpcrOGB5f2hJ.png" alt="image-20230901175709520" style="zoom:100%;" /></p><p>边界条件还是<span class="math inline">\(K(X)=-a_i\)</span></p><blockquote><p>按照之前的讨论，对于两个点<spanclass="math inline">\(x,y\)</span>,若<spanclass="math inline">\(k_{x,y}\leq K(x)\)</span>,则点<spanclass="math inline">\(y优于x\)</span>,否则<spanclass="math inline">\(点x优于y\)</span></p></blockquote><p>那么我们有如下几种情况：</p><ul><li>$K_{yz}&lt;K_{xy} K(X) <spanclass="math inline">\(,则\)</span>点z优于点x,y$</li><li><span class="math inline">\(K_{yz}\leqK(X)&lt;K_{xy}\)</span>,则点<spanclass="math inline">\(x,z\)</span>优于<spanclass="math inline">\(点y\)</span></li><li><span class="math inline">\(K(X)\leqK_{yz}&lt;K_{zy}\)</span>,则点x优于点<spanclass="math inline">\(y,z\)</span></li></ul><p>此时我们惊奇地发现，不管是哪一种情况，点<spanclass="math inline">\(y\)</span>都不可能作为最优解。按照之前所说，我们其实是对于这样一系列固定的点，对于不同的i，考察最优决策点的变化。也就是说，如果我们提前处理好了这样若干个点，那么我们就已经知道点y永远不会成为最优决策点了（在三个点都能选择的情况下）</p><blockquote><p>讲回我们在这部分讨论前做的假设<span class="math inline">\(K_{yz}\leqK_{x,y}\)</span>,读者可以自行验证，当三点不满足该关系的时候，我们并不能得到类似或者什么更优的结论。</p></blockquote><p>那么我们对于一个固定的点i，将所有能进行决策的点进行这样一个预处理过程的话（大部分情况下对于固定的点i，我们只能够在<spanclass="math inline">\([1,i-1]\)</span>内决策，这里直接取该情况，其它情况其实同理），<spanclass="math inline">\(\forall 1\leq x&lt;y&lt;z&lt; i\)</span>,若<spanclass="math inline">\(K_{yz}\leqK_{x,y}\)</span>,则将点y删除（因为它永远不会成为一个最优）,那么将留下来的点两两按横坐标顺序前后链接，斜率是<strong>单调不降的</strong>，换句话说，留下来的点就形成了一个<strong>下凸包</strong>，如下图所示，其中绿色连接部分就是一个凸包，红色点是在处理过程中被删除的点</p><p><img src="https://s2.loli.net/2023/12/19/1IxmWoDGw9PSRen.png" alt="image-20230901175709520" style="zoom:100%;" /></p><h4 id="最优决策点的快速寻找">最优决策点的快速寻找</h4><p>一旦要维护的东西变成了一个凸包，那么我们的手段就可以很骚了，因为此时它的斜率具有单调性，我们就可以上二分等手段了:)</p><p>对于一个固定的i，我们有<spanclass="math inline">\(K(X)=-a_i\)</span>,由于下凸包的斜率是单增的，所以将斜率从左到右一一写出来的话，我们会得到如下关系</p><p><span class="math inline">\(K_1&lt;K_2&lt;...&lt;K_s\leqK(X)&lt;K_{s+1}...K_{m}\)</span></p><p>那么我们要找的点显然就是s，也就是最后一个与前面的点连线的斜率<spanclass="math inline">\(\leq K(X)\)</span>的点</p><p>那么我们维护好这个凸包之后，直接用二分线段即可，最后一个斜率<spanclass="math inline">\(\leq K(X)\)</span>的线段的右端点就是答案了</p><blockquote><p>考虑凸包的一个特殊情况：多个点处于一条线段上，就如上图的第二条线段，但是该情况对我们的选择并没有影响，因为我们取的是每一个线段的最右端点</p></blockquote><p>这样每次去寻找最优决策点的复杂度是<spanclass="math inline">\(O(log)\)</span>的，再加上维护凸包的复杂度<spanclass="math inline">\(O(N)\)</span>,时间复杂度就是<spanclass="math inline">\(O(NlogN)\)</span>的</p><p>具体流程:</p><ul><li><p>A 在凸包上二分找到最优决策点x</p></li><li><p>B 用x的值更新<span class="math inline">\(dp_i\)</span></p></li><li><p>C在将i加入凸包之前，我们要先将队尾一部分一定没有i优的点踢掉，然后再将i加入凸包</p></li></ul><p>对步骤C的解释：这里将i直接加入凸包的话，有可能我们维护的就不再是一个凸包了，如下图情况</p><p><img src="https://s2.loli.net/2023/12/19/OCarLxQ3tYJR1SE.png" alt="image-20230901175709520" style="zoom:100%;" /></p><p>不难发现，此时<spanclass="math inline">\(x,y,i\)</span>三点形成的就是之前讨论过的三个点的情形，所以y是一定不会成为最优决策点的。同理，踢掉y之后，如果<spanclass="math inline">\(z,x,i\)</span>也是一个情况的话，x也会被踢掉，直到最后不再有这样的点为止</p><h4 id="再优化">再优化</h4><p>注意到上面的复杂度还是有点高，我们考虑dp过程中常见的决策单调性情况</p><p>决策单调性：在dp过程中，设<spanclass="math inline">\(S_i表示dp_i\)</span>的最优决策点，如果<spanclass="math inline">\(\forall i&lt;j,S_i\leqS_j\)</span>则称该dp过程满足决策单调性，也就是说随着dp过程的进行，最优决策点是单调不降的</p><p>关于决策单调性的证明，常见的就是四边形不等式，这里暂且不提，后面有空再说:)</p><p>决策单调性在这里意味着什么？意味着之前已经被淘汰的点是不会再作为最优决策点出现的。所以我们就可以考虑用单调队列来维护。</p><p>具体流程：</p><ul><li>A <strong>将队列首部斜率<span class="math inline">\(\leqK(X)\)</span>的线段的左端点不断踢出，最后剩下的队首元素x就是最优决策点。（正确性显然）</strong></li><li>B 用x的值更新<span class="math inline">\(dp_i\)</span></li><li>C在将i加入凸包之前，我们要先将队尾一部分一定没有i优的点踢掉，然后再将i加入凸包</li></ul><p>与直接二分的区别就在于步骤A</p><blockquote><p>同时我们注意到，如果<spanclass="math inline">\(K(X)\)</span>是单调的，其自然满足决策点的单调性。（在横坐标单调的前提下）</p></blockquote><p><img src="https://s2.loli.net/2023/12/19/lvNPTIB4QUHjGx6.png" alt="image-20230901175709520" style="zoom:100%;" /></p><h4 id="类型总结单调队列维护凸包">类型总结（单调队列维护凸包）</h4><p>当dp式子满足<span class="math inline">\(\large\frac{c_y-c_x}{b_y-b_x}\leq-a_i\)</span>的时候，我们要维护的是一个下凸包</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>que[++tl]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>    <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[hd],que[hd+<span class="hljs-number">1</span>])&lt;=k[x]) hd++;<span class="hljs-comment">//这里k[x]表示K(X)</span><br>    dp[i]=...<span class="hljs-comment">//用que[hd]来更新dp[i]即可</span><br>    <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[tl<span class="hljs-number">-1</span>],que[tl])&gt;=<span class="hljs-built_in">Slope</span>(que[tl],i)) tl--;<br>    que[++tl]=i;<span class="hljs-comment">//插入凸包</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当dp式子满足<span class="math inline">\(\large\frac{c_y-c_x}{b_y-b_x}\geq-a_i\)</span>的时候，同理就是维护一个上凸包</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>que[++tl]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>    <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[hd],que[hd+<span class="hljs-number">1</span>])&gt;=k[x]) hd++;<span class="hljs-comment">//这里k[x]表示K(X)</span><br>    dp[i]=...<span class="hljs-comment">//用que[hd]来更新dp[i]即可</span><br>    <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[tl<span class="hljs-number">-1</span>],que[tl])&lt;=<span class="hljs-built_in">Slope</span>(que[tl],i)) tl--;<br>    que[++tl]=i;<span class="hljs-comment">//插入凸包</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="tip">Tip</h4><ul><li>当两个点的横坐标相等的时候，实际上不存在斜率，这里我们要特判，取为inf</li><li>到底维护的是上凸包还是下凸包不要弄混，仔细推导一遍最好</li><li>一般是直接用double类型来计算斜率并进行比较，但是有时候出题人不讲武德卡精度，那就要转成乘式类型来比较了，这时候要注意一下负号改变方向的情况</li><li>队列一开始要放进去一个0，毕竟也不一定非有上一个转移点</li><li>有时候dp值会需要预处理，要小心</li><li>比较斜率的时候最好使用<spanclass="math inline">\(\leq,\geq\)</span></li></ul><h4 id="一些特殊情况">一些特殊情况</h4><ul><li><spanclass="math inline">\(b_j\)</span>是单调减的：实际与之前的情况同理。在一开始的推导中我们假定<spanclass="math inline">\(x&lt;y\)</span>，本质上就是为了保证<spanclass="math inline">\(b_j\)</span>是单增的，如果此时它是单减的，我们只要在原本的式子中在对应位置取负，再改变前面符号，重新推导即可。此时<spanclass="math inline">\(-b_j\)</span>就是单增的了</li><li><spanclass="math inline">\(b_j\)</span>不具备单调性：此时我们不能直接通过单调队列来维护凸包，因为新加入的点的横坐标并不是单调的，可能会插入在凸包的中间的位置。此时需要采用cdq分治</li><li>不具备决策单调性：那就只能二分了，不能强行弹出点，因为它可能在后面会成为最优决策点</li><li>不具备决策单调性&amp;横坐标不单调：cdq分治 后面会讲</li></ul><h3 id="例子">例子</h3><p><a href="https://www.luogu.com.cn/problem/P2120">仓库建设</a></p><p>大意：</p><p><span class="math inline">\(n\)</span>个工厂，由高到低分布在一座山上，工厂 <spanclass="math inline">\(1\)</span> 在山顶，工厂 <spanclass="math inline">\(n\)</span> 在山脚。第 <spanclass="math inline">\(i\)</span> 个工厂目前已有成品 <spanclass="math inline">\(p_i\)</span> 件，在第 <spanclass="math inline">\(i\)</span> 个工厂位置建立仓库的费用是 <spanclass="math inline">\(c_i\)</span>。对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，产品只能往山下运（即<strong>只能运往编号更大的工厂的仓库</strong>），一件产品运送一个单位距离的费用是<span class="math inline">\(1\)</span>。</p><ul><li>工厂 <span class="math inline">\(i\)</span> 距离工厂 <spanclass="math inline">\(1\)</span> 的距离 <spanclass="math inline">\(x_i\)</span>（其中 <spanclass="math inline">\(x_1=0\)</span>）。</li><li>工厂 <span class="math inline">\(i\)</span> 目前已有成品数量 <spanclass="math inline">\(p_i\)</span>。</li><li>在工厂 <span class="math inline">\(i\)</span> 建立仓库的费用 <spanclass="math inline">\(c_i\)</span>。</li></ul><p>问修建仓库的最小代价</p><p>思路：</p><p>设<spanclass="math inline">\(dp_i\)</span>表示前i个工厂的最小代价，写出dp式子的过程还是比较套路的，</p><p><span class="math inline">\(dp_i=min_{j\leqi}\{dp_j+x_i\sum_{k=j+1}^{i}(p_k)-\sum_{k=j+1}^{i}(x_kp_k)\}+c_i\)</span></p><p>转化得到</p><p><span class="math inline">\(dp_i=min_{j\leqi}\{dp_j+x_i(sum_i-sum_j)-(xsum_i-xsum_j)\}+c_i\)</span></p><p>其中<spanclass="math inline">\(sum_i=\sum_{k=1}^{i}p_k,xsum_i=\sum_{k=1}^{i}p_k*x_k\)</span></p><p>所以<span class="math inline">\(dp_i=min_{j\leqi}\{-sum_jx_i+(dp_j+xsum_j)\}+x_isum_i-xsum_i+c_i\)</span></p><p>这里<span class="math inline">\(sum_j\)</span>是单调增的</p><p>考虑<span class="math inline">\(a&lt;yb\)</span>,且b优于a:</p><p>令<span class="math inline">\(f_j=dp_j+xsum_j\)</span></p><p><span class="math inline">\(-sum_bx_i+f_b\leq-sum_ax_i+f_a\)</span></p><p><span class="math inline">\(\frac{f_b-f_a}{sum_b-sum_a}\leqx_i\)</span>,这里我们要维护的就是一个下凸包了，并且斜率<spanclass="math inline">\(K(X)=x_i\)</span>是单调增的</p><p>因此直接套板子即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ty</span><br>&#123;<br>    ll x,p,c;<br>&#125;mas[N];<br>ll sum[N];<br>ll xsum[N];<br>ll n;<br>ll dp[N];<br>ll que[N];<br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll l,ll r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> mas[r].x*(sum[r]-sum[l])-(xsum[r]-xsum[l]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Slope</span><span class="hljs-params">(ll a,ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(sum[a]==sum[b]) <span class="hljs-keyword">return</span> inf;<br>    <span class="hljs-type">double</span> x=(dp[a]+xsum[a]-dp[b]-xsum[b])*<span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">double</span> y=(sum[a]-sum[b])*<span class="hljs-number">1.0</span>;<br>    <span class="hljs-keyword">return</span> x/y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;mas[i].x&gt;&gt;mas[i].p&gt;&gt;mas[i].c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) sum[i]=sum[i<span class="hljs-number">-1</span>]+mas[i].p,xsum[i]=xsum[i<span class="hljs-number">-1</span>]+mas[i].x*mas[i].p;<br>    ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>    que[++tl]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[hd],que[hd+<span class="hljs-number">1</span>])&lt;mas[i].x) hd++;<br>        dp[i]=dp[que[hd]]+<span class="hljs-built_in">gt</span>(que[hd],i)+mas[i].c;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[tl<span class="hljs-number">-1</span>],que[tl])&gt;<span class="hljs-built_in">Slope</span>(que[tl],i)) tl--;<br>        que[++tl]=i;<br>    &#125;<br>    ll pos=n;<br>    <span class="hljs-keyword">while</span>(mas[pos].p==<span class="hljs-number">0</span>) pos--;<br>    ll ans=inf;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos;i&lt;=n;++i) ans=<span class="hljs-built_in">min</span>(ans,dp[i]);<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>PS:此题有其它坑点，读者自己小心~</p><p><a href="https://www.luogu.com.cn/problem/P2900">[USACO08MAR] LandAcquisition G</a></p><p>大意：</p><p>将<spanclass="math inline">\(n\)</span>块土地分组，每组的价格是这组土地中最大的长宽乘积，问买下所有土地的最小花费。</p><p>思路：</p><p>个人感觉一开始的思路还是有点妙的</p><p>不妨按照长升序排序，如果长相同就宽升序</p><p>从前往后遍历的时候，考虑<spanclass="math inline">\(i&lt;j\)</span>，显然如果<spanclass="math inline">\(i,j\)</span>放一组，长一定是取<spanclass="math inline">\(j\)</span>的，那么如果<spanclass="math inline">\(j\)</span>的宽也大于<spanclass="math inline">\(i\)</span>的话，那么<spanclass="math inline">\(i\)</span>就没有任何贡献。所以我们可以用一个栈来维护，把没用的东西踢掉。显然在最优决策下，每一组的土地会是连续的一段</p><p>考虑<spanclass="math inline">\(dp_i\)</span>表示排序弹出处理之后前i个土地的最小值：</p><p><span class="math inline">\(dp_i=min_{j\leqi}\{dp_j+b_{j+1}a_i\}\)</span>,其中<spanclass="math inline">\(a\)</span>表示长，<spanclass="math inline">\(b\)</span>表示宽</p><p>这里<spanclass="math inline">\(b_j\)</span>在处理之后是降序的，我们可以转化成<spanclass="math inline">\(dp_i=min_{j\leqi}\{dp_j-b&#39;_{j+1}a_i\},b&#39;_j=-b_j\)</span></p><p>考虑<span class="math inline">\(x&lt;y\)</span>,且y优于x</p><p><span class="math inline">\(-b&#39;_ya_i+dp_j\leq-b&#39;_xa_i+dp_x\)</span></p><p><span class="math inline">\(\frac{dp_x-dp_y}{b&#39;_x-b&#39;_y}\leqa_i\)</span>，还是维护一个下凸包，并且斜率<spanclass="math inline">\(a_i\)</span>是单增的，所以也是直接套板子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ty</span><br>&#123;<br>    ll a,b;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> ty &amp; B) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(a==B.a) <span class="hljs-keyword">return</span> b&lt;B.b;<br>        <span class="hljs-keyword">return</span> a&lt;B.a;<br>    &#125;<br>&#125;mas[N];<br>ll n;<br>ll que[N];<br>ll dp[N];<br>ty st[N];<br>ll top=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Slope</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(st[x+<span class="hljs-number">1</span>].b==st[y+<span class="hljs-number">1</span>].b) <span class="hljs-keyword">return</span> inf;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>*((dp[y]-dp[x])/(-st[y+<span class="hljs-number">1</span>].b+st[x+<span class="hljs-number">1</span>].b));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;mas[i].a&gt;&gt;mas[i].b;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(mas+<span class="hljs-number">1</span>,mas+<span class="hljs-number">1</span>+n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(top)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(mas[i].b&gt;=st[top].b) top--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        st[++top]=mas[i];<br>    &#125;<br>    ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>    que[++tl]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=top;++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[hd],que[hd+<span class="hljs-number">1</span>])&lt;st[i].a) hd++;<br>        <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;que[hd]&lt;&lt;endl;</span><br>        dp[i]=dp[que[hd]]+st[que[hd]+<span class="hljs-number">1</span>].b*st[i].a;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[tl<span class="hljs-number">-1</span>],que[tl])&gt;<span class="hljs-built_in">Slope</span>(que[tl],i)) tl--;<br>        que[++tl]=i;<br>    &#125;<br>    cout&lt;&lt;dp[top]&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><ahref="https://www.luogu.com.cn/problem/P4027">[ZJOI2007]仓库建设</a></p><p>大意：</p><p><del>本人太懒。。。</del></p><p>思路：</p><p>这题就是需要cdq分治的题了</p><p>考虑<spanclass="math inline">\(f_i\)</span>表示第i天能够获得的最大钱数，<spanclass="math inline">\(g_i\)</span>表示第i天最多能买多少张B券</p><p>则<span class="math inline">\(\largeg_i=\frac{f_i}{r_ia_i+b_i}\)</span></p><p>故<span class="math inline">\(f_i=max\{max_{j\leqi-1}\{g_j\frac{b_i}{a_i}+r_jg_j\}*a_i,f_{i-1}\}\)</span></p><p>外层的max我们可以直接特判，内层的max就是一个典型的斜率优化dp了。</p><p>考虑<spanclass="math inline">\(g_x&lt;g_y\)</span>,且y优于x（这里<spanclass="math inline">\(g\)</span>不是单调的，我们不能直接假设<spanclass="math inline">\(x&lt;y\)</span>）,l令<spanclass="math inline">\(F_j=r_jg_j\)</span></p><p><span class="math inline">\(g_x\frac{b_i}{a_i}+F_x\geqg_y\frac{b_i}{a_i}+F_y\)</span></p><p>即<span class="math inline">\(\large \frac{F_x-F_y}{g_x-g_y}\leq-\frac{b_i}{a_i}\)</span></p><p>实际还是一个下凸包。这里横坐标是<spanclass="math inline">\(g_j\)</span>,纵坐标是<spanclass="math inline">\(F_j\)</span>,斜率是<spanclass="math inline">\(-\frac{b_i}{a_i}\)</span></p><p>横坐标不是单调的，斜率也不是单调的，看起来不是能用普通凸包来维护的样子。所以我们可以使用cdq分治</p><p>想要用单调队列维护凸包的话，我们实际上有三维偏序：</p><ul><li>对于每一个i，它的决策点是<spanclass="math inline">\(\{j|j&lt;i\}\)</span>，也就是id较小的点才可以更新id较大的点</li><li>维护凸包的时候，如果x先于y加入凸包，要满足<spanclass="math inline">\(g_x&lt;g_y\)</span></li><li>凸包查询最优决策点的时候，如果x先于y查询，要满足<spanclass="math inline">\(K(x)&lt;K(y)\)</span>，因为我们要利用决策点不降的性质来加速选择最优点的过程</li></ul><p>显然，三维偏序正是cdq分治的拿手好戏~</p><ul><li>第一关键字：首先将点按照斜率升序排序，能够保证查询的斜率递增，从而能用单调队列维护</li><li>第二关键字：分治时按照id分成左右两个部分。这样保证最后递归到叶子节点的时候是符合原本顺序的，且斜率查询的时候保证都是维护的点的id都是在自己之前的（其实就是一个归并排序）</li><li>第三关键字：x每次分治结束之后内部不再有贡献，所以我们可以直接按照横坐标升序排序方便后面维护凸包</li></ul><p>我们会发现这样处理之后就能够实现三维偏序了。</p><p>cdq分治的灵魂是用前半部分的信息来统计对后半部分的贡献，当一段区间分治结束之后，这段区间内的信息就全部处理完了，换句话说，区间内部的点之间是不会再产生贡献了，因此我们才可以随意更改该区间内部的点的顺序。将其按照横坐标排序，我们才能进行凸包的维护。同时，以横坐标为关键字的排序我们可以直接sort，但是也可以采用归并排序</p><p>最后，求出<span class="math inline">\(f_i\)</span>之后，再与<spanclass="math inline">\(f_{i-1}取max\)</span>，并更新<spanclass="math inline">\(g_i\)</span></p><p>具体流程：</p><ul><li>if(l==r) 更新，退出</li><li>按照id分成左右两部分<spanclass="math inline">\([l,mid],(mid,r]\)</span></li><li>cdq(l,mid)</li><li>此时<spanclass="math inline">\([l,mid]\)</span>已经处理好了，所以用单调队列对<spanclass="math inline">\([l,mid]\)</span>建凸包</li><li><span class="math inline">\((mid,r]\)</span>区间此时是以<spanclass="math inline">\(\frac{-b_i}{a_i}\)</span>升序,所以按顺序更新即可，并更新凸包</li><li>cdq(mid+1,r)</li><li>按照横坐标对<spanclass="math inline">\([l,r]\)</span>进行归并，因为该区间内部不会再有互相的贡献了</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> il inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps =<span class="hljs-number">1e-8</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e17</span>;<br>ll n;<br><span class="hljs-type">double</span> s;<br><span class="hljs-type">double</span> A[N],B[N],R[N];<br><span class="hljs-type">double</span> f[N],X[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ty</span><br>&#123;<br>    ll id;<br>    <span class="hljs-type">double</span> slope;<br>    <span class="hljs-type">double</span> a,b,k;<br>    <span class="hljs-comment">//第一关键字：斜率 按照斜率升序能够保证查询的斜率递增，从而能用单调队列维护</span><br>    <span class="hljs-comment">//第二关键字：id 分治时按照id分成左右两个部分。这样保证最后递归到叶子节点的时候是符合原本顺序的</span><br>    <span class="hljs-comment">//且斜率查询的时候保证都是维护的点的id都是在自己之前的</span><br>    <span class="hljs-comment">//第三关键字：x 每次分治结束之后内部不再有贡献，则按照x升序排方便后面维护凸包</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> ty &amp; b) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(slope==b.slope) <span class="hljs-keyword">return</span> id&lt;b.id;<br>        <span class="hljs-keyword">return</span> slope&gt;b.slope;<span class="hljs-comment">//斜率递减</span><br>    &#125;<br>&#125;mas[N],tmp[N];<br>ll que[N];<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Slope</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(X[mas[x].id]==X[mas[y].id])<br>    &#123;<br>        <span class="hljs-keyword">return</span> inf;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (X[mas[y].id]*mas[y].k-X[mas[x].id]*mas[x].k)/(X[mas[y].id]-X[mas[x].id]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> id,<span class="hljs-type">double</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[mas[id].id]&lt;val)<br>    &#123;<br>        f[mas[id].id]=val;<br>        X[mas[id].id]=f[mas[id].id]/(mas[id].k*mas[id].a+mas[id].b);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cdq</span><span class="hljs-params">(ll l,ll r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r)<br>    &#123;<br>        f[mas[l].id] = <span class="hljs-built_in">max</span>(f[mas[l].id],f[mas[l].id<span class="hljs-number">-1</span>]);<span class="hljs-comment">//这里的f_&#123;i-1&#125;是所有排序前的i-1，所以要稍微绕一下，注意别弄错</span><br>        X[mas[l].id]=f[mas[l].id]/(mas[l].k*mas[l].a+mas[l].b);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    ll posl=l,posr=mid+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(mas[i].id&lt;=mid) tmp[posl++]=mas[i];<br>        <span class="hljs-keyword">else</span> tmp[posr++]=mas[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;++i) mas[i]=tmp[i];<br>    <span class="hljs-comment">//按照id处理好了</span><br>    <span class="hljs-built_in">cdq</span>(l,mid);<br>    <span class="hljs-comment">//先处理前一个部分，保证此时前半部分的x是升序的</span><br>    ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=mid;++i)<span class="hljs-comment">//维护凸包</span><br>    &#123;<br>        <span class="hljs-keyword">while</span>(tl&gt;hd&amp;&amp;<span class="hljs-built_in">Slope</span>(que[tl<span class="hljs-number">-1</span>],que[tl])&lt;<span class="hljs-built_in">Slope</span>(que[tl],i)+eps) tl--;<br>        que[++tl]=i;<br>    &#125;<br>    ll id;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=mid+<span class="hljs-number">1</span>;i&lt;=r;++i)<span class="hljs-comment">//计算两边产生的贡献</span><br>    &#123;<br>        <span class="hljs-keyword">while</span>(tl&gt;hd&amp;&amp;<span class="hljs-built_in">Slope</span>(que[hd],que[hd+<span class="hljs-number">1</span>])&gt;mas[i].slope) hd++;<br>        <span class="hljs-built_in">upd</span>(i,X[mas[que[hd]].id]*(mas[que[hd]].k-mas[i].slope)*mas[i].a);<br>    &#125;<br>    <span class="hljs-built_in">cdq</span>(mid+<span class="hljs-number">1</span>,r);<br><br>    posl=l,posr=mid+<span class="hljs-number">1</span>;<br>    ll tot=l<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(posl&lt;=mid&amp;&amp;posr&lt;=r)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(X[mas[posl].id]&lt;X[mas[posr].id]) tmp[++tot]=mas[posl++];<br>        <span class="hljs-keyword">else</span> tmp[++tot]=mas[posr++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(posl&lt;=mid) tmp[++tot]=mas[posl++];<br>    <span class="hljs-keyword">while</span>(posr&lt;=r) tmp[++tot]=mas[posr++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;++i) mas[i]=tmp[i];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;A[i]&gt;&gt;B[i]&gt;&gt;R[i];<br>        mas[i].id=i;<br>        mas[i].a=A[i];mas[i].b=B[i];mas[i].k=R[i];<br>        mas[i].slope=-B[i]/A[i];<br>        <span class="hljs-comment">// if(i&gt;1) continue;</span><br>        X[mas[i].id]=s/(R[i]*A[i]+B[i]);<br>        <span class="hljs-comment">// mas[i].y=R[i]*mas[i].x;</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) f[i]=s;<br>    <span class="hljs-built_in">sort</span>(mas+<span class="hljs-number">1</span>,mas+<span class="hljs-number">1</span>+n);<br>    <span class="hljs-built_in">cdq</span>(<span class="hljs-number">1</span>,n);<br>    cout&lt;&lt;fixed&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">4</span>)&lt;&lt;f[n]&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="后记">后记</h3><p>斜率优化dp在大部分情况下都是结合决策单调性进行的（<strong>大部分</strong>），所以也比较套路</p><p>另外还有结合Wqs二分来处理前n个数限定分m段的情况等的套路，个人感觉决策单调性优化的水还是有点深的，有空会试试写一期总结</p><p>加油~</p>]]></content>
    
    
    <categories>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>动态规划</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>群作用</title>
    <link href="/2023/12/19/%E7%BE%A4%E4%BD%9C%E7%94%A8/"/>
    <url>/2023/12/19/%E7%BE%A4%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="群作用轨道-稳定化子定理">群作用，轨道-稳定化子定理</h1><p>不妨通过一个简单的例子来引入群作用的概念，恕我直言这个东西真的很神奇</p><h2 id="引入">引入</h2><blockquote><p>令<spanclass="math inline">\(S\)</span>是一个非空集合，我们考虑所有<spanclass="math inline">\(S \rightarrow S\)</span>的双射<spanclass="math inline">\(f\)</span>所组成的集合，记为<spanclass="math inline">\(Perm(S)\)</span>，事实上它关于映射的复合作成一个群，即<span class="math inline">\(S\)</span>上的置换群，即<spanclass="math inline">\((Perm(s),\circ)\)</span></p></blockquote><p>接下来考虑群<spanclass="math inline">\(G\)</span>上，对于一个特定的元素<spanclass="math inline">\(x\in G\)</span>的映射： <spanclass="math inline">\(\phi_x: G\rightarrow G,a\mapstoxa\)</span>,事实上它是一个双射，对于这一点我们只需证明<spanclass="math inline">\(\phi_x\)</span>存在逆映射即可。显然<spanclass="math inline">\(\phi_x\)</span>的逆映射就是<spanclass="math inline">\(\phi_{x^{-1}}: G\rightarrow G,a\mapstox^{-1}a\)</span>，</p><p><font color='orange'><strong>证明： </strong></font> <spanclass="math display">\[(\phi_x\circ\phi_{x^{-1}})(a)=\phi_x((\phi_{x^{-1}}(a)))=\phi_x(x^{-1}a)=xx^{-1}a=a=Id(a)\\(\phi_{x^{-1}}\circ\phi_{x})(a)=\phi_{x^{-1}}((\phi_{x}(a)))=\phi_{x^{-1}}(xa)=x^{-1}xa=a=Id(a)\\\]</span> 其中<span class="math inline">\(Id\)</span>就表示<spanclass="math inline">\(S\rightarrow S\)</span>的恒等映射</p><p>那么此时就有<spanclass="math inline">\((\phi_x)^{-1}=\phi_{x^{-1}}\)</span> ，故<spanclass="math inline">\(\phi_x\)</span>是<spanclass="math inline">\(G到G\)</span>的一个双射 <spanclass="math inline">\(\square\)</span></p><hr /><p>我们很快就注意到<strong><span class="math inline">\(\phi_x\inPerm(G)\)</span></strong> 。将目光从<spanclass="math inline">\(\phi_x\)</span>上再抽象出来一层，我们定义映射<spanclass="math inline">\(\phi:(G,\cdot)\rightarrow (Perm(G),\circ),x\mapsto\phi_x\)</span>。这里有点抽象，前者是一个群<spanclass="math inline">\(G\)</span>，后者也是一个群，但是它是从一个<strong>集合</strong><spanclass="math inline">\(G\)</span>当中得到的，在这个集合里我们忽略了<spanclass="math inline">\(G\)</span>的运算的结构，只考虑它作为集合的结构，从而得到所有在其上的双射组成的<spanclass="math inline">\((Perm(G),\circ)\)</span></p><p>映射的两个对象都是群，令人惊奇的是，事实上<spanclass="math inline">\(\phi\)</span>也是一个群同态：</p><p><font color='orange'><strong>证明：</strong></font></p><p><span class="math inline">\(\phi是良定义的:这一点显然\\\)</span></p><p><span class="math inline">\(\forall x,y\in G，z\in G\)</span> <spanclass="math display">\[(\phi_x\circ\phi_y)(z)=x(yz)=(xy)z=\phi_{xy}(z)\]</span> 对于所有的<spanclass="math inline">\(z\)</span>都满足该性质，故 <spanclass="math display">\[\phi_x\circ \phi_y=\phi_{xy}\]</span> 故 <span class="math display">\[\phi(x\cdot y)=\phi(x)\circ \phi(y)\]</span> <strong>故<span class="math inline">\(\phi\)</span>是<spanclass="math inline">\(G\rightarrow Perm(G)\)</span>的一个群同态</strong> <span class="math inline">\(\square\)</span></p><p>这样的一个神奇的<spanclass="math inline">\(\phi\)</span>就是一个群作用。现在我们给出定义如下</p><h2 id="定义1">定义1</h2><blockquote><p>令<span class="math inline">\(G\)</span>是一个群，<spanclass="math inline">\(S\)</span>是一个非空集合，若<spanclass="math inline">\(\phi:G\rightarrowPerm(S)\)</span>是一个<strong>群同态</strong>，那么称<spanclass="math inline">\(\phi\)</span>是<strong>群</strong><spanclass="math inline">\(G\)</span>在<strong>集合</strong><spanclass="math inline">\(S\)</span>上的一个群作用</p></blockquote><p>在上例中集合<span class="math inline">\(S\)</span>恰好就是<spanclass="math inline">\(G\)</span>本身，但是我们也强调过在<spanclass="math inline">\((Perm(G),\circ)\)</span>中我们已经忽略了<spanclass="math inline">\(G\)</span>作为群的运算结构而只考虑其集合的结构</p><p>从这个定义中我们可以很清晰地看到<spanclass="math inline">\(\phi\)</span>作为一个群同态的优美性质，但是实际上还有另外一种等价的定义，它能帮助我们更好地判断一个映射是否为群作用</p><h2 id="定义2">定义2</h2><blockquote><p>令<span class="math inline">\(G\)</span>是一个群，<spanclass="math inline">\(S\)</span>是一个非空集合，如果映射 <spanclass="math display">\[\sigma: G\cross S\rightarrow S\\\forall a\in G,x\in S,(a,x)\mapstoa\cdot x\\我们记为a作用在x上\]</span> 满足： <span class="math display">\[e\cdot x=x,\forall x\in S\\(ab)\cdot x=a\cdot(b\cdot x),\forall a,b \inG,x\in S\]</span> 那么称群<span class="math inline">\(G\)</span>在集合<spanclass="math inline">\(S\)</span>上<strong>有一个作用</strong> <spanclass="math inline">\((a,x)\mapsto a\cdot x\)</span></p></blockquote><p>仔细观察定义1，<spanclass="math inline">\(\phi\)</span>是我们的群作用，是一个<spanclass="math inline">\(G\rightarrowPerm(s)\)</span>的映射，现在我们取出一个<spanclass="math inline">\(x\)</span>，得到一个<spanclass="math inline">\(\phi_x\inPerm(S)\)</span>,它又是一个映射（事实上是双射），它作用在<spanclass="math inline">\(s\in S\)</span>,会得到<spanclass="math inline">\(\phi_x(s)\in S\)</span>。整个过程实际上就是在<spanclass="math inline">\(G\)</span>中取出一个元素x，在<spanclass="math inline">\(S\)</span>中取出一个元素<spanclass="math inline">\(s\)</span>,也就是对应<spanclass="math inline">\(G\cross S\)</span>,得到一个<spanclass="math inline">\(S\)</span>中的元素，这一过程解释了在定义2中<spanclass="math inline">\(\sigma\)</span>为什么是<spanclass="math inline">\(G\cross S\rightarrow S\)</span>的映射。</p><h2 id="两个定义的联系">两个定义的联系</h2><p>下面我们来证明两个定义其实是等价的：</p><p><font color='orange'><strong>证明:</strong></font></p><p>定义1$$定义2：</p><p>首先<span class="math inline">\(\phi\)</span>确实是<spanclass="math inline">\(G\cross S\rightarrowS\)</span>的映射，我们定义双射 <span class="math display">\[\phi_a: S\rightarrow S\\(a,x)\mapsto a\cdot x,a\in G,x\in S\\\]</span> 则： <span class="math display">\[\forall x\in S,e\cdot x=\phi_e(x)=Id(x)=x,故第一条得证\\\forall a,b\inG,(ab)\cdot x=\phi_{ab}(x)=(\phi_a\circ\phi_b)(x)=\phi_a(\phi_b(x))=\phi_a(b\cdot x)=a\cdot(b\cdotx)\\从而第二条得证\]</span> 定义2<spanclass="math inline">\(\rightarrow\)</span>定义1：</p><p>还是定义 <span class="math display">\[\phi: G\rightarrow Perm(S)\\x\mapsto\phi_x\\其中\phi_x: S\rightarrow S\\s\mapsto x\cdot s,s\in S\]</span> 首先证明<spanclass="math inline">\(\phi_x\)</span>确实是一个双射： <spanclass="math display">\[x\cdot(x^{-1}\cdot s)=(xx^{-1})\cdot s=e\cdot s= s\\x^{-1}\cdot(x\cdots)=(x^{-1}x)\cdot s=e\cdot s= s\]</span> 故<spanclass="math inline">\((\phi_x)^{-1}=\phi_{x^{-1}}\)</span>,所以它确实是一个双射。这一结论是由性质1保证的，因为<spanclass="math inline">\(e\cdot s=s\)</span></p><p>而由性质2，我们知道<spanclass="math inline">\(\phi\)</span>保持运算，所以<spanclass="math inline">\(\phi\)</span>是一个<spanclass="math inline">\(G\rightarrow Perm(S)\)</span>的群同态，所以<spanclass="math inline">\(\phi\)</span>就是群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(S\)</span>上的作用 <spanclass="math inline">\(\square\)</span></p><p>所以第一条性质是为了保证良定义，第二条性质是为了保证群同态，两者合在一起就是对群作用的定义</p><p>这样我们对一个映射就有了判断的条件了，也认识到了其优美的同态性质</p><blockquote><p>同时，如果我们认识到了群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(S\)</span>上有一个群作用 <spanclass="math display">\[(a,x)\mapsto a\cdot x,a\in G,x\in S\]</span> 那么 <span class="math display">\[\phi:G\rightarrow Perm(S)\\x\mapsto a\cdot x\]</span> 就一定是群<span class="math inline">\(G\)</span>到集合<spanclass="math inline">\(S\)</span>的群同态，以及 <spanclass="math display">\[\forall a\in G,\phi_a是S\rightarrow S的双射\]</span> <font color='red'>（当然<spanclass="math inline">\(\phi_a\)</span>不一定是群同态）</font></p></blockquote><h2 id="群作用的核">群作用的核</h2><p>群作用的核定义为定义1中同态<spanclass="math inline">\(\phi\)</span>的核，即<spanclass="math inline">\(Ker\phi\)</span></p><p>故 <span class="math display">\[a\in G是群作用的核\\\Leftrightarrow \phi_a=Id\\ \Leftrightarrow\phi_a(x)=x,\forall x\in S \\\Leftrightarrow a\cdot x=x,\forall x\in S\]</span></p><h2 id="群作用的例子">群作用的例子</h2><p>我们重新审视一下开头讲的例子</p><h3 id="群g在集合g上的左平移">群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(G\)</span>上的左平移</h3><p>令 <span class="math display">\[G\cross G\rightarrow G\\x\mapsto ax      (1)\]</span> 显然有 <span class="math display">\[ex=x,\forall x\in G\\(ab)x=a(bx),\forall a,b\in G,\forall x\in G\]</span> 所以<spanclass="math inline">\((1)\)</span>式给出了一个群作用。这里我们用定义2重新证明了这是一个群作用。</p><p>我们考察一下这个群作用的核 <span class="math display">\[a\in G属于群作用的核\\\Leftrightarrow ax=x,\forall x\inG\\\Leftrightarrow a=e\]</span> 故群作用的核为<spanclass="math inline">\(\{e\}\)</span>,所以<spanclass="math inline">\(\phi:G\rightarrowPerm(G)\)</span>是一个单同态。那么显然<span class="math inline">\(G\congIm\phi\)</span>。又<spanclass="math inline">\(Im\phi&lt;Perm(G)\)</span>,所以群<spanclass="math inline">\(G\)</span>与集合<spanclass="math inline">\(G\)</span>上的一个变换群同构！</p><p>如此我们很轻松地就证明了<spanclass="math inline">\(Cayley\)</span>定理：任意一个群都同构于某一个集合上的变换群</p><p>推论：<font color='blue'>任意一个<strong>有限群</strong>都同构于一个<strong>置换群</strong></font></p><hr /><h3 id="群g在集合g上的共轭作用">群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(G\)</span>上的共轭作用</h3><p>令 <span class="math display">\[G\cross G\rightarrow G\\x\mapsto axa^{-1}      (2)\]</span> 显然有 <span class="math display">\[exe^{-1}=x,\forall x\in G\\(ab)\cdot x=abxb^{-1}a^{-1}=a\cdot(bxb^{-1})=a\cdot(b\cdot x)\]</span> 故<spanclass="math inline">\((2)\)</span>式同样给出了一个群作用，叫做群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(G\)</span>上的共轭作用</p><p>考察该作用的核 <span class="math display">\[a\in G属于群作用的核\\\Leftrightarrow axa^{-1}=x\\\Leftrightarrowax=xa\\ \Leftrightarrowa\in \{b\in G|bx=xb,\forall x\in G\}=Z(G)\]</span> 这里<span class="math inline">\(Z(G)\)</span>称为群<spanclass="math inline">\(G\)</span>的中心。得到<spanclass="math inline">\(Ker\phi=Z(G)\)</span>。</p><p>这里共轭作用比左乘作用的性质要更好一些，因为实际上对于一个作用来说，根据我们之前所说，<span class="math display">\[\phi_a: G\rightarrow G\\x\mapsto axa^{-1}(3)\]</span></p><p>一定是双射，但是却未必是群同态，而共轭作用的每一个<spanclass="math inline">\(\phi_x\)</span><font color='red'>都是一个群同态</font>，从而<font color='red'>都是群同构</font></p><p><strong><font color='orange'>证明：</font></strong></p><p>因为<spanclass="math inline">\(\phi_a\)</span>都是双射，我们只需证明它是群同态即可（不是说<spanclass="math inline">\(\phi\)</span>是群同态，而是对每一个<spanclass="math inline">\(\phi_a\)</span>都是群同态） <spanclass="math display">\[\forall y,z\inG,\phi_a(yz)=a(yz)a^{-1}=aya^{-1}aza^{-1}=\phi_a(y)\phi_a(z)\]</span> 这就证明了共轭作用下每一个<spanclass="math inline">\(\phi_a\)</span>都是<strong>群<spanclass="math inline">\(G\)</span>到自身</strong>的群同构 <spanclass="math inline">\(\square\)</span></p><p>我们称群<spanclass="math inline">\(G\)</span>到自身的同构映射为自同构(automorphism),而由<spanclass="math inline">\((3)\)</span>式定义的同构称为内自同构(innerautomorphism) <span class="math display">\[f是群G的内自同构\Leftrightarrow f是G的共轭作用给出的一个自同构\]</span></p><p>然后我们来研究一些更加深入的东西</p><h2 id="轨道-稳定化子定理">轨道-稳定化子定理</h2><h3 id="轨道">轨道</h3><p>令 <span class="math display">\[\phi:G\rightarrow Perm(s)\\\phi_a(x)=a\cdot x\]</span> 是一个群作用</p><p>那么定义<span class="math inline">\(s\in S\)</span>的轨道<spanclass="math inline">\(Orb(s)\)</span>为 <span class="math display">\[Orb(s)=\{s&#39;\in S|\exist x\in G,xs&#39;=s\}=\{xs|x\in G\}\]</span> 也就是<span class="math inline">\(s\)</span>在所有<spanclass="math inline">\(x\)</span>的作用下能到达的点的集合。我们很快就能看到这个定义有什么用</p><blockquote><p>所有元素<span class="math inline">\(s\)</span>的轨道是集合<spanclass="math inline">\(S\)</span>的一个划分，即</p></blockquote><p><strong><font color='orange'>证明：</font></strong></p><p>定义集合<span class="math inline">\(S\)</span>上的一个二元关系 <spanclass="math display">\[y\sim x\Leftrightarrow \exist a\in G,y=a\cdot x\]</span> 不难验证<spanclass="math inline">\(\sim\)</span>是一个等价关系。所以它给出<spanclass="math inline">\(S\)</span>上的一个划分 <spanclass="math display">\[\begin{flalign}\forall x\in S,\bar{x}&amp;=\{y\in S|y\sim x\}\\&amp;=\{y\in S|\exista\in G,y=a\cdot x\}\\&amp;=\{a\cdot x|a\in G\}\\&amp;=Orb(x)\end{flalign}\\\]</span> <span class="math inline">\(\square\)</span></p><h3 id="一些杂谈">一些杂谈</h3><p>我们先来看看<span class="math inline">\(T\cross X\rightarrowX\)</span>的映射<spanclass="math inline">\(\phi\)</span>,当然它不一定满足群作用的性质，但是这个结构本身有很多值得研究的东西</p><p>不过我们不妨还是定义<span class="math inline">\((t,x)\mapsto t\cdotx\)</span></p><ul><li><p>令<span class="math inline">\(t\in T\)</span>，则集合 <spanclass="math display">\[\{x\in X|t\cdot x=x\}\]</span> 表示的是在变换t下不变的元素</p></li><li><p>令<span class="math inline">\(K\subset T\)</span>，则集合 <spanclass="math display">\[\{x\in X|\forall t\in K,t\cdot x=x\}\]</span> 表示的是在<spanclass="math inline">\(K\)</span>中所有变换<spanclass="math inline">\(t\)</span>下都保持不变的x的集合</p></li></ul><p>相对应的，我们以<spanclass="math inline">\(x\)</span>为主视角看看</p><ul><li><p>令<span class="math inline">\(x\in X\)</span>,则集合 <spanclass="math display">\[\{t\in T|t\cdot x=x\}\]</span> 表示的是固定了<spanclass="math inline">\(x\)</span>的所有变换t</p></li><li><p>令<span class="math inline">\(A\subset X\)</span>,则集合 <spanclass="math display">\[\{t\in T|\forall x\in A,t\cdot x=x\}\]</span> 表示的是固定了A中所有元素<spanclass="math inline">\(x\)</span>的t的集合</p></li></ul><p>事实上，只要给定了形如<span class="math inline">\(T\crossX\rightarrowX\)</span>的映射，我们都能很清晰地指出以上四个集合的内容</p><p>现在再回过头来看稳定化子。</p><h3 id="稳定化子">稳定化子</h3><p>定义<span class="math inline">\(s\in S\)</span>的稳定化子<spanclass="math inline">\(Stab(s)\)</span>为 <span class="math display">\[Stab(s)=\{x\in G|xs=s\}\]</span> 也就是固定了元素<spanclass="math inline">\(s\)</span>的所有<spanclass="math inline">\(x\)</span>,实际上也就是上文的第三个集合</p><blockquote><p>Stab(s)&lt;G</p></blockquote><p><strong><font color='orange'>证明：</font></strong></p><p><span class="math inline">\(\forall x,y\in Stab(s)\)</span>,有 <spanclass="math display">\[x\cdot s=y\cdot s=s\]</span> 从而<span class="math inline">\(x^{-1}\cdot s=x^{-1}\cdot(x\cdot s)=(x^{-1}x)\cdot s=e\cdot s=s\)</span>（关键步骤）</p><p>所以 <span class="math display">\[(yx^{-1})\cdot s=y(x^{-1}\cdot s)=y\cdot s=s\]</span> 故 <span class="math display">\[yx^{-1}\in Stab(s)\]</span> 从而<span class="math inline">\(Stab(s)&lt;G\)</span> <spanclass="math inline">\(\square\)</span></p><p><font color='red'>稍微总结一下我们就能看到一个很眼熟的东西</font></p><h4 id="引理1">引理1</h4><blockquote><p>令<span class="math inline">\(\phi:G\rightarrowPerm(S)\)</span>是一个群作用，则 <span class="math inline">\(\forallx,y\in G,s\in S,x\cdot s=y\cdot s\Leftrightarrow xy^{-1}\inStab(s)\)</span></p></blockquote><p>这与</p><blockquote><p>H&lt;G,则<span class="math inline">\(\forall x,y\inG,xH=yH\Leftrightarrow xy^{-1}\in H\)</span></p></blockquote><p>是很像的</p><p>现在我们知道<spanclass="math inline">\(Stab(s)\)</span>里的元素保持<spanclass="math inline">\(s\)</span>不变，我们还可以再探究一下其同一个陪集的元素对<spanclass="math inline">\(s\)</span>的作用</p><h4 id="引理2">引理2</h4><p><span class="math display">\[\begin{flalign}&amp;aStab(s)=bStab(s)\\&amp;\Leftrightarrow b^{-1}a\in Stab(s)\\&amp;由引理\\&amp;\Leftrightarrow a\cdot s=b\cdot s\end{flalign}\]</span></p><p>所以同一个陪集里的元素对<spanclass="math inline">\(s\)</span>的作用是一样的</p><p>从而我们令 <span class="math display">\[\phi:(G/Stab(s))_l\rightarrow Orb(s)\\ aStab(s)\mapsto a\cdot s\]</span> 那么从而我们可以通过引理2的正向推和逆向推得到<spanclass="math inline">\(\phi\)</span>的合理性以及单射的性质，又由于<spanclass="math inline">\(\phi\)</span>显然是一个满射，从而<spanclass="math inline">\(\phi\)</span>是一个<font color='red'><strong>双射！</strong></font></p><p>如次我们就证得了</p><h3 id="轨道-稳定化子定理-1">轨道-稳定化子定理</h3><blockquote><p>令<span class="math inline">\(\phi:G\rightarrowPerm(S)\)</span>是一个群作用，则<span class="math inline">\(\forall s\inS\)</span>,存在<span class="math inline">\((G/Stab(s))_l\)</span>到<spanclass="math inline">\(Orb(s)\)</span>的双射</p><p>从而<span class="math inline">\(|Orb(s)|=[G:Stab(s)]\)</span></p><p>若<span class="math inline">\(G\)</span>为有限群，则有<strong><spanclass="math inline">\(|G|=|Orb(s)|*|Stab(s)|\)</span></strong></p></blockquote><p>举一个形象的例子</p><p>二面体群 <spanclass="math inline">\(D_{2n}\)</span>，它是由所有正<spanclass="math inline">\(n\)</span>边形到自身的对称变换所构成的。对称变换,就是把<strong>自身映到自身</strong>，而且是保距的。保距指的是，原先距离相同的点，变换后距离仍然相同</p><blockquote><p><span class="math inline">\(|D_{2n}|=2n\)</span></p></blockquote><p><font color='orange'><strong>证明：</strong></font></p><p>首先正n边形有n个旋转变换，以及n个对称变换（绕n个对称轴分别翻转），这样就有<spanclass="math inline">\(2n\)</span>个元素了，我们要证明只有这些元素</p><p>任取正n边形的一个顶点<spanclass="math inline">\(s\)</span>,考虑其轨道<spanclass="math inline">\(Orb(s)\)</span>,最多只能到达n个顶点，而n个旋转变换就恰好可以让s到达n个不同顶点，所以<spanclass="math inline">\(|Orb(s)|=n\)</span></p><p>然后考虑<span class="math inline">\(Stab(s)\)</span>,我们要保持<spanclass="math inline">\(s\)</span>不变，不难发现只有两种变换满足要求，一个是恒等变换，另一个是绕s的对称轴翻转的变换，从而<spanclass="math inline">\(Stab(s)=2\)</span></p><p>所以<spanclass="math inline">\(|D_{2n}|=|Orb(s)|*|Stab(s)|=2n\)</span> <spanclass="math inline">\(\square\)</span></p>]]></content>
    
    
    <categories>
      
      <category>抽象代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>抽象代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Burnside引理</title>
    <link href="/2023/12/18/Burnside/"/>
    <url>/2023/12/18/Burnside/</url>
    
    <content type="html"><![CDATA[<h1id="burnside引理pólya定理及其应用">Burnside引理,Pólya定理及其应用</h1><h2 id="burnside引理">Burnside引理</h2><p>书接上回，继续深入研究在群作用下集合的轨道与稳定子群的相关性质</p><p>现在我们想要研究这样一个问题： <span class="math display">\[有限群G在有限集合S上面有一个作用，那么S的G-轨道条数是多少\]</span> 也就是在有限群<spanclass="math inline">\(G\)</span>作用下集合<spanclass="math inline">\(S\)</span>的等价类的数量</p><p>不妨设<span class="math inline">\(S\)</span>有<spanclass="math inline">\(r\)</span>条<spanclass="math inline">\(G\)</span>-轨道条数，那么就有 <spanclass="math display">\[S=\bigcup_{i=1}^{r}Orb(x_i)\]</span> 其中<spanclass="math inline">\(x_i\)</span>就是每一条轨道的代表元。注意到任意两条轨道交集为空，所以<span class="math display">\[|S|=\bigcup_{i=1}^{r}|Orb(x_i)|=\bigcup_{i=1}^{r}\frac{|G|}{|Stab(x_i)|}\]</span>这里有点怪，它似乎暗示我们<strong>同一个轨道的元素的不变子群的阶都是一样的</strong>。我们再仔细研究一下</p><p><span class="math inline">\(\forall x,y\in S\)</span>,且<spanclass="math inline">\(x\)</span>,<spanclass="math inline">\(y\)</span>在同一条轨道里面，<spanclass="math inline">\(\exist a\in G,a\cdot x=y\)</span>。则 <spanclass="math display">\[\begin{flalign}&amp;h\in Stab(y)\Leftrightarrow h\cdot y=y\\ &amp;\Leftrightarrow h\cdot(a\cdot x)=a\cdot x\\ &amp;\Leftrightarrow (ha)\cdot x=a\cdot x\\ &amp;\Leftrightarrow a^{-1}\cdot ((ha)\cdot x)=(a^{-1}\cdot (a\cdotx))\\ &amp;\Leftrightarrow (a^{-1}ha)\cdot x=x\\ &amp;\Leftrightarrow a^{-1}ha\in Stab(x)\\ &amp;\Leftrightarrow h\in a^{-1}Stab(x)a\end{flalign}\]</span></p><p>注意到上述过程都是等价的，所以我们很快得到 <spanclass="math display">\[Stab(y)=a^{-1}Stab(x)a\]</span> <font color='green'>于是我们得到如下命题</font></p><blockquote><p>设有限群<span class="math inline">\(G\)</span>在有限集合<spanclass="math inline">\(S\)</span>上面有一个作用，那么同一个<spanclass="math inline">\(G\)</span>-轨道的点的稳定子群彼此共轭，从而它们彼此同构</p></blockquote><p>同构的群之间显然阶数相等，这也解答了我们刚刚的疑惑。</p><p>现在再来重新审视一个轨道<spanclass="math inline">\(Orb(x_i)\)</span>,其内部所有元素的稳定子群的阶是相同的，那么内部所有元素的稳定子群的阶数之和就会等于<span class="math display">\[\sum |Stab(x_i)|=|Stab(x_i)||Orb(x_i|=|G|\]</span>那么<font color='red'>集合内部所有元素的稳定子群的阶之和就会等于</font><span class="math display">\[\sum_{x\in S}|Stab(x)|=\sum_{i=1}^{r}|G|=r|G|\quad\quad\quad\quad\quad\quad(1)\]</span> 这启发我们用另一种方法来计算<spanclass="math inline">\(r\)</span>.只要能够得到<spanclass="math inline">\(\sum_{x\in S}|Stab(x)|\)</span>,再除以<spanclass="math inline">\(|G|\)</span>，就能得到<spanclass="math inline">\(r\)</span></p><hr /><p>我们考虑<span class="math inline">\(G\cross S\)</span>的一个子集<spanclass="math inline">\(K=\{(a,x)|a\cdot x=x\}\)</span>,</p><p>对于一个给定的<span class="math inline">\(x\in S\)</span>,以<spanclass="math inline">\(x\)</span>作为第二个值的有序对<spanclass="math inline">\((a,x)\)</span>的数量显然就是<spanclass="math inline">\(|Stab(x)|\)</span>,所以 <spanclass="math display">\[|K|=\sum_{x\in S}|Stab(x)|\]</span> 问题又转化成了求<spanclass="math inline">\(|K|\)</span>,不过我们离成功已经很近了。</p><p>事实上将问题转化成求<spanclass="math inline">\(|K|\)</span>是很有好处的，因为我们可以以<spanclass="math inline">\(x\)</span>为关键字来看待它，当然也可以以<spanclass="math inline">\(a\)</span>为关键字来看。如此，对于一个给定的<spanclass="math inline">\(a\in G\)</span>,所有以<spanclass="math inline">\(a\)</span>为第一个值的有序对对应的x组成一个集合<spanclass="math inline">\(F_a=\{x|a\cdot x=x\}\)</span>,我们记其为<spanclass="math inline">\(a\)</span>的不动点集</p><p>那么 <span class="math display">\[\sum_{x\in S}|Stab(x)|=|K|=\sum_{a\in G}|F_a|\]</span> 从而由<span class="math inline">\((1)\)</span>式可知 <spanclass="math display">\[r=\frac{\sum_{x\in S}|Stab(x)|}{|G|}=\frac{1}{|G|}\sum_{a\in G}|F_a|\]</span> <font color='green'>于是我们得到<spanclass="math inline">\(Burnside\)</span>引理如下：</font></p><blockquote><p>设有限群<span class="math inline">\(G\)</span>在有限集合<spanclass="math inline">\(S\)</span>上有一个群作用，那么<spanclass="math inline">\(S\)</span>的<spanclass="math inline">\(G\)</span>-轨道条数<spanclass="math inline">\(r\)</span>为 <span class="math display">\[r=\frac{1}{|G|}\sum_{a\in G}|F_a|\]</span></p></blockquote><p>这个引理的意义在于，原本单纯只跟集合<spanclass="math inline">\(S\)</span>有关的问题，我们可以借用群<spanclass="math inline">\(G\)</span>来解决了，而群<spanclass="math inline">\(G\)</span>在一些特定情况下有良好的性质能够帮助我们快速计算<spanclass="math inline">\(\sum_{a\in G}|F_a|\)</span></p><h3 id="应用">应用</h3><p>来个具体的例子</p><blockquote><p>给定一个大小为n的环，环上每一个点有m种染色方案。问总共可以染出多少个本质不同的环。这里环本质不同定义为无法通过旋转得到</p></blockquote><p>不妨记环上点的集合为<spanclass="math inline">\(B=\{b_1,b_2,...b_n\}\)</span>,染色方案集合为<spanclass="math inline">\(C=\{c_1,c_2,...c_m\}\)</span>,考虑集合 <spanclass="math display">\[S=B^C=\{X_i\},其中X_i=&lt;c_{i_1},c_{i_2},...c_{i_n}&gt;,1\leq i_j\leq m\]</span> <spanclass="math inline">\(S\)</span>的实际含义就是所有给<spanclass="math inline">\(B\)</span>中元素染色的方案的集合,每一个方案用一个n元排列表示,显然<spanclass="math inline">\(|S|=m^n\)</span></p><p>现在考虑在集合<span class="math inline">\(B\)</span>上的置换群<spanclass="math inline">\(Perm(B)\)</span>的子群<spanclass="math inline">\(G=\{\bigl(\begin{smallmatrix} 1 &amp; 2 &amp; ...&amp; n-1 &amp; n\\ 2 &amp; 3 &amp; ...&amp; n &amp; 1\end{smallmatrix}\bigr),\bigl(\begin{smallmatrix}  1&amp; 2 &amp; 3&amp; ... &amp; n-1 &amp; n\\ 3 &amp; 4&amp; ...&amp; n &amp; 1 &amp; 2\end{smallmatrix}\bigr),...,(1)\}\)</span>,其中<spanclass="math inline">\(G_i=\bigl(\begin{smallmatrix}  1&amp;2 &amp;3&amp;4&amp;... &amp; n-1 &amp; n\\  i+1&amp; i+2 &amp; ... &amp; n&amp; 1 &amp;...&amp;i \end{smallmatrix}\bigr)\)</span>。显然<spanclass="math inline">\(|G|=n\)</span>。此外不难证明<spanclass="math inline">\(G\)</span>确实是一个群，这里就不证了。</p><p><font color='red'><strong>至于为什么要这样定义，是因为<spanclass="math inline">\(G\)</span>中元素实际上代表的就是一个环的旋转（这一点不难发现）与题目给出的本质不同的定义相吻合。整个<spanclass="math inline">\(G\)</span>就恰好代表了环上的所有旋转操作，如果我们能证明有限群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(S\)</span>上有一个作用,那么本质不同的环的数量不就是<spanclass="math inline">\(S\)</span>的<spanclass="math inline">\(G\)</span>-轨道条数了吗，从而可以用<spanclass="math inline">\(Burnside\)</span>引理求解</strong></font></p><p>我们来证明有限群<span class="math inline">\(G\)</span>确实在集合<spanclass="math inline">\(S\)</span>上有一个作用</p><p><strong><font color='orange'>证明：</font></strong></p><p>考虑 <span class="math display">\[\phi:G\cross S\rightarrow S\\ (a,x)\mapsto a\cdot x\]</span> 这里<span class="math inline">\(a\)</span>是一个置换，<spanclass="math inline">\(x\)</span>是一个大小为<spanclass="math inline">\(n\)</span>的排列，那么此时<spanclass="math inline">\(a\cdot x\)</span>就是一个普通的置换在排列上的作用了，这样定义显然是合理的。</p><p>要证明<span class="math inline">\(G\)</span>在<spanclass="math inline">\(S\)</span>上有群作用，我们只需要证明 <spanclass="math display">\[e\cdot x=x,\forall x\in S\\ (a\circ b)\cdot x=a\cdot (b\cdot x)\]</span> 第一点非常显然，<spanclass="math inline">\(G\)</span>中的<spanclass="math inline">\(e\)</span>就是恒等变换，它作用在一个排列上显然保持不变</p><p>第二点其实就是置换的复合性质的描述，我们当然知道它是成立的</p><p>从而<span class="math inline">\(G\)</span>确实在<spanclass="math inline">\(S\)</span>上有一个群作用，那么我们就可以用<spanclass="math inline">\(Burnside\)</span>引理来处理这个问题了。 <spanclass="math inline">\(\square\)</span></p><p>我们要求本质不同的环的数量，也就是求<spanclass="math inline">\(S\)</span>的<spanclass="math inline">\(G\)</span>-轨道条数<spanclass="math inline">\(r\)</span>,从而 <span class="math display">\[r=\frac{1}{|G|}\sum_{a\in G}|F_a|=\frac{1}{n}\sum_{a\in G}|F_a|\]</span> 此时问题变成对于<spanclass="math inline">\(G\)</span>内的每一个置换，求其不动点集的阶</p><hr /><p>不妨来看个简单版本，我们就令<spanclass="math inline">\(n=4\)</span>。此时总共有4个置换，</p><ul><li><span class="math inline">\(a_1=\bigl(\begin{smallmatrix} 1 &amp; 2&amp; 3 &amp; 4 \\ 2 &amp; 3 &amp;4 &amp; 1\end{smallmatrix}\bigr)\)</span>,​此时显然需要<spanclass="math inline">\(x_i\)</span>内所有<spanclass="math inline">\(c_{i_j}\)</span>都相等，从而<spanclass="math inline">\(|F_{a_1}|=m\)</span></li><li><span class="math inline">\(a_2=\bigl(\begin{smallmatrix} 1 &amp; 2&amp; 3 &amp; 4 \\ 3 &amp; 4 &amp; 1 &amp; 2\end{smallmatrix}\bigr)\)</span>,<spanclass="math inline">\(1,3\)</span>是一组，<spanclass="math inline">\(2,4\)</span>是一组，所以<spanclass="math inline">\(|F_{a_2}|=m^2\)</span></li><li>同理可得<span class="math inline">\(|F_{a_3}|=m\)</span></li><li><span class="math inline">\(a_4=(1)\)</span>,每一个排列在<spanclass="math inline">\(a_4\)</span>作用下都保持不变，元素对应的颜色自然也不变，从而<spanclass="math inline">\(|F_{a_4}|=|S|=m^n\)</span></li></ul><p>从而<spanclass="math inline">\(r=\frac{1}{n}(m^n+2m+m^2)\)</span></p><hr /><p>但是当<spanclass="math inline">\(n\)</span>逐渐变大的时候,这种暴力枚举的方法将会变的寸步难行。这里再引入一个概念</p><h3 id="置换群的轮换指标">置换群的轮换指标</h3><p>置换型：如果<span class="math inline">\(n\)</span>元置换<spanclass="math inline">\(g\)</span>中有<spanclass="math inline">\(b_i\)</span>个长度为<spanclass="math inline">\(i\)</span>的轮换，那么<spanclass="math inline">\(g\)</span>的置换型为<spanclass="math inline">\({x_1}^{b_1}{x_2}^{b_2}...{x_n}^{b_n}\)</span>，其中<spanclass="math inline">\(\sum i*b_i=n\)</span>显然成立。这里<spanclass="math inline">\(x_i\)</span>只是一个形式</p><blockquote><p>设<span class="math inline">\((G,\circ)\)</span>是一个<spanclass="math inline">\(n\)</span>元置换群，那么它的轮换指标定义为 <spanclass="math display">\[P_G(x_1,x_2,...x_n)=\frac{1}{|G|}\sum_{g\inG}x_1^{b_1}x_2^{b_2}...x_{n}^{b_n}\]</span></p></blockquote><p><span class="math inline">\({x_i}^{b_i}\)</span>就表示在一个置换<spanclass="math inline">\(g\)</span>内有<spanclass="math inline">\(b_i\)</span>个<spanclass="math inline">\(i\)</span>-轮换，而对于一个轮换，其内所有点都是可以互相到达的，所以轮换内部的点的颜色一定得相同，从而这个轮换的染色方案就是<spanclass="math inline">\(m\)</span>,从而,对于置换<spanclass="math inline">\(g\)</span>,<spanclass="math inline">\(|F_g|=m^{b_1}m^{b_2}...m^{b_n}\)</span></p><p>从而 <span class="math display">\[r=\frac{1}{|G|}\sum_{a\in G}|F_a|=\frac{1}{|G|}\sum_{a\inG}x_1^{b_1}x_2^{b_2}...x_{n}^{b_n}=P_G(x_1,x_2,...x_n)\]</span> 现在问题就变成了求置换群<spanclass="math inline">\(G\)</span>的轮换指标</p><p>这里给出一些结论</p><h4 id="正n边形的旋转群的轮换指标">正n边形的旋转群的轮换指标</h4><p><span class="math display">\[P_G=\frac{1}{n}\sum_{d|n}\phi_d{x_d}^{\frac{n}{d}}\]</span></p><p>这其实就是我们刚刚在研究的问题</p><p>注意到正n边形的旋转群<span class="math inline">\(G\)</span>中，<spanclass="math inline">\(G_i\)</span>就表示旋转步长为<spanclass="math inline">\(i\)</span>的置换组成，我们有如下结论： <spanclass="math display">\[|F_{G_i}|=(n,i)\]</span> <strong><font color='orange'>证明：</font></strong></p><ul><li><span class="math inline">\(i|n\)</span>,每次走i步，<spanclass="math inline">\(n/i\)</span>次后回到原点，所以该置换可以拆成i个轮换，每一个轮换的阶为<spanclass="math inline">\(n/i\)</span>。显然有<spanclass="math inline">\(|F_{G_i}|=i=(n,i)\)</span></li><li><span class="math inline">\(i\nmid n\)</span>,每次走<spanclass="math inline">\(i\)</span>步，回到原点需要<spanclass="math inline">\(lcm(n,i)\)</span>次，从而每一个轮换的阶为<spanclass="math inline">\(lcm(n,i)/i\)</span>,那么<spanclass="math inline">\(|F_{G_i}|=n/(lcm(n,i)/i)=ni/lcm(n,i)=(n,i)\)</span></li></ul><p><span class="math inline">\(\square\)</span></p><p>未完待续</p>]]></content>
    
    
    <categories>
      
      <category>抽象代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>抽象代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
