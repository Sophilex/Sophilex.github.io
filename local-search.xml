<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Different Designs For LLM KD Loss</title>
    <link href="/posts/bb72292a/"/>
    <url>/posts/bb72292a/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>slides</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>KD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Importance-Aware Data Selection for Efficient LLM Instruction Tuning</title>
    <link href="/posts/7ee4c4ca/"/>
    <url>/posts/7ee4c4ca/</url>
    
    <content type="html"><![CDATA[<p>提出llm微调时的一种数据选择策略。利用In ContextLearning来判断模型在特定指令类型上的表现，从而能够有针对性地选择影响力高的数据。<img src="https://s2.loli.net/2025/11/17/FByYM2I76dZPJsN.png" alt="" width="500"></p><p>指令微调数据可以表示为<span class="math inline">\(\{(x_{1},y_{1}),(x_{2},y_{2}), \dots (x_{n}, y_{n})\}\)</span>，对于每一个<spanclass="math inline">\(x_{i} = (x_{i}^1, x_{i}^2, \dotsx_{i}^Q)\)</span>，对每一个token做embedding操作，得到 <spanclass="math display">\[h_{i}^1, h_{i}^2, \dots h_{i}^Q = E(x_{i}^1, x_{i}^2, \dots x_{i}^Q)\]</span> 这里<spanclass="math inline">\(E\)</span>选择的模型是Bge-en-large。从而指令<spanclass="math inline">\(x_{i}\)</span>的embedding结果为 <spanclass="math display">\[h_{i} = \frac{\sum_{q=1}^{Q}h_{i}^q}{Q}\]</span> 之后用cos similarity找到与<spanclass="math inline">\(h_{i}\)</span>最接近的<spanclass="math inline">\(h_{j}, j\neq i\)</span>，从而定义<spanclass="math inline">\((x_{j},y_{j})\)</span>是<spanclass="math inline">\((x_{i}, y_{i})\)</span>的one shot example</p><p>利用one shot example，我们可以定义数据的重要性： <spanclass="math display">\[MIWV(x_{i},y_{i}) = L_{\theta}(y_{i}|x_{i},C) - L_{\theta}(y_{i}|x_{i})\]</span> 其中<span class="math inline">\(C\)</span>就是<spanclass="math inline">\((x_{i},y_{i})\)</span>的one shotexample。这里<span class="math inline">\(L_{\theta}(y_{i}|x_{i},C) =-\frac{1}{A}\sum_{a=1}^{A}\logp(y_{i}^{a}|x_{i},C,y_{i}^{&lt;a})\)</span>就是正常的CE Loss</p><p>之后取MIWV最高的<spanclass="math inline">\(k\%\)</span>数据即可。这里MIWV越高，代表引入与construct类似的oneshotexample之后，模型的预测结果并没有多少提升，从而其在该数据上的学习更需要注重。需要注意的是，有可能对于样本<span class="math inline">\((x_{i},y_{i})\)</span>，其可能并没有非常接近的one shotexample，引入的最接近的<spanclass="math inline">\((x_{j},y_{j})\)</span>可能反而会阻碍模型预测。这种情况下，该样本的MIWV值也会比较高，从而被采样到，这在一定程度上也保证了训练数据的多样性。</p><p>对数据质量的分析也表示，MIWVtop的样本，其分布质量往往会更好。<img src="https://s2.loli.net/2025/11/17/WevuANiqQG5r29d.png" alt="" width="350"></p><p>最后从实验结果上来看，哪怕仅仅使用前<spanclass="math inline">\(1\%\)</span>的数据，训练效果也比使用全量数据要好，这也代表原始数据是冗余且存在噪声的。这里最优比例在<spanclass="math inline">\(15\%\)</span>左右。<img src="https://s2.loli.net/2025/11/17/BtmwDprndCW5R92.png" alt="" width="350"></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scaling Up Dataset Distillation to ImageNet-1K with Constant Memory</title>
    <link href="/posts/b581fc49/"/>
    <url>/posts/b581fc49/</url>
    
    <content type="html"><![CDATA[<p>针对MTT的一些优化。MTT通过匹配在不同数据集上训练的模型参数，来优化<spanclass="math inline">\(C_{sync}\)</span>. 其损失函数为 <spanclass="math display">\[L =\frac{||\hat{\theta}_{t+T}-\theta^*_{t+M}||_{2}^2}{||\theta^*_{t+T}-\theta^*_{t+M}||_{2}^2}\tag{1}\]</span> 其中<spanclass="math inline">\(\theta^*_{t}\)</span>代表模型在原始数据集<spanclass="math inline">\(C_{pre}\)</span>上训练时第t步的参数，再在此基础上，<spanclass="math inline">\(\hat{\theta}_{t+T}\)</span>代表在合成数据<spanclass="math inline">\(C_{sync}\)</span>上再训练<spanclass="math inline">\(T\)</span>步之后的参数，其中<spanclass="math inline">\(T\ll M\)</span></p><p>注意到 <span class="math display">\[\hat{\theta}_{t+T} = \theta^*_{t} - \beta\nabla_{l}(\theta^*_{t};\hat{X}_{0}) - \beta\nabla_{\theta}l(\hat{\theta}_{t+1};\hat{X}_{1}) - \dots \beta\nabla_{\theta}l(\hat{\theta}_{t+T-1};\hat{X}_{T-1})\tag{2}\]</span> 从而 <span class="math display">\[L&#39; = ||\hat{\theta}_{t+T}-\theta^*_{t+M}||_{2}^2 = ||\theta^*_{t} -\beta\sum_{i=0}^{T-1}\nabla_{\theta}l(\hat{\theta}_{t+i};\hat{X}_{i})-\theta^*_{t+M}||_{2}^2\tag{3}\]</span> 注意到对于任意<spanclass="math inline">\(\tilde{X}_{i}\)</span>，有 <spanclass="math display">\[\frac{\partial L&#39;}{\partial \tilde{X}_{i}} = \frac{\partialL&#39;}{\partial \hat{\theta}_{t+T}}\frac{\hat{\theta}_{t+T}}{\partial\tilde{X}_{i}}\tag{4}\]</span> 由于<spanclass="math inline">\(\hat{\theta}_{t+T}\)</span>的存在，需要将共<spanclass="math inline">\(T\)</span>步的所有梯度都保存下来，从而导致巨大的显存消耗。事实上可以对<span class="math inline">\((3)\)</span>式进行变形，得到<span class="math display">\[\begin{flalign}L&#39; &amp;= ||\theta^*_{t} - \beta\sum_{i=0}^{T-1}\nabla_{\theta}l(\hat{\theta}_{t+i};\hat{X}_{i})-\theta^*_{t+M}||_{2}^2\\&amp;=  \beta^2||\sum_{i=0}^{T-1}\nabla_{\theta}l(\hat{\theta}_{t+i};\hat{X}_{i})||_{2}^2-2\beta(\sum_{i=0}^{T-1}\nabla_{\theta}l(\hat{\theta}_{t+i};\hat{X}_{i}))^T(\theta_{t}^* -\theta^*_{t+M})+C \tag{5}\end{flalign}\]</span> 其中<span class="math inline">\(C = ||\theta_{t}^* -\theta^*_{t+M}||_{2}^2\)</span>，是一个常数</p><p>从<span class="math inline">\((5)\)</span>式出发，可以将<spanclass="math inline">\((4)\)</span>式转化为 <span class="math display">\[\frac{\partial L&#39;}{\partial \tilde{X}_{i}} = 2\beta^2 G^T\frac{\partial}{\partial \tilde{X}_{i}}\nabla_{\theta}l(\hat{\theta}_{t+i};\hat{X}_{i}) - 2\beta\frac{\partial}{\partial\tilde{X}_{i}}(\nabla_{\theta}l(\hat{\theta}_{t+i};\hat{X}_{i}))(\theta_{t}^*- \theta^*_{t+M}) \tag{6}\]</span> 其中<span class="math inline">\(G = \sum_{i=0}^{T-1}\nabla_{l}(\hat{\theta}_{t+i};\hat{X}_{i})\)</span></p><p>在<span class="math inline">\((6)\)</span>式中，第二项只与每一个<spanclass="math inline">\(\tilde{X}_{i}\)</span>有关，只有第二项中<spanclass="math inline">\(G^T\)</span>是与全体步骤的梯度有关的，而其作为梯度之和，可以提前计算好，从而整体显存与迭代步数<spanclass="math inline">\(T\)</span>可以做到不相关，从而显存占用从<spanclass="math inline">\(O(T)\)</span>压到了<spanclass="math inline">\(O(1)\)</span>整体来看，只是对梯度的求法做了一个变形，但确实带来了很好的效果。</p><p>另一点在于标签的使用。作者发现原始的0/1 hardlabel，收敛性差，但如果换成<spanclass="math inline">\((0,1)\)</span>之间的softlabel，会有更好效果。因此作者使用目标步长<spanclass="math inline">\(\theta_{t+M}^*\)</span>的参数作为教师，生成softlabel概率分布。这一点其实与KD是一致的。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KD</tag>
      
      <tag>Dataset_Condensation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Squeeze, Recover and Relabel: Dataset Condensation at ImageNet Scale From A New Perspective</title>
    <link href="/posts/750bb55b/"/>
    <url>/posts/750bb55b/</url>
    
    <content type="html"><![CDATA[<p>以往的datasetdistillation都是基于耦合的双层优化的，内层优化模型关于syntheticdataset的参数，外层优化syntheticdataset。但是当原始数据集很大/模型很大的时候，这一双层优化过程的速度就会很慢。作者提出对这一过程进行解耦，从而将原本的平方复杂度降低至线性。<img src="https://s2.loli.net/2025/10/13/Ty54tuAEn3F7JvK.png" width="500"></p><p>其阶段可以分为三个部分 <imgsrc="https://s2.loli.net/2025/10/13/hNnfx9b3qyUcjVR.png" /></p><p>首先进行数据集信息的凝练，将其存入模型参数中。 <spanclass="math display">\[\theta_{T} = argmin_{\theta}L_{T}(\theta)\tag{1}\]</span>这一步实现起来并没有多余设计，就是让模型在原始数据集上进行训练，并冻结参数。不过作者指出，数据集的一部分重要信息，是由BN中的mean和variance记录的，因此后续需要用BN的信息进行对齐。但是ViT中使用的是LayerNorm，因此作者也将其修改为BN。注意这里模型在数据集上训练的目的是存储数据集信息，而不是单纯跑到最优性能，因此将ViT的Norm手段修改为BN，虽然性能会掉，但是是可以接受的。</p><p>其次，就是用上一步凝练得到的数据集信息，还原回合成数据集 <spanclass="math display">\[argmin_{C_{syn}} l(\Phi_{\theta_{T}}(\tilde{X}_{syn}, y)) +R_{reg}\tag{2}\]</span> <spanclass="math inline">\((2)\)</span>式中第一部分就是上一步冻结参数的模型<spanclass="math inline">\(\theta_{T}\)</span>在合成数据集<spanclass="math inline">\(C_{syn}\)</span>的一个batch <spanclass="math inline">\(\tilde{X}_{syn}\)</span>上的loss，第二部分是正则化项。注意这里<spanclass="math inline">\(\theta_{T}\)</span>是被冻结的，因此是在单纯优化<spanclass="math inline">\(C_{syn}\)</span></p><p>为了更好对齐数据集，会使用上一轮计算的BN中的mean和variance <imgsrc="https://s2.loli.net/2025/10/13/xo8YqEOKIQBfAFN.png" /></p><p>此外，作者每次是随机在合成数据上截取一个固定大小的区域进行参数优化，从而防止过拟合。</p><p>最后一步，对合成数据集重新进行label标注，这一步使用<spanclass="math inline">\(\theta_{T}\)</span>即可 <spanclass="math display">\[\tilde{y} = \Phi_{\theta_{T}}(\tilde{X}_{R})\tag{3}\]</span> 那么之后就可以用其它数据集在<spanclass="math inline">\(C_{syn}\)</span>上进行训练了 <spanclass="math display">\[L_{syn} = -\sum_{i} \tilde{y}_{i}\log\Phi_{\theta_{C_{syn}}}(\tilde{X}_{R_{i}})\tag{4}\]</span></p><p>总体来说，通过先固定原始数据集<spanclass="math inline">\(C_{pre}\)</span>的信息，让<spanclass="math inline">\(C_{syn}\)</span>来匹配这一信息，可以将原本耦合的两层优化解耦，实现线性复杂度。相比之下，原本是先让模型学习<spanclass="math inline">\(C_{syn}\)</span>上的信息，再用<spanclass="math inline">\(C_{pre}\)</span>来评判模型，就会繁琐很多。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KD</tag>
      
      <tag>Dataset_Condensation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Training-Inference Mismatch In LLM KD(II)</title>
    <link href="/posts/5489d3fa/"/>
    <url>/posts/5489d3fa/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>slides</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>KD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FROM CORRECTION TO MASTERY: REINFORCED DISTILLATION OF LARGE LANGUAGE MODEL AGENTS</title>
    <link href="/posts/498af5ab/"/>
    <url>/posts/498af5ab/</url>
    
    <content type="html"><![CDATA[<p>对agentdistillation的优化。以往KD范式普遍是对一条策略直接进行对齐，其中数据来自TGO或者是SGO。之前的工作已经证明SGO对于缓解学生的exposurebias存在帮助，但是SGO本身往往也面临着exposure bias的影响。 <imgsrc="https://s2.loli.net/2025/09/28/ESe7T1Us64qBi8v.png" /></p><h2 id="trajectory-generation">Trajectory Generation</h2><p><img src="https://s2.loli.net/2025/09/28/ymUCMdcXWs4qG9u.png" /></p><p>这里证明，当不存在其它干预的时候，学生生成策略会随着策略长度而存在平方级别的误差。因此尝试在学生生成SGO的时候引入教师进行干预：当学生生成第一个错误action<spanclass="math inline">\(a_{k}\)</span>的时候，教师才进行介入并且将其改为正确结果<spanclass="math inline">\(a_{k}&#39;\)</span>，然后学生在<spanclass="math inline">\(a_{k}&#39;\)</span>的基础上重新生成下一个action，从而得到action序列为<span class="math inline">\(a_{1},a_{2},\dotsa_{k-1},a_{k}&#39;,a_{k+1},\dots\)</span></p><p>由此得到的教师介入过的SGO‘，<strong>其误差相对于策略长度，可以控制在线性范围内</strong><img src="https://s2.loli.net/2025/09/28/JfNWyomHDnOPGFZ.png" /></p><h2 id="sft-based-on-sgo">SFT Based On SGO'</h2><p>接下来就是利用生成好的数据对学生进行BehaviorCloning对齐。对于每一条策略，以往的方法往往是对齐最后一个action，但是此时每一条策略中往往会存在多个教师介入过的，学生生成效果差的action，在这些地方进行对齐往往能有更好的效果。与此同时，一条策略也可以进行多次对齐，数据效率更高。<img src="https://s2.loli.net/2025/09/28/m5TRBZXE8KaCLut.png" /></p><h2 id="rl-phase">RL Phase</h2><p>使用GRPO进行RL训练。RL面临的常见问题：稀疏奖励，以及长轨迹导致的梯度估计方差过大</p><p>与SFT环节类似，在不同的教师纠正过的地方添加reward并进行对齐，这就同时解决了上述两个问题。对于reward的具体设置：如果最终结果正确的话，会有一个更大的reward<spanclass="math inline">\(R_{final}\)</span>。同时在中间部分为了区分不同token的效果，reward设置为<img src="https://s2.loli.net/2025/09/28/UVH1ju4eA79JtEb.png" />其中<spanclass="math inline">\(a_{k}^{\pi_{E}}\)</span>是教师纠正结果，<spanclass="math inline">\(a_{k}^{orig}\)</span>是学生原始action。如果学生学到了教师的正确action，会有更大的reward，如果其避免了原本的错误，但是依然没有达到教师的结果，会有一个较小的reward。</p><blockquote><p>This reward scheme provides informative credit assignment at thestudent’s weakest step, while maintaining prioritization of final tasksuccess</p></blockquote><h2 id="conclusion">Conclusion</h2><p>精华在于引入教师的纠正，但同时又保留了大部分学生的推理结果，让生成的SGO匹配学生当前性能，又不会具有过大的误差。</p><p><strong>以及，学生是被允许自由探索，与环境交互的，这可能可以带来新路线，这也是为什么<spanclass="math inline">\(reward_{final}\)</span>会有最大的值。而自由探索，在原始蒸馏中应当是没有的，因此由其得到的模型也没有向上扩展的空间</strong></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>KD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Merge-of-Thought Distillation</title>
    <link href="/posts/300ec667/"/>
    <url>/posts/300ec667/</url>
    
    <content type="html"><![CDATA[<p>主要是对LLM COTKD中教师监督范式的改进，尝试将复杂推理能力从多个大模型教师转移到一个更加紧凑的学生模型，在数学题目等数据集上有更好表现。目前可以将教师监督分为：单教师监督(<strong>STD</strong>,Single-Teacher Distillation)，多教师监督(MTD, Multi-TeacherDistillation)。前者很好理解，假定了存在一个足够强大的教师模型，对于不同数据集，不同学生，都能给出足够好的指导。但是现有的结论是</p><blockquote><p>different students have different “best teachers,” and even for thesame student the best teacher can vary across datasets</p></blockquote><p>既然不存在永远最好的教师，而每次重新选择一个好的教师成本又会很大，那么multi-teacherKD可能会是一个解决方案。COT蒸馏的时候，对于multi-teacher的利用，可以直接将所有teacher的COT直接聚集起来，然后打乱，一起扔给student学习。这样做的好处是，可以聚集不同教师的能力，期望能让学生从各个方面得到强化。但是COT本身，随着长度的增加，会包含累积的噪声，以及教师能力本身也对COT质量有影响，从而直接引入多个教师的COT，也可能会带来许多噪声。</p><p><img src="https://s2.loli.net/2025/09/28/HrNxX6PzDu9ECy5.png" />在两个数学数据集上，当学生模型规模比较小(8B)的时候，MTD相比不同singleteacher的STD结果，会有一定优势。但是当模型规模上去(30B)的时候，MTD的结果不优于任何一个singleteacher的STD结果。作者对此的解释是</p><blockquote><p>as the scales of the student model and the teacher model becomeincreasingly close, the student model is more susceptible to theinfluence of teachers with closer distributions, thereby collaspe MTDinto Best STD</p></blockquote><p>即，当学生规模上去时，其更可能受一个教师的影响，从而MTD退化为STD，此时其它教师的COT的噪声可能就会被放大，从而导致MTD不如STD。这种操作在scale之后失效，归根结底是不同教师信息之间没有经过协调。因此作者提出MOT。</p><ul><li>首先，对于不同的教师<spanclass="math inline">\(t_{k}\)</span>，单独用其COT微调一个学生模型的副本<spanclass="math inline">\(s_{k}\)</span>，这一步的操作其实与STD训练是一样的</li><li>从而得到<span class="math inline">\(k\)</span>个学生模型的副本<spanclass="math inline">\(s_{1},s_{2},\dotss_{k}\)</span>，将它们的参数直接取平均 <spanclass="math inline">\(\theta^{t} = \frac{1}{k}\sum_{i=1}^{k}\theta^{t,k}\)</span></li><li>得到<spanclass="math inline">\(\theta^t\)</span>之后，重复上述两个步骤，进而得到<spanclass="math inline">\(\theta^{t+1},\dots, \theta^T\)</span></li></ul><p>期望通过多轮迭代，让不同教师之间的信息收敛，缓解MTD中不同信息互相冲突的情况。回到图1，也不难看出，MOT在绝大部分数据集，模型规模上都取得了领先。</p><h2 id="conclusion">Conclusion</h2><p>单个教师可能在某些时候确实是不够的。SGO监督的时候，教师对SGO可能也并不能有很好的认知，此时聚集多个教师的信息可能会有一定帮助。</p><p>另外，一个经验性的结论：</p><blockquote><p>相比于直接要求基础模型学习各个方面的能力（通过multi-loss或者multi-teacher），可能更应该对其在各个方面单独训练，然后再尝试合在一起。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>KD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Delta Knowledge Distillation for Large Language Models</title>
    <link href="/posts/b9cc2e20/"/>
    <url>/posts/b9cc2e20/</url>
    
    <content type="html"><![CDATA[<p>LLM蒸馏中，指出学生直接模仿教师的分布是欠妥的，因为两者的能力不同，可以尝试学习教师从预训练到SFT后的转变路径。<img src="https://s2.loli.net/2025/09/28/FgW17y6tkQjGbZe.png" /></p><p>具体来说，给定<spanclass="math inline">\(\pi_{s}^{raw}(y|x)\)</span>代表学生的原始预测分布，<spanclass="math inline">\(\pi_{t}^{raw}(y|x)\)</span>代表教师SFT前的预测分布，<spanclass="math inline">\(\pi_{t}^{ft}(y|x)\)</span>代表教师SFT之后的预测分布，希望找到一个目标分布<spanclass="math inline">\(\pi_{s}^*(y|x)\)</span>，能够借鉴到教师从预训练到SFT之后的转变&gt; align the finetuning trajectory of the small model with that of thelarge model by matching their respective behavior shifts</p><p>记 <span class="math display">\[\Delta(p_{1},p_{2})(y|x) = \frac{p_{1}(y|x)}{p_{2}(y|x)}\tag{1}\]</span> 代表目标分布<spanclass="math inline">\(p_{1}\)</span>，原始分布<spanclass="math inline">\(p_{2}\)</span>之间的相对关系，那么对于上述内容，可以表述为<span class="math display">\[\Delta(\pi_{s}^{*}, \pi_{t}^{ft})(y|x) \propto \Delta(\pi_{s}^{raw},\pi_{t}^{raw})(y|x)^\alpha \tag{2}\]</span> 这里<spanclass="math inline">\(\alpha\)</span>用于控制对齐的强度。将<spanclass="math inline">\((1)\)</span>代入<spanclass="math inline">\((2)\)</span>之后，可以得到 <spanclass="math display">\[\pi_{s}^*(y|x) = \frac{1}{Z(x,y)} \pi_{t}^{ft}(y|x) \left(\frac{\pi_{s}^{raw}(y|x)}{\pi_{t}^{raw}(y|x)} \right)^\alpha \tag{3}\]</span> 其中<span class="math inline">\(Z(x,y)\)</span>是归一化项</p><p>然后用KLD将学生参数分布<spanclass="math inline">\(\pi_{\theta}(y|x)\)</span>与目标分布<spanclass="math inline">\(\pi_{s}^{*}(y|x)\)</span>进行对齐即可。同时添加与groundtruth的对齐。这种完全增量的更新目标相对以前还是挺不一样的，有一定道理，值得借鉴。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>KD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Massive Activations in Large Language Models</title>
    <link href="/posts/8a2d197a/"/>
    <url>/posts/8a2d197a/</url>
    
    <content type="html"><![CDATA[<h2 id="massive-activation">Massive Activation</h2><p>探究了LLM中的massive activation。</p><ol type="1"><li><p>LLM中某些activation具有巨大的magnitude，其值比普通activation的多了好几个数量级，并且它们的数量相当稀少，在每个模型中基本只有2-4个，但是确实是普遍存在的<imgsrc="https://s2.loli.net/2025/09/21/EYloPMDjWeq4Cwu.png" /></p></li><li><p>关于这种massiveactivation的存在：往往是在某一层之后突然就出现的，然后会<strong>一直持续</strong>，在末尾几层消失</p></li></ol><blockquote><p>"we have shown that their values largely stay constant in middlelayers"</p><p>"Massive activations exist and remain as largely constant valuesthroughout most of the intermediate layers. They emerge in the initiallayers and start to diminish in the last few layers"</p></blockquote><p><imgsrc="https://s2.loli.net/2025/09/21/lAirI6Ez8M4gwSV.png" />这意味着它们不是通过多层逐渐积累的结果，而是由其它机制引起的</p><p>从feature的角度来看，它们往往出现在<strong>较少</strong>且<strong>固定</strong>的维度上</p><p>从token的角度来看，这种massiveactivation往往出现在起始token以及分隔符等位置<imgsrc="https://s2.loli.net/2025/09/21/PTmDSCHJlEBzyiR.png" /> 3.关于它们的作用，作者分别做了两种对比实验：在其第一次出现的时候，将其置为0，或者直接置为不同输入下的经验平均值<imgsrc="https://s2.loli.net/2025/09/21/Y8qclT9DBWoMwHC.png" />不难看出，将这些极少数的维度置为0，带来了毁灭性的性能下降，但是将其鲁莽地置为平均值，几乎没有带来性能下降，这意味着这种activation的值是相当稳定的，并且<strong>几乎不随输入而变化</strong>，所以作者将其视为模型中的固定且重要的偏差。</p><p>从这一角度可以尝试理解为什么massiveactivation往往出现在起始token以及分隔符等位置。对于分隔符，其往往没有具体含义，从而适合存储此类偏差。而如果在一些具有丰富语义的token上存储massiveactivation的话，可以导致输入信息的丢失。对于出现在起始token，作者的解释为<imgsrc="https://s2.loli.net/2025/09/21/RbTNYALPye6DKqk.png" /></p><h2 id="effects-on-attention">Effects on Attention</h2><p>attention sink现象是指selfattention的注意力权重中，大部分都集中在第一个token上，而这一现象也可以与MassiveAttention关联 <imgsrc="https://s2.loli.net/2025/09/21/2BgjRI8MVwJPGlv.png" /></p><p>不难看出，实际上注意力分数较高的部分，都是与massiveactivation相关联的token，这为attention提供了新的解释</p><p>事实上，如果将<strong>massiveactivation对应维度对注意力分数的贡献</strong>提取出来（关于某个tokenk），其分布也基本是不变的，这为之前的bias的说法提供了依据。<imgsrc="https://s2.loli.net/2025/09/21/tmglZI52A3jC74p.png" />可以看到，其分布在不同输入中高度一致，同时在不同token中也高度一致，一方面说明其稳定性，另一方面印证了<strong>其作为统一的bias的作用</strong>。这种说法还是挺有意思的。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TD3: Tucker Decomposition Based Dataset Distillation Method for Sequential Recommendation</title>
    <link href="/posts/4a91a6ca/"/>
    <url>/posts/4a91a6ca/</url>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2025/09/21/3KWlInuc7bi2GBw.png" /></p><p>主要针对序列推荐数据集的蒸馏。传统的推荐数据集蒸馏方法通常生成独立的合成交互，这些交互无法捕捉<strong>序列数据固有的时间依赖性</strong>，简单地将独立生成的交互组织成序列并不能保证保留时间上的依赖信息。此外，推荐数据集蒸馏自然面对着<strong>数据离散性</strong>对优化的挑战。普遍的解决手段是item参数化，优化得到其分数，然后依分数采样得到最终数据集。但是这也导致一个问题：参数量与数据集大小强相关，对计算，优化的压力都很大。</p><p>首先，原始数据集表示为<span class="math inline">\(\tau =\{x_{i}\}_{i=1}^{|\tau|}, \ x_{i} = [x_{ij}\inV]_{j=1}^{|x_{i}|}\)</span>，用户，样本集合为<spanclass="math inline">\(U,V\)</span>。要合成的序列推荐数据集，可以参数化表示为<spanclass="math inline">\(S\in R^{\mu \times \zeta \times|V|}\)</span>，分别代表user，时间t，以及每一个item的概率。</p><p>内部推荐模型做优化的时候，对于每一个交互，作者并没有选择一个固定的item的embedding作为输入，而是将<spanclass="math inline">\(S\)</span>的最后一维与提前训好的embedding矩阵相乘，相当于对候选items的embedding做了加权。这当然也是有道理的，本身<spanclass="math inline">\(S\)</span>也是学习得到的，不过这一点与之前工作还是不太一样的。事实上这种操作也带来了一个好处：最后不需要对item依据分数采样，也就省去了诸如DconRec中引入gumbalsoftmax之类的麻烦。</p><p>说回面临的挑战，其中之一是参数量与数据集强相关。直接将参数规模做到与数据集规模解耦在推荐场景下可能不是特别现实？不过对参数矩阵引入分解还是可以极大缓解参数压力。作者引入Tucker分解，将<spanclass="math inline">\(S\in R^{\mu \times \zeta \times|V|}\)</span>分解为<span class="math inline">\(S = G \times_{1} U\times_{2} T\times_{3} E\)</span>。其中<span class="math inline">\(G\in\mathbb{R}^{d_{1},d_{2},d_{3}}\)</span>用于建模其余因子之间的关系，<spanclass="math inline">\(U\in \mathbb{R}^{\mu \timesd_{1}}\)</span>表示合成用户的相关信息，<span class="math inline">\(E\in\mathbb{R}^{\zeta \times d_{2}}\)</span>表示时间信息，<spanclass="math inline">\(P\in \mathbb{R}^{|V|\timesd_{3}}\)</span>代表item信息。Tucker分解固定将张量分解为四个小张量，这里作者直接赋予了它们与推荐场景相关的含义，也算有道理吧。其中<spanclass="math inline">\(E\)</span>可以直接用embedding信息替换，不需要训练，其它矩阵梯度下降优化。</p><p>至于两层优化的对应手段，比较常规，内层用KLD对齐要预测item的概率。<strong>当然考虑到前面提到的序列依赖性，这里不能只对齐最后一个item，前面的item也要对齐</strong>。外层就是推荐模型的feature对齐。</p><p>亮点还是提出参数量随数据集规模增长这个问题以及Tucker分解的引入，分解得到的三个因子刚刚好对应了矩阵<spanclass="math inline">\(S\)</span>的三个维度hhh。这块可能也还有发展空间。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dataset_Condensation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dataset Condensation for Recommendation</title>
    <link href="/posts/fb443351/"/>
    <url>/posts/fb443351/</url>
    
    <content type="html"><![CDATA[<p>推荐数据集蒸馏的普遍问题是：</p><ul><li>对于用户的潜在兴趣，往往会被忽略</li><li>难以生成<strong>离散</strong>的user-item交互信息</li></ul><p>首先回顾一下推荐数据集蒸馏操作的基本框架</p><p>记<span class="math inline">\(\Phi: U\times I\rightarrow\mathbb{R}\)</span>代表在对应数据集上训练的推荐模型。对于原始数据集<spanclass="math inline">\(D\in R^{|U|\times|I|}\)</span>，要找到一个较小的数据集<spanclass="math inline">\(D^s\)</span>，其应当满足 <spanclass="math display">\[\underset{D^s}{argmin}\  \underset{(u,i,r)\simD^{val}}{\mathbb{E}}[l(\theta_{D^s}^*(u,i),r)]\ \ \ s.t. \theta_{D^s}^*= \underset{\theta}{argmin}\  \underset{(u,i,r)\sim D^{s}}{\mathbb{E}}[l(\Phi(u,i),r)]\tag{1}\]</span> 其中<spanclass="math inline">\(D^{val}\)</span>是一个验证集，<spanclass="math inline">\(l(\cdot)\)</span>代表对应的可微的loss，其监督模型<spanclass="math inline">\(\Phi\)</span>关于用户<spanclass="math inline">\(u\)</span>对<spanclass="math inline">\(i\)</span>的评分结果。这是一个经典的数据集蒸馏的双层优化问题，其中内层优化对应的模型，外层优化数据集。这里合成数据集<spanclass="math inline">\(D^s\)</span>与<spanclass="math inline">\(D\)</span>一样代表user-item交互信息，其应当是参数化的，然后通过<spanclass="math inline">\((1)\)</span>式进行优化。</p><p>对于第一点，用户未交互的item并不一定是其不感兴趣的，这一隐式关系在原始数据集中通过大量信息的学习也许是可以挖掘出来的，但是当数据集压缩之后，难度可能会变大，因此作者希望在压缩数据集中也能反映出user的潜在感兴趣item。</p><p>实现上，首先需要提前训练一个模型<spanclass="math inline">\(f_{p}\)</span>，找出每一个user的潜在感兴趣item，这些item应当是user未交互过的，从中取出前topK，作为该user的潜在感兴趣item，形式化来说，<span class="math display">\[TopK(u) = \{ i| i = arg\ \text{IsTopK} f_{p}(u,i&#39;), i&#39;\inI&#39;(u) \}\tag{2}\]</span> 其中<span class="math inline">\(I&#39;(u)\)</span>就代表<spanclass="math inline">\(u\)</span>未交互过的item集合。那么接下来，只需要将<span class="math display">\[D^{ps} = \{ (u,i)|u\in U, i\in TopK(u)\}\tag{3}\]</span></p><p>加入原始数据集<spanclass="math inline">\(D\)</span>，就得到最终<strong>增强过的数据集<spanclass="math inline">\(D^{p}\)</span></strong>，其保留原始数据集信息的同时，帮助挖掘出了用户的隐藏兴趣，更有利于数据集质量的提升。整体来说，这一操作还是非常自然，符合直觉的，并且从之后的实验来看，这一操作的收益是很大的。<img src="https://s2.loli.net/2025/09/14/gAltfHaWNhZFOcq.png"alt="|400" /> 关于这里的推荐模型<spanclass="math inline">\(f_{p}\)</span>的选择，跟正常做推荐没啥区别，LighGCN，MF，XSimGCL之类的都是可以的，文中也有不同<spanclass="math inline">\(f_{p}\)</span>选择的对比实验，这里略过。</p><p>接下来是关于<strong>离散</strong>的user-item交互信息的生成。由于交互信息中，每一个<spanclass="math inline">\((u,i)\)</span>对的值只有<spanclass="math inline">\(0,1\)</span>两个值，是离散的，并不能直接用梯度下降进行优化。针对这一点，[1]提出重新构造一个参数矩阵<spanclass="math inline">\(S\)</span>，<spanclass="math inline">\((u,i)\)</span>对的分数<spanclass="math inline">\(S_{(u,i)}\in \mathbb{R}\)</span>，然后依据<spanclass="math inline">\(S_{(u,i)}\)</span>的大小，采样出较为重要的<spanclass="math inline">\((u,i)\)</span>对，用于构造合成数据集<spanclass="math inline">\(D^s\)</span>。这里采样操作是不可微的，因此需要调整为gumbal-softmax。此时分数是连续值，因此也就可以用梯度下降来优化了。</p><p>关于这一点，本文的思路其实是类似的，同样构造一个参数矩阵<spanclass="math inline">\(S\)</span>，但是<spanclass="math inline">\((u,i)\)</span>对的分数<spanclass="math inline">\(S_{u,i}\in(0,1)\)</span>，然后通过Bernoulli采样得到<spanclass="math inline">\(M\)</span>，代表<spanclass="math inline">\((u,i)\)</span>是否在<spanclass="math inline">\(D^s\)</span>中应该有交互，并用<spanclass="math inline">\(M\)</span>构造合成数据集<spanclass="math inline">\(D^s\)</span>。即 <span class="math display">\[P(M|S) = \prod_{(u,i)\inD^p}(S_{u,i})^{M_{u,i}}(1-S_{u,i})^{1-M_{u,i}}\tag{4}\]</span> 同时还需要对<spanclass="math inline">\(||M||_{0}\)</span>进行限制，因为我们需要限制最终合成数据集的规模，其应当满足<span class="math display">\[||M||_{0} \leq r|D|\tag{5}\]</span> 通过<span class="math inline">\((4)\)</span>式，可以将对<spanclass="math inline">\(M\)</span>的限制转化到参数<spanclass="math inline">\(S\)</span>上，即<spanclass="math inline">\((5)\)</span>式可以转化为 <spanclass="math display">\[\mathbb{E}_{p(M|S)}||M_{0}|| = \sum_{(u,i)\in D^p}S_{u,i} =||S||_{1}\tag{6}\]</span> 这就是参数上关于数据集规模的限制，后续<spanclass="math inline">\(S\)</span>在进行更新之后，会额外做一步投影操作将其投影到对应的合法空间，即满足<spanclass="math inline">\(||S||_{1}\leqr|D|,S_{u,i}\in[0,1]\)</span>的空间内</p><p>但是注意到Bernoulli采样操作本身也是不可微的，因此还需要做一些操作。此时外层优化dataset的过程中，Loss表示为<span class="math display">\[\Phi(S) = \mathbb{E}_{p(M|S)}L(\theta^*(M)), s.t.\ \ \theta^*(M) =\underset{\theta}{argmin}\ \hat{L}(\theta;M)\tag{7}\]</span> 从而梯度可以表示为 <span class="math display">\[\begin{flalign}\nabla_{S}\Phi(S) &amp;= \mathbb{E}_{p(M|S)}L(\theta^*(M))\\&amp;= \nabla_{S} \int L(\theta^*(M))p(M|S)dM\\&amp;= \int L(\theta^*(M)) \frac{\nabla_{S}p(M|S)}{p(M|S)}p(M|S)dM\\&amp;= \int L(\theta^*(M)) \nabla_{S}\ln p(M|S)\ p(M|S)dM\\&amp;= \mathbb{E}_{p(M|S)}L(\theta^*(M))\nabla_{S}\ln p(M|S)\tag{8}\end{flalign}\]</span>通过策略梯度，我们现在可以直接估计出Loss对参数S的梯度，并且这一操作只需要forward计算出<spanclass="math inline">\(L(\theta^*(M))\)</span>，以及一个非常好算的<spanclass="math inline">\(\nabla_{S}\ln p(M|S)\)</span>，这一点只需要对<spanclass="math inline">\((4)\)</span>式做一些变形即可。</p><p>最终参数<span class="math inline">\(S\)</span>的更新形式为 <spanclass="math display">\[S \leftarrow Pc(S - \eta L(\theta^*(M))\nabla_{S}\ln p(M|S))\tag{9}\]</span> 这里<spanclass="math inline">\(Pc(\cdot)\)</span>操作就是为了将<spanclass="math inline">\(S\)</span>投影到合法空间内</p><p>从而，同样是对交互信息进行重参数化建模，同样是有不可微的采样操作以及对应的补救措施，但是本文相对于[1]，实现了一次forward就可以计算梯度，时间上会有巨大的优势，这一点在下图中会更加直观<img src="https://s2.loli.net/2025/09/14/67HCKwFZsNzIOVB.png"alt="|400" />此外，为了进一步减少计算成本，内部推荐模型优化的时候，只进行了一步更新，然后就进行梯度对齐。</p><blockquote><p>"The intuition behind is that the loss decreases after first stepoptimization of the inner model training is strong enough to providecomprehensive information to guide the outer data update"</p></blockquote><p>从下图的结果来看，压缩前先增强数据集这一步的质量收益是很大的，并且one-stepupdate以及REINFORCE极大压缩了计算成本。 <imgsrc="https://s2.loli.net/2025/09/14/enty5mEAu16ZarX.png" /></p><blockquote><p><strong>reducing the dataset size by 75% and approximating 98% of theoriginal performance on Dianping and about 90% on otherdatasets</strong><br /><strong>Besides, our framework is significantly faster than theprevalent gradient matching solver (e.g., 8× in dataset Ciao forupdating the data for 100 epochs)</strong></p></blockquote><p>总结一下，压缩前先增强数据集，显式表达user的隐藏兴趣，提升数据集质量。REINFORCE实现前向传播即可估计外层优化的梯度，同时内层优化使用one-stepupdate，压缩计算成本。</p><h2 id="reference">Reference</h2><p>[1] Sachdeva, N., Dhaliwal, M.P., Wu, C., &amp; McAuley, J. (2022).Infinite Recommendation Networks: A Data-Centric Approach. In NeurIPS,22.</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KD</tag>
      
      <tag>Dataset_Condensation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BOND: Aligning LLMs with Best-of-N distillation</title>
    <link href="/posts/bb161de0/"/>
    <url>/posts/bb161de0/</url>
    
    <content type="html"><![CDATA[<h2 id="main">Main</h2><p>Best-of-N是一个很好的推理时策略，但是需要进行N次推理，成本有点大，作者希望进行一次推理就能达到与其一致的生成效果。作者的想法是，抽象出BoN的策略<spanclass="math inline">\(\pi_{BoN}\)</span>，然后让模型策略<spanclass="math inline">\(\pi\)</span>与<spanclass="math inline">\(\pi_{BoN}\)</span>进行对齐。这其实也可以看成是一种蒸馏。</p><p><span class="math inline">\(\pi_{BoN}\)</span>显式建模出来的结果是<span class="math display">\[\pi_{BoN}(y) = \pi_{ref}(y) \times p_{\leq}(y)^{N-1} \times\sum_{i=1}^{N} \left[ \frac{p_{&lt;}(y)}{p_{\leq}(y)}\right]^{i-1}\tag{1}\]</span> 具体证明参考论文Appendix A.。其中<spanclass="math inline">\(\pi_{ref}\)</span>是原始策略，<spanclass="math inline">\(p_{\leq}(y) = \mathbb{P}_{y&#39; \sim\pi_{ref}}[r(y&#39;)\leq r(y)]\)</span>代表依据<spanclass="math inline">\(\pi_{ref}\)</span>生成的token <spanclass="math inline">\(y&#39;\)</span>，依照奖励模型<spanclass="math inline">\(r\)</span>，不优于<spanclass="math inline">\(y\)</span>的概率，<spanclass="math inline">\(p_{&lt;}(y)\)</span>也是同理。</p><p>作者还提供了BoN与RLHF的关系。RLHF的目标一般是 <spanclass="math display">\[\pi_{RLHF} = argmax_{\pi} \mathbb{E}_{\pi}[r(y)] - \betaD(\pi||\pi_{ref})\tag{2}\]</span>一方面希望尽可能获得更多的奖励，同时要求学习到的策略与原始策略不要偏离太远。根据上式可以得到<spanclass="math inline">\(\pi_{RLHF}\)</span>的显式解，简单表示为 <spanclass="math display">\[\pi_{RLHF}(y) \propto \pi_{ref}(y)\exp\left( \frac{1}{\beta}r(y)\right)\tag{3}\]</span> 证明可以参考[1] (Appendix A)。将<spanclass="math inline">\((1)\)</span>与<spanclass="math inline">\((3)\)</span>的形式进行对比，实际上就可以得到<spanclass="math inline">\(\pi_{BoN}\)</span>下的奖励函数 <spanclass="math display">\[r_{BoN}(y) = \log p_{\leq}(y) + \frac{1}{N-1} \log \sum_{i=1}^{N} \left[\frac{p_{&lt;}(y)}{p_{\leq}(y)}\right]^{i-1}\tag{4}\]</span> 这里<span class="math inline">\(\frac{1}{N-1}\)</span>是<spanclass="math inline">\(p_{\leq}(y)^{N-1}\)</span>带来的。同时不难注意到此时RLHF中关于KL项的系数<spanclass="math inline">\(\beta =N-1\)</span>，这为理解BoN提供了RLHF的视角。即BoN中的采样次数<spanclass="math inline">\(N\)</span>，代表了RLHF中KL项的约束强度。N越大，<spanclass="math inline">\(\beta\)</span>越大，越倾向于在RLHF中进行KL对齐。</p><p><img src="https://s2.loli.net/2025/08/18/uG4ZP8qNzsSTIMU.png" /></p><p>同时，<spanclass="math inline">\(r_{BoN}\)</span>中每一项都是log的形式，因此其对于较高值并不会有明显偏大的奖励，但对较小值会有很大的惩罚，相比起鼓励goodcase，BoN其实更加侧重于避免bad case。此外，不管是<spanclass="math inline">\(p_{\leq}(y)\)</span>还是<spanclass="math inline">\(p_{&lt;}(y)\)</span>，提供的都是相对大小，或者说rank信息，因此其对reward会更加鲁棒。这段分析还是很有意思的。</p><p>不管怎么样，根据<spanclass="math inline">\((1)\)</span>式，接下来可以以<spanclass="math inline">\(\pi_{BoN}\)</span>作为学习目标，尝试得到BoN的生成效果。这里涉及三个问题</p><ul><li><p>如何计算<span class="math inline">\(p_{&lt;},p_{\leq}\)</span></p></li><li><p>如何对齐两个策略，即<spanclass="math inline">\((2)\)</span>式中<spanclass="math inline">\(D\)</span>的选择</p></li><li><p>N的选择</p></li></ul><p>对于第一点，作者选择直接蒙特卡洛采样进行估计，表示为 <spanclass="math display">\[\hat{p}_{\leq}(y) = \frac{1}{k}\sum_{i=1}^{k} [r(y_{i})\leq r(y)]\tag{5}\]</span>对于第二点，KL和RKL各有优劣，作者选择将两者进行加权结合，也称为Jeffreysdivergence。这一选择与之前的认知[2]相符</p><p>最后，关于<span class="math inline">\(N\)</span>的选择，其影响如下<img src="https://s2.loli.net/2025/08/18/bYu79x45aIMvHSw.png" />一个大的N，可以带来好的效果，但是可能带来更大误差，以及成本大。作者选择用一种迭代的方式来近似一个大的N的效果。<img src="https://s2.loli.net/2025/08/18/CpZjzf1Eb9cYkO6.png" />基于的事实是，在一次BoN优化之后，再进行一次BoN优化，相当于做了一个Bo<spanclass="math inline">\(N^2\)</span>的优化。因此最后实现时，每次只需要取<spanclass="math inline">\(N=2\)</span>，然后多次迭代来更新策略<spanclass="math inline">\(\pi\)</span></p><p>非常优雅的一篇文章。</p><h2 id="reference">Reference</h2><p>[1] Rafailov, R., Sharma, A., Mitchell, E., Ermon, S., Manning, C.D.,&amp; Finn, C. (2023). Direct Preference Optimization: Your LanguageModel is Secretly a Reward Model. </p><p>[2] <a href="https://sophilex.top/posts/418a878e/slide.pdf">DifferentDesigns For LLM KD Loss</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>KD</tag>
      
      <tag>RLHF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Evaluating Position Bias in Large Language Model Recommendations</title>
    <link href="/posts/871e7e59/"/>
    <url>/posts/871e7e59/</url>
    
    <content type="html"><![CDATA[<p>指出LLMRec的时候，模型给出的推荐结果可能会受到item输入顺序的影响。输入的prompt格式如下<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">Based <span class="hljs-keyword">on</span> the user’s preferences, can you rank the following items, item1, item2,<span class="hljs-params">...</span>?<br></code></pre></td></tr></table></figure>那么item列表打乱之后，得到的推荐序列结果也可能会与原本有很大的差异。为了衡量这种现象的程度，作者设计了一个指标用于计算两个序列的相似性 <spanclass="math display">\[\tau = \frac{ n_{c} -n_{d} }{\frac{1}{2}n(n-1)}\]</span> 其中<spanclass="math inline">\(n\)</span>是item序列长度，也是最终推荐列表的长度。<spanclass="math inline">\(n_{c}\)</span> 代表pairs ordered the same way inboth rankings，那么<span class="math inline">\(n_{d}\)</span>就代表pairsordered differently in two rankings。那么这个<spanclass="math inline">\(\tau\)</span>越大，就代表两个序列越相似，这么设计的合理性还是很直观的。为了衡量模型受input positionbias的影响程度，可以计算其在原始item序列<spanclass="math inline">\(K\)</span>以及reversed <spanclass="math inline">\(K\)</span>下推荐序列之间的<spanclass="math inline">\(\tau\)</span>(Positional Consistency(<strong>PC</strong>))，也可以计算其在<spanclass="math inline">\(K\)</span>的不同shuffle下推荐结果的两两平均<spanclass="math inline">\(\tau\)</span>(Output Similarity(<strong>Sim</strong>))</p><p>接下来先看看作者是如何尝试降低input position bias对模型的影响的 <imgsrc="https://s2.loli.net/2025/08/11/aDJGYEwPjh9uFxA.png"alt="600" /></p><p>设计非常直观，每次推荐时只取出推荐序列的top1，然后将剩下的item重新给llm进行推荐任务，最后将n-1次推荐结果合在一起得到最终推荐结果。如果一次性给n个item排序太难的话，就把任务进行拆解。这里每次只取出top1，记为RISE@1</p><figure><img src="https://s2.loli.net/2025/08/11/1v9euDLQ6WYsZoP.png"alt="600" /><figcaption aria-hidden="true">600</figcaption></figure><p>这里<span class="math inline">\(K\)</span>代表序列长度，PositionalConsistency (<strong>PC</strong>)，Output Similarity(<strong>Sim</strong>)的含义如前所述。首先可以看到RISE@1在缓解inputposition bias上确实是有帮助的，只是其在Amazon Books上的推荐效果(Recall,NDCG)反而落后挺多，说服力不是很足。</p><p>总之，本文提出模型在推荐任务中得到的结果会受到input positionbias的影响，并指出对推荐任务进行拆解有助于缓解该现象。但是没有尝试解释这一现象的内在原因，以及其具体是如何影响推荐性能的。这个bias本身的描述也不甚清晰，推荐结果中两个item之间的相对顺序的改变，是只受到它们在input中相对顺序的影响吗，还是与其它item也有关？不过现象本身还是挺有意思的。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DATASET DISTILLATION VIA KNOWLEDGE DISTILLATION: TOWARDS EFFICIENT SELF-SUPERVISED PRETRAINING OF DEEP NETWORKS</title>
    <link href="/posts/16b1e492/"/>
    <url>/posts/16b1e492/</url>
    
    <content type="html"><![CDATA[<p>尝试在SSL问题中使用datadistillation，以往的方法主要针对SL，并不能直接迁移到SSL问题中。</p><p>SSL问题一般需要对data训一个encoder <spanclass="math inline">\(f\)</span>，其loss定义为 <spanclass="math display">\[L_{BT} = \sum_{i=1}^{d} (1-F_{ii})^2 + \lambda \sum_{i=1}^{d}\sum_{j\neq i} F_{ij}^2\tag{1}\]</span> 其中 <span class="math display">\[F_{ij} = \mathbb{E}_{x \in B} \mathbb{E}_{x_{1},x_{2}\in A(x)}[f_{i}(x_{1})f_{j}(x_{2})]\tag{2}\]</span> 代表对于batch <spanclass="math inline">\(B\)</span>中数据<spanclass="math inline">\(x\)</span>，其不同视图<spanclass="math inline">\(x_{1},x_{2}\)</span>在第<spanclass="math inline">\(i,j\)</span>个特征的乘积，<spanclass="math inline">\(d\)</span>是embedding size 整个<spanclass="math inline">\((1)\)</span>式就代表，希望同一样本的不同视图在相同特征上尽可能一直，在不同特征上尽量不相关从而，利用encoder <spanclass="math inline">\(f\)</span>，就可以在dataset <spanclass="math inline">\(D\)</span>上，训练一个分类器<spanclass="math inline">\(g_{D}(f)\)</span>用于下游任务。</p><p>对于dataset distillation，我们需要生成一个比原始dataset<spanclass="math inline">\(D_{real}\)</span>小得多的<spanclass="math inline">\(D_{syn}\)</span>，同时满足在<spanclass="math inline">\(D_{syn}\)</span>上训练得到的encoder <spanclass="math inline">\(f_{\theta_{syn}}\)</span>，与在<spanclass="math inline">\(D_{real}\)</span>上得到的<spanclass="math inline">\(f_{\theta_{real}}\)</span>应当尽量接近，这可以表述为<span class="math display">\[D_{syn}^* = argmin_{D_{syn}} \mathbb{E}_{x \sim D_{real}}D(f_{\theta_{syn}}(x), f_{\theta_{real}}(x))\tag{3}\]</span> 其中<span class="math inline">\(D\)</span>用于衡量两者距离</p><p>SL中常用MATCHING TRAINING TRAJECTORIES来进行datasetdistillation，具体来说，就是希望在两个dataset上训练的<spanclass="math inline">\(f\)</span>，其参数优化轨迹是类似的，loss定义为<span class="math display">\[L_{DD}(D_{syn}) = \frac{||\hat{\theta}_{t+N} -\theta^*_{t+M}||^2}{||\theta^*_{t} - \theta^*_{t+M}||^2}\tag{4}\]</span> 其中<span class="math inline">\(\theta^*\)</span>是在<spanclass="math inline">\(D_{real}\)</span>上训练的参数，<spanclass="math inline">\(\hat{\theta}\)</span>是在<spanclass="math inline">\(D_{syn}\)</span>上训练的参数，上式分子最小化N步之后与在原本数据集上M步之后的差距，分母消除专家轨迹本身的尺度影响注意到由不同的数据出发，训练得到的参数优化轨迹是会有一定的偏差的，作者证明在SSL下loss受batch内数据的影响很大，方差很大，而每一个小batch的高方差，会导致参数训练轨迹的累计高方差。轨迹方差大，那么收敛就会慢，从而训练轨迹也会变长，恶性循环。<img src="https://s2.loli.net/2025/08/11/J6cH8UbSWAwgMRr.png" /></p><p>相比之下，SL的方差较小，那么轨迹长度也会小（收敛快），是利于参数优化轨迹的拟合的。因此作者尝试找到一种方式，将原本在SSL任务上训练得到的f，转化为用SL任务训练得到。</p><p>作者用KD来非常巧妙地实现了这种转化。具体来说，先在<spanclass="math inline">\(D_{real}\)</span>上无监督训练一个teacher encoder<spanclass="math inline">\(f_{\theta_{T}}\)</span>，然后将SL任务定义为：在dataset上训练一个student<span class="math inline">\(f&#39;\)</span>，其目标就是拟合<spanclass="math inline">\(f_{\theta_{T}}\)</span>，此时任务有了groundtruth，就已经是一个SL任务了，从而实现SSL向SL的转化。那么按照轨迹匹配的目标，我们先在<spanclass="math inline">\(D_{real}\)</span>上训student，<spanclass="math inline">\(f_{\theta^*}\)</span>，其Loss自然表示为 <spanclass="math display">\[\mathbb{E}_{x_{i}\in D_{real}}L_{MSE}(f_{\theta^*}(x_{i}),f_{\theta^T}(x_{i}))\tag{5}\]</span>其参数优化路径就是前文提及的专家轨迹了。之后我们再在初始化好的<spanclass="math inline">\(D_{syn}\)</span>上训<spanclass="math inline">\(f_{\hat{\theta}}\)</span>，其Loss的设计，类似<spanclass="math inline">\((5)\)</span>，表示为 <span class="math display">\[\mathbb{E}_{x_{i}\in D_{real}}L_{MSE}(f_{\hat{\theta}}(x_{i}),f_{\theta^T}(x_{i}))\tag{6}\]</span> 轨迹匹配时，首先选一个epoch <spanclass="math inline">\(t\)</span>，并令<spanclass="math inline">\(\hat{\theta}_{t} =\theta^*_{t}\)</span>，然后从第<spanclass="math inline">\(t\)</span>步之后，利用<spanclass="math inline">\((5),(6)\)</span>，分别对在<spanclass="math inline">\(D_{real}\)</span>和<spanclass="math inline">\(D_{syn}\)</span>上训练的<spanclass="math inline">\(f_{\theta^*},f_{\hat{\theta}}\)</span>进行参数更新，并依据<spanclass="math inline">\((4)\)</span>式得到两者轨迹匹配的Loss <spanclass="math inline">\(L_{DD}\)</span>，最终用<spanclass="math inline">\(L_{DD}\)</span>更新<spanclass="math inline">\(D_{syn}\)</span>即可。</p><p>实际实现的时候还有一些细节，比如<spanclass="math inline">\(f_{\theta^*}\)</span>的训练，是同时训了K个，之后轨迹匹配时，随机选一个expert的训练轨迹进行匹配，用以减少随机影响。整体流程如下<img src="https://s2.loli.net/2025/08/11/iStqXHFWE9R5wOg.png"alt="600" /></p><p>总结下来，作者利用KD，巧妙地将对encoder的训练任务范式由SSL转化为SL，从而减轻了轨迹匹配中的方差的影响，进而可以将SLdataset distillation中轨迹匹配方法自然地迁移到SSL中，非常巧妙。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>KD</tag>
      
      <tag>Pruning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Distilling the Knowledge in Data Pruning</title>
    <link href="/posts/9e785f75/"/>
    <url>/posts/9e785f75/</url>
    
    <content type="html"><![CDATA[<p>原本对训练dataset进行pruning之后直接进行模型训练就结束了，本文提出，原本的基于全dataset训练的模型可以作为Teacher，对在pruneddataset上训练的Student进行蒸馏，这会取得更好的效果。 首先介绍一下DatasetPruning，这其实与WeightPruning是类似的，都是对基本组成元素定义一个重要性，然后依据重要性进行pruning。同时定义剪枝比例<spanclass="math inline">\(f =\frac{N_{f}}{N}\)</span>代表保留的数据比例，其中<spanclass="math inline">\(N,N_{f}\)</span>分别代表原始数据集大小，剪枝后的数据集大小整体Loss表示为 <span class="math display">\[L_{\theta} = (1-\alpha) L_{cls}(\theta) + \alpha L_{KD}(\theta)\]</span> 其中前者代表学生在pruned dataset上训练的CELoss，后者代表教师与学生的KD Loss。这里<spanclass="math inline">\(\alpha\)</span>的设计也有点意思。事实上随着剪枝比例<spanclass="math inline">\(f\)</span>的降低，留下的都是一些学习难度较大的样本，其中的噪声较多，此时在全dataset上训练过的教师就能提供很好的指导作用[1]。因此<spanclass="math inline">\(f\)</span>降低时，KD所占的权重应当扩大，即<spanclass="math inline">\(\alpha\)</span>与<spanclass="math inline">\(f\)</span>应当是成反比的。 至于在构造pruneddata的时候，具体的pruning策略，作者直接选择了随机pruning。这是因为作者发现，在加入KD之后，与复杂的修剪方法相比，在使用简单随机修剪的同时结合KD 可以达到相当或更高的准确性。</p><figure><img src="https://s2.loli.net/2025/08/11/ZbOSxzMqK9HksfY.png"alt="600" /><figcaption aria-hidden="true">600</figcaption></figure><p>这一点还是很有意思的。</p><p>训练时还有一个有意思的现象 <imgsrc="https://s2.loli.net/2025/08/11/tVDBiw6XhOGjmQK.png" alt="400" />当剪枝比例<spanclass="math inline">\(f\)</span>比较低的时候，面对同一个学生，用规模较低的教师对其进行蒸馏反而有更好的效果，并且这一现象关于蒸馏温度是鲁棒的。这其实有点反直觉，作者也没有给出很好的解释。不过这一现象在<spanclass="math inline">\(f\)</span>较高的时候就不存在了。</p><p>总体来说，引入KD之后，对dataset的pruning策略可以变得异常简单（完全随机pruning）而不会带来显著的模型性能下降（甚至还有上升）。不过其实也可以直接从KD的视角来观察这一训练范式：<strong>它其实就是在教师训练好之后，对教师训练用的dataset进行pruning，然后直接做KD。</strong>从这一视角来看，做datasetpruning可能就显得有些多余了，不如直接做KD？</p><h2 id="reference">Reference</h2><p>[1] Das, R., &amp; Sanghavi, S. (2023). UnderstandingSelf-Distillation in the Presence of Label Noise.</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>KD</tag>
      
      <tag>Compression</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DA-KD: Difficulty-Aware Knowledge Distillation for  Efficient Large Language Models</title>
    <link href="/posts/e27147d6/"/>
    <url>/posts/e27147d6/</url>
    
    <content type="html"><![CDATA[<p>提出在训练的时候，根据模型学习效果动态筛选数据集，倾向于选出学习效果较差的样本拿来训练。学习效果的依据为<span class="math display">\[DDS(x) = \frac{L_{q_{\theta}}(x)}{L_{p}(x)}\]</span> 其中<span class="math inline">\(L_{f}(x)\)</span>代表样本<spanclass="math inline">\(x\)</span>在模型<spanclass="math inline">\(f\)</span>预测结果与ground truth下的ce loss</p><p><img src="https://s2.loli.net/2025/08/04/zGiofbaP3dRp2MA.png" /></p><p>至于实际筛选策略，每次会根据样本的<spanclass="math inline">\(DDS\)</span>值降序排序，然后按比重分成高<spanclass="math inline">\(DDS\)</span>部分和低<spanclass="math inline">\(DDS\)</span>部分，再分别从中随机采样一定数量样本，组合成新的训练数据集。</p><p>另外对loss也做了修改，参考SKL[1]，得到 <span class="math display">\[D_{BDL}(p,q_{\theta}) = D_{KL}(((1-\lambda)p+\lambda q_{\theta})||(\lambda p+(1-\lambda)q_{\theta}))\]</span> 实际上也就是把SKL和SRKL糅在了一起，此时相对参数<spanclass="math inline">\(\lambda\)</span>会有一个比较稳定的上下界，梯度相对比较稳定。记<spanclass="math inline">\(P_{m},Q_{m}\)</span>分别代表<spanclass="math inline">\((1-\lambda)p+\lambda q_{\theta}, \lambdap+(1-\lambda)q_{\theta}\)</span>，有 <imgsrc="https://s2.loli.net/2025/08/04/ZcaN6Fo3zkvDmjG.png" /></p><p>而 <span class="math display">\[\frac{P_{m}}{Q_{m}} = \frac{(1-\lambda)p+\lambda q_{\theta}}{\lambdap+(1-\lambda)q_{\theta}}\]</span> 当<span class="math inline">\(p \ggq_{\theta}\)</span>时，<span class="math inline">\(\frac{P_{m}}{Q_{m}}\rightarrow \frac{1-\lambda}{\lambda}\)</span>，当<spanclass="math inline">\(p \ll q_{\theta}\)</span>时，<spanclass="math inline">\(\frac{P_{m}}{Q_{m}} \rightarrow\frac{\lambda}{\lambda}\)</span> 从而<spanclass="math inline">\(\nabla_{\theta}D_{BDL}(p,q_{\theta})\)</span>上下界相对稳定</p><h2 id="reference">Reference</h2><p>[1] Ko, J., Kim, S., Chen, T., &amp; Yun, S. DistiLLM: TowardsStreamlined Distillation for Large Language Models. In ICML, 24</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>KD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Boosting Parameter Efficiency in LLM-Based Recommendation through Sophisticated Pruning</title>
    <link href="/posts/bdceb487/"/>
    <url>/posts/bdceb487/</url>
    
    <content type="html"><![CDATA[<p>本文尝试通过参数pruning来减小模型规模。核心认识就是通用模型用在推荐任务下，其关于数学或者代码的能力并不是必须的，这部分能力对应的参数就是冗余的，是应当去除的。而原本针对通用llm的pruning方式，目的是保留其各方面的通用能力，因此在推荐任务下并不会有很好的效果。<img src="https://s2.loli.net/2025/08/04/wsoyZ5QMm7dgukD.png" />比如WANDA[1]与随机pruning相比，在推荐任务下的性能几乎差不多，甚至有所不足。这意味着需要在推荐场景下单独设计pruning策略。## Step1 减小模型宽度 包括减小embeding size，减小attention头的个数</p><p>对每一个attentionhead求一个重要性，定义为抑制其前后模型输出的KLD，记为<spanclass="math inline">\(Imp(O_{i}^l)\)</span>，代表第l层第i个attentionhead的重要性。为了考虑去除前面的attentionhead之后，对后面层的影响，将其更新为 <span class="math display">\[Imp(O_{i}^l) = \alpha Imp(O_{i}^l) + (1-\alpha) Imp(O_{i}^{l+1})\]</span> 显然这是递归定义的，就考虑到了对之后每一层的影响之后根据Imp对attention head进行修剪。</p><p>对于embeding，定义每一个维度<spanclass="math inline">\(d\)</span>的重要性为<spanclass="math inline">\(|E_{d}\bigodot\nabla_{E_{d}}|\)</span>，即其对应嵌入权重与梯度的乘积的abs，然后按照重要性修剪。</p><h2 id="step2-修剪mlp">Step2 修剪MLP</h2><p>实验发现MLP层的activation分布明显长尾，这意味着少部分维度提供了大部分信息，从而存在冗余维度。考虑每一个序列最后一个token对应的activation（这应该是只希望考虑任务强相关的信息，毕竟最后一个token之后就是预测结果了）定义每一个维度的重要性为其整个batch中其对应activation大于给定阈值<spanclass="math inline">\(\tau\)</span>的概率，之后保留topK维度</p><h2 id="step3-层级修剪">Step3 层级修剪</h2><p>对于每一层，重要性定义为去除其前后的PPL变化，变化越大，代表其越重要。然后依据此修剪冗余层</p><h2 id="性能恢复">性能恢复</h2><p>以修剪前的模型作为teacher，与修建后的模型做KD，加上student与groundtruth的对齐</p><h2 id="总结">总结</h2><p>对于每一个组件，主要还是依据其对具体任务的影响来评估其重要性，然后依据重要性修剪。当然最终的效果还是很好的，在修剪了95%的参数（非embedding）之后还能还原88%的性能。</p><h2 id="reference">Reference</h2><p>[1] Sun, M., Liu, Z., Bair, A., &amp; Kolter, J.Z. A Simple andEffective Pruning Approach for Large Language Models. In ICLR, 24</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>Pruning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C2KD: Cross-layer and Cross-head Knowledge Distillation for  Small Language Model-based Recommendations</title>
    <link href="/posts/898fd981/"/>
    <url>/posts/898fd981/</url>
    
    <content type="html"><![CDATA[<p>目前llm蒸馏主要有两个方向：prediction蒸馏与feature蒸馏，这其实与vanilaKD是一样的对于前者，由于教师与学生是在不同数据集上训练的，其输出头包含的信息实际上是不一样的，如果直接对齐两者的预测结果的话，并不能保证分布对齐。对于后者，教师的层实际上有某些是冗余的，在推荐场景下，有些层的贡献可能就会较小，那么层的选择也会是一个问题。</p><p>下图给出了到不同层为止的推荐能力，与SASRec进行对比。这里评估的方式是：到对应层停止推理，然后用可学习的预测头给出最终结果。背景是序列推荐。![[Pasted image 20250804131358.png|500]]</p><p>可以看到，不管是较大(8B)的教师还是较小的学生(1B)，其推荐能力普遍在十几层之后才超过SASRec，这可能是因为前面的层主要捕获低级文本线索，缺乏顺序推荐所需的上下文推理。另外注意到教师的表现最优的层并非最后一层，并且在不同数据集上，最优层对应的位置也在不断变化，这意味着，feature蒸馏的时候，中间层的选择应当是要精心设计的。</p><p>具体选择的时候，选择教师具体层数时，首先得到教师参数<spanclass="math inline">\(H^l\)</span>经过mlp变换后的结果<spanclass="math inline">\(g^l(H_{t}^l;W^l)\)</span>，当然这个<spanclass="math inline">\(W^l\)</span>是根据变换后结果在具体任务上学习的。之后通过如下式子得到最优层数<span class="math display">\[l^* = argmax_{l\in \{1, 2, \dots L_{T}\}} \frac{&lt;H_{s}^n,g^l(H_{t}^l;W^l)&gt;}{||H_{s}^n||\  ||g^l(H_{t}^l;W^l)||}\]</span>即依照每一层变换后的教师特征与学生的相似度，取最相似的一层。之后直接MSE对齐即可，记为<spanclass="math inline">\(L_{feat}\)</span></p><p>对于另外一点，即教师和学生预测头分布不同的问题，作者选择对学生的最后一层的特征做一个变换，然后与教师<strong>使用同一个预测头</strong>。即对<spanclass="math inline">\(H_{s}^{L_{S}}\)</span>乘上一个可学习的矩阵<spanclass="math inline">\(W_{proj}\)</span>，进行维度对齐以及空间变换。为了避免特征投影中的信息丢失，对<spanclass="math inline">\(W_{proj}\)</span>加上正交性限制 <spanclass="math display">\[L_{orth} = ||W_{proj}^TW_{proj} - I|| + ||W_{proj}W_{proj}^T - I||\]</span>这一点其实与[1]的想法是很类似的，只是[1]不仅做了学生feature向教师的转换，还做了教师feature向学生的转换，当然省略了正交性限制。不管怎么样，之后对教师与学生在同一个预测头下的预测结果进行对齐即可，记为<spanclass="math inline">\(L_{logit}\)</span></p><p>那么最终Loss就表示为 <span class="math display">\[Loss = Loss_{feat} + L_{task} + L_{orth} + L_{logit}\]</span></p><h2 id="reference">Reference</h2><p>[1] Zhang, S., Zhang, X., Sun, Z., Chen, Y., &amp; Xu, J. Dual-SpaceKnowledge Distillation for Large Language Models. In EMNLP, 24</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>KD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SVD Decompositon in LLM Compression</title>
    <link href="/posts/af06fe9c/"/>
    <url>/posts/af06fe9c/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>slides</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>Compression</tag>
      
      <tag>SVD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DipSVD: Dual-importance Protected SVD for Efficient LLM Compression</title>
    <link href="/posts/dd35f5de/"/>
    <url>/posts/dd35f5de/</url>
    
    <content type="html"><![CDATA[<p>在<ahref="https://sophilex.top/posts/589e9b78/">SVD-LLM</a>的基础上提出改进。LLMmatrix decomposition 的目标函数，可以写成 <span class="math display">\[W_{k}^* = \mathop{\text{argmin}}\limits_{W_{k}} ||W_{k}X -WX||_{F}^2\tag{1}\]</span> 每一层的线性层参数<spanclass="math inline">\(W\)</span>，以及其输入<spanclass="math inline">\(X\)</span>，参数的最优近似结果为<spanclass="math inline">\(W_{k}^*\)</span> 引入<spanclass="math inline">\(X\)</span>是为了对齐两种参数下的输出结果，但是这对<spanclass="math inline">\(X\)</span>的各个通道都是同一权重。作者提出引入<span class="math display">\[\alpha_{j} = \sqrt{ x_{j}^T(XX^T)x_{j} }\tag{2}\]</span> 这一指标来衡量输入中不同通道的重要性。</p><p>实际上这等价于<spanclass="math inline">\(||x_{j}^TX||\)</span>，它代表了<spanclass="math inline">\(x_{j}\)</span>与各个通道的对齐程度，从而可以反映其重要性。进一步定义重要性矩阵<spanclass="math inline">\(D\)</span>，表示为 <span class="math display">\[D_{jj} = \left\{\begin{matrix}a &amp; \text{if } \alpha_{j} \text{ is among the top p\%values},a&gt;1\\1 &amp; otherwise\end{matrix}\right.\tag{3}\]</span> 那么目标<span class="math inline">\((1)\)</span>可以改写为<span class="math display">\[W_{k}^* = \mathop{\text{argmin}}\limits_{W_{k}} ||W_{k}\tilde{X} -W\tilde{X}||_{F}^2, \ \ \tilde{X} = XD\tag{4}\]</span> 通过系数<span class="math inline">\(a\)</span>对<spanclass="math inline">\(X\)</span>中比较重要的通道进行适当扩大，提高其在之后分解过程中的重要性。</p><p>这是从每一层具体矩阵的分解角度出发，另外还可以考虑每一层的压缩率<spanclass="math inline">\(k_{i}\)</span>。压缩率会影响每一层SVD分解之后保留的奇异值的数量，但是之前的工作往往是对每一层采用同一个压缩率，或者简单使用二分。这篇文章尝试提出一种自适应的策略。</p><p>如果记模型的总层数为<spanclass="math inline">\(L\)</span>的话，期望的总压缩率为<spanclass="math inline">\(k\)</span>的话，目标可以表述如下 <spanclass="math display">\[\begin{flalign}&amp;\mathop{max}\limits_{k_{1},k_{2},\dots k_{L}}D(f_{\text{orig}}(x),f_{\text{comp}}(x))\\&amp;s.t.\ \frac{1}{L}\sum_{i=1}^{L} k_{l} = k\end{flalign}\tag{5}\]</span> 其中<span class="math inline">\(D(\cdot,\cdot)\)</span>代表衡量两个分布相似程度的手段，作者选择了cossimilarity。接下来看看每一层的压缩率<spanclass="math inline">\(k_{i}\)</span>可以怎么设置。</p><p>期望衡量每一层的<strong>重要程度</strong>，以及其<strong>可压缩程度</strong>。对于前者，作者引入Fisher Sensitivity进行描述 <spanclass="math display">\[S_{l} = \sum_{Attention} \frac{||\nabla_{\theta}L||_{F}}{||\theta||_{F}}+ \sum_{MLP} \frac{||\nabla_{\theta}L||_{F}}{||\theta||_{F}}\tag{6}\]</span> <spanclass="math inline">\((6)\)</span>式中，对于每一层的Attention和MLP架构，<spanclass="math inline">\(||\nabla_{\theta}L||_{F}\)</span>衡量了该层参数对Loss的贡献，除以<spanclass="math inline">\(||\theta||_{F}\)</span>则是为了抹去参数规模的影响，从而得到该层的总体重要程度。<spanclass="math inline">\(S_{l}\)</span>越高，该层的重要性越高，从而压缩率应当越高。对于可压缩程度，引入 <span class="math display">\[R_{l} = min\left\{  k| \frac{\sum_{i=1}^{k}\sigma_{i}}{\sum_{i=1}^{r}\sigma_{i}} \geq \text{ threshold}\right\}\tag{7}\]</span></p><p>实际上代表了保留前多少个奇异值得到的信息可以达到预设的阈值threshold，其一般设为<spanclass="math inline">\(0.95\)</span> <spanclass="math inline">\(R_{l}\)</span>越低，代表这一层可压缩程度越高，压缩率应当越低</p><p>那么综合两个指标，可以得到最终指标表示为 <spanclass="math display">\[Q_{l} = S_{l}^{\beta} (1-R_{l})^{1-\beta}\tag{8}\]</span> 其反映了每一层适合的压缩率大小。那么结合目标<spanclass="math inline">\((5)\)</span>，可以得到每一层的具体的参数压缩率为<span class="math display">\[k_{l} = \frac{Q_{l}}{\sum_{i=1}^{L}Q_{i}}Lk\tag{9}\]</span></p><p>简单来说，就是让一些不那么重要，或者空余参数较多的层，来更多地承担压缩任务。下图展示了Vicuna-7B上不同层的对应系数结果，可以看到前几层往往得到较多保留，而之后的层被压缩的较严重。而之前工作往往对每一层采用同一压缩率，显然是不妥的。<img src="https://s2.loli.net/2025/07/06/3owEpIhFUTjP7xa.png" /></p><p>总的来说，在SVD-LLM的基础上，对input <spanclass="math inline">\(X\)</span>进行了增强，同时引入每一层自适应计算压缩率的手段。SVD-LLM的参数微调策略背其省略了，可能也是因为效果有限，毕竟从消融实验也可以看出，主要起作用的还是对<spanclass="math inline">\(XX^T\)</span>进行Cholesky分解带来的奇异值-loss一一对应。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>Matrix_Decomposition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SVD-LLM: TRUNCATION-AWARE SINGULAR VALUE DECOMPOSITION FOR LARGE LANGUAGE MODEL COMPRESSION</title>
    <link href="/posts/589e9b78/"/>
    <url>/posts/589e9b78/</url>
    
    <content type="html"><![CDATA[<p>在近似矩阵参数<spanclass="math inline">\(W\)</span>的背景下，即每一层的输入为<spanclass="math inline">\(X\)</span>，那么目标可以表示为 <spanclass="math display">\[W^* = \mathop{\text{argmin}}\limits_{W&#39;} ||W&#39;X -WX||_{F}^2\tag{1}\]</span> ASVD[[#^a3b6a4|[1]]]的做法是引入与输入<spanclass="math inline">\(X\)</span>相关的可逆矩阵<spanclass="math inline">\(S\)</span>，将<spanclass="math inline">\(WX\)</span>改写为<spanclass="math inline">\((WS)(S^{-1}X)\)</span>，并用SVD对<spanclass="math inline">\(WS\)</span>进行近似。其将<spanclass="math inline">\(S\)</span>取为 <span class="math display">\[S_{ii} = \left( \frac{1}{n} \sum_{j=1}^{n}|X_{ij}| \right)^{\alpha}\tag{2}\]</span> 本文指出目前设计的<spanclass="math inline">\(S\)</span>依然存在问题，贪心地对<spanclass="math inline">\(WS\)</span>的最小奇异值方向进行去除并不能保证<spanclass="math inline">\(Loss = ||W&#39;X -WX||_{F}^2\)</span>最小。本文将<spanclass="math inline">\(S\)</span>设计为<spanclass="math inline">\(XX^T\)</span>的Cholesky decomposition，即满足<span class="math display">\[SS^T = XX^T \tag{3}\]</span> 且<spanclass="math inline">\(S\)</span>是一个下三角矩阵，这里记为<spanclass="math inline">\(S_{Cho}\)</span> 在这种设计下，再对<spanclass="math inline">\(WS_{Cho}\)</span>进行SVD分解，可以做到<spanclass="math inline">\(Loss\)</span> 与删除的奇异值<spanclass="math inline">\(\sigma_{i}\)</span>是一一对应的，从而可以从理论上保证贪心策略的有效性。</p><p>具体来说，其证明了，当<span class="math inline">\(S_{Cho}\)</span>是<span class="math inline">\(XX^T\)</span>的Choleskydecomposition，且对<spanclass="math inline">\(WS_{Cho}\)</span>进行SVD分解并去除第<spanclass="math inline">\(i\)</span>个奇异值对应向量时，有 <spanclass="math display">\[Loss = ||W&#39;X - WX||_{F}^2 = \sigma_{i}^2\tag{4}\]</span> 并且，如果同时去除<spanclass="math inline">\(\sigma_{m+1},\sigma_{m+2},\dots ,\sigma_{r}\)</span>的话，可以得到 <span class="math display">\[Loss = ||W&#39;X - WX||_{F}^2 = \sum_{j=m+1}^{r}\sigma_{i}^2\tag{5}\]</span> 具体证明过程略过。这还是非常神奇且强大的。</p><p>另外其还指出在略去一些参数之后，还应该重新对参数进行微调。记近似之后的结果为<span class="math display">\[WS_{Cho} \approx U_{k} \Sigma_{k} V_{k}^T\tag{6}\]</span> 记 <span class="math display">\[W_{u}&#39; = U_{k} \Sigma_{k}^{1/2}, W_{v}&#39; =\Sigma_{k}^{1/2}V_{k}^TS_{Cho}^{-1}\]</span> 这里把多出来的<spanclass="math inline">\(S_{Cho}^{-1}\)</span>放进来，那么此时<spanclass="math inline">\(W_{u}&#39;W_{v}&#39;\)</span>就是最终的近似参数了。我们应当对<spanclass="math inline">\(W_{u}&#39;\)</span>和<spanclass="math inline">\(W_{V}&#39;\)</span>都进行LoRA微调。 <spanclass="math display">\[W_{u}&#39; \leftarrow W_{u}&#39; + B_{u}A_{u}, \ \ W_{v}&#39; \leftarrowW_{v}&#39; + B_{v}A_{v}\]</span> 但是由于它们来自于<spanclass="math inline">\(WS_{Cho}\)</span>的分解，是相互关联的，两者分开单独微调的话，会有一定影响。因此作者提出分别微调 <imgsrc="https://s2.loli.net/2025/07/07/fH4PjBDV29txrg6.png" /> 先冻结<spanclass="math inline">\(W_{v}&#39;\)</span>，微调<spanclass="math inline">\(W_{u}&#39;\)</span>；再冻结<spanclass="math inline">\(W_{u}&#39;\)</span>，更新<spanclass="math inline">\(W_{V}&#39;\)</span></p><p>从结果上来看，效果还是很惊艳的 <imgsrc="https://s2.loli.net/2025/07/07/C1kMDfWFZJBUahx.png" /></p><p>SVD-LLM(W)代表只使用<spanclass="math inline">\(S_{Cho}\)</span>，不进行分解近似后的微调。</p><h2 id="reference">Reference</h2><p>[1] Yuan, Z., Shang, Y., Song, Y., Wu, Q., Yan, Y., &amp; Sun, G.(2023). ASVD: Activation-aware Singular Value Decomposition forCompressing Large Language Models. ^a3b6a4</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>KD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LANGUAGE MODEL COMPRESSION WITH WEIGHTED  LOW-RANK FACTORIZATION</title>
    <link href="/posts/b977ce3c/"/>
    <url>/posts/b977ce3c/</url>
    
    <content type="html"><![CDATA[<p>指出模型matrix decomposition的时候，依据singularvalues的大小贪心删去对应方向的向量，与模型性能减少的幅度，可能并不是完全正相关的<img src="https://s2.loli.net/2025/07/03/21nKfNoyZSevJlM.png"alt="The truncation and its crossponding performance" /></p><p>可以看到，这里删去最小的一组singularvalues反而导致了比前几组更多的性能下降。这是因为单纯对参数进行SVD分解，并没有考虑到data，task</p><p>我们记模型的SVD分解结果为 <span class="math display">\[W = U\Sigma V\]</span> 可以简记为<span class="math inline">\(A = U\Sigma,B=V\)</span>那么原本的目标可以表示为 <span class="math display">\[\mathop{min}\limits_{A,B}||W-AB||_{2} =\mathop{min}\limits_{A,B}\sum_{i,j}(W_{i,j}-(AB)_{i,j})^2\tag{1}\]</span>本文考虑对每一个参数进行加权，依据为参数与性能的关联性，从而新的目标可以表示为<span class="math display">\[\mathop{min}\limits_{A,B}\sum_{i,j}\hat{I}_{W_{i,j}}(W_{i,j}-(AB)_{i,j})^2\tag{2}\]</span>接下来的问题就是如何能够得到参数与性能之间的关联？可以使用<strong>Fisherinformation</strong>，其定义如下 <span class="math display">\[I_{w} = E\left[ \left( \frac{\partial}{\partial_{w}}\log p(D|w)\right)^2 \right]\approx \frac{1}{|D|}\sum_{i=1}^{D} \left(\frac{\partial}{\partial_{w}}L(d_{i};w) \right)^2 = \hat{I}_{w}\tag{3}\]</span> 其中<spanclass="math inline">\(d_{i}\)</span>代表具体训练数据，<spanclass="math inline">\(L\)</span>就是任务相关的loss。直观来看，这一指标实际反映的就是在参数<spanclass="math inline">\(w\)</span>下，模型期望loss。那么对于那些改变之后对<spanclass="math inline">\(\hat{I}_{w}\)</span>影响较大的参数，就应当是需要重点拟合的参数，相对应的，在<spanclass="math inline">\((2)\)</span>式中，也应该给到更大的权重。</p><p>当然，<spanclass="math inline">\((2)\)</span>式此时还缺乏一个闭式解，因此需要对齐做一个近似：每一行的参数取同一个权重：<span class="math display">\[\hat{I}_{w_{i}} = \sum_{j} \hat{I}w_{i,j}\tag{4}\]</span> 从而<span class="math inline">\((2)\)</span>式可以整理为 <spanclass="math display">\[\mathop{min}\limits_{A,B}||\hat{I}W-\hat{I}AB||_{2}\tag{5}\]</span> 从而我们只需要对<spanclass="math inline">\(\hat{I}W\)</span>进行SVD分解，分解出来的结果作为<spanclass="math inline">\(\hat{I}AB\)</span>即可。</p><p>最后展示一下目前已有的模型压缩技术路线 <imgsrc="https://s2.loli.net/2025/07/03/bpJMwPvcWFok9Ns.png"alt="three paths to create compressed language models" /></p><p>对于LLM，一般是先做预训练，然后针对特定任务微调，最后post-training进行参数压缩，post-training中已有的技术包括Quantization，参数剪枝，以及本文的Factorization。如果有学生模型的加入的话，在双方都预训练之后，可以做一个KD，然后做类似的微调。早先的操作中，学生在KD，微调之后基本就结束了，但是本文的引入可以做到在后面再加一个Factorization，对学生再进一步压缩参数。作者的实验表明这一操作确实是有效的。</p><p>事实上，对于KD，其实学生模型的架构是提前限定好的，但是model每一层具体可以怎么压缩，压缩到什么程度，直接提前设定好是否还是欠妥，事实上应该也很难提前确定好最优解。而进一步向最优解靠近交给MatrixDecomposition来自适应调整，或许是比较好的。这样一来，KD用于知识迁移，MD用于冗余参数移除，两者的功能其实还是相对正交的。因此路线3的合理性也是可以理解的。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>Matrix_Decomposition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ASVD: ACTIVATION-AWARE SINGULAR VALUE DECOMPOSITION FOR COMPRESSING LARGE LANGUAGE  MODELS</title>
    <link href="/posts/38df231f/"/>
    <url>/posts/38df231f/</url>
    
    <content type="html"><![CDATA[<p>ASVD提出使用SVD分解来做到用较少参数近似LLM参数，从而减小模型规模，算一种post-training。这一思想个人感觉与KD算是正交的。前者减小现有模型规模，而后者是在两个模型上转移知识，且学生模型的架构是提前设置好的。首先目标是比较明晰的，我们考虑每一层的线性层参数<spanclass="math inline">\(W\)</span>，以及其输入<spanclass="math inline">\(X\)</span>，参数的最优近似结果<spanclass="math inline">\(W_{k}^*\)</span>应当满足 <spanclass="math display">\[W_{k}^* = \mathop{\text{argmin}}\limits_{W_{k}} ||W_{k}X -WX||_{F}^2\tag{1}\]</span> 其中<span class="math inline">\(k\)</span>代表秩为<spanclass="math inline">\(k\)</span>的近似。 这里我们考虑了每一层的输入<spanclass="math inline">\(X\)</span>，从而<spanclass="math inline">\((1)\)</span>式实际上是在对齐两种参数下的输出空间，而不仅仅是对齐参数。这是因为对模型已有参数进行近似，应当是<code>task-targeted</code>，而这一点在简单对齐参数的情况下可能是难以满足的。事实上[2]对此现象也有所描述,这里不再赘述。</p><p>那么在<spanclass="math inline">\((1)\)</span>式下，我们直接对参数<spanclass="math inline">\(W\)</span>做SVD分解，然后保留前<spanclass="math inline">\(k\)</span>大的奇异值方向，极有可能是不够优的。作者提出引入一个来自参数<spanclass="math inline">\(X\)</span>的<mark style="background: #FF5582A6;">可逆</mark>矩阵<spanclass="math inline">\(S\)</span>，并且将<spanclass="math inline">\(WX\)</span>改写为 <span class="math display">\[W = (WS)(S^{-1}X)\tag{2}\]</span> 那么让<span class="math inline">\(W_{k}\)</span>近似<spanclass="math inline">\(WS\)</span>即可，后半部分只跟输入<spanclass="math inline">\(X\)</span>有关。那么我们按照SVD的套路对WS进行分解，并保留前k大奇异值方向进行近似。具体来说<span class="math display">\[WS=U&#39;\Sigma&#39; V&#39;^T \tag{3}\]</span> 保留前<span class="math inline">\(k\)</span>大奇异值后得到<span class="math display">\[WS \approx U_{k}&#39;\Sigma_{k}&#39; V_{k}&#39;^T = W_{k} \tag{4}\]</span> 事实上也不难看出引入<spanclass="math inline">\(S\)</span>的目的:在分解，近似的过程中加入对当前层输入<spanclass="math inline">\(X\)</span>的考虑，直观上对靠近<spanclass="math inline">\((1)\)</span>式最优解<spanclass="math inline">\(W_{K}^*\)</span>是有帮助的。</p><p>但是如何引入<spanclass="math inline">\(X\)</span>也是有讲究的。ASVD中将<spanclass="math inline">\(S\)</span>设置为一个对角阵 <spanclass="math display">\[S_{ii} = \left( \frac{1}{n} \sum_{j=1}^{n}|X_{ij}| \right)^{\alpha}\tag{5}\]</span> 其没有解释这一设计的具体理由，可能也是试出来的吧</p><p>另外其对模型中不同层对压缩的敏感性也做了探究 <imgsrc="https://s2.loli.net/2025/07/03/FkoDMGUtAdZ4NSb.png"alt="Perplexity across Various Linear Layers and Parameter Ratios" /></p><p>如图，横轴代表不同的压缩比，纵轴代表perplexity用来表示性能。可以看到不同层之间对压缩的敏感性不同，但是都表现出了压缩比越高，性能越差的结果(显然)。</p><p>由此我们应当对不同层采用不同的压缩比，这一点在文中是通过二分实现的，这里不再赘述。</p><h2 id="reference">Reference</h2><p>[1] Yuan, Z., Shang, Y., Song, Y., Wu, Q., Yan, Y., &amp; Sun, G.(2023). ASVD: Activation-aware Singular Value Decomposition forCompressing Large Language Models.  ^132f6c</p><p>[2] Hsu, Y., Hua, T., Chang, S., Lou, Q., Shen, Y., &amp; Jin, H.(2022). Language model compression with weighted low-rankfactorization. In ICLR, 22 ^942a0c</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>Matrix_Decomposition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Training-Inference Mismatch In LLM KD</title>
    <link href="/posts/ef9972ec/"/>
    <url>/posts/ef9972ec/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>slides</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>KD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dual-Space Knowledge Distillation for Large Language Models</title>
    <link href="/posts/8d7eb621/"/>
    <url>/posts/8d7eb621/</url>
    
    <content type="html"><![CDATA[<p>目前llm白盒蒸馏往往是对齐教师学生最后输出的概率分布，本文希望在隐藏状态层面进行对齐。同时目前的llmkd局限于同词汇表的架构之间的蒸馏，对上一个点的改进也有助于解决这个问题。</p><p>考虑隐藏状态<spanclass="math inline">\(h_{1:n}^t\)</span>,其过一个linear层<spanclass="math inline">\(P^{t \rightarrows}\)</span>，映射到学生的隐藏状态空间中，表示为 <spanclass="math display">\[h_{1:n}^{t \rightarrow s} = P^{t \rightarrow s}(h_{1:n}^t;\theta_{P}^{t\rightarrow s}) \in \mathbb{R}^{n\times d}\]</span> 其中<span class="math inline">\(d\)</span>是学生emd size从而教师映射之后得到的概率分布可以表示为 <span class="math display">\[p_{1:n}^{t \rightarrow s} = \text{softmax}(h_{1:n}^{t \rightarrow s}W^s)\]</span> 其中<spanclass="math inline">\(W^s\)</span>就是学生的映射头，此时双方可以共享一个映射头。这里唯一的参数是<spanclass="math inline">\(P^{t \rightarrow s}\)</span>,其训练时通过将<spanclass="math inline">\(p_{1:n}^{t \rightarrow s}\)</span>与groundtruth进行ce loss对齐实现的。当然后面做教师学生KLD对齐的时候，这里的<spanclass="math inline">\(W^s\)</span>并不会做反向传播。类似的，学生的隐藏状态也可以映射到教师空间中，然后通过教师映射头得到概率分布，并与教师进行对齐。最终训练的时候，两个对齐的方向都会使用。</p><p>llmkd中另一个问题是，由于模型输出的概率分布是定义在词汇表中的token上的，如果某个token在词汇表上不存在，那么其出现的概率也是没有定义的，从而在使用KLD对齐教师学生概率分布的时候，不同的词汇表就会导致不对应的token对齐错误。因此目前llm白盒蒸馏仅仅局限于同词汇表的模型之间。尝试通过attention来解决这个问题。每次对齐的时候，考虑学生向教师对齐，则将Q设计为学生相关emd，K设计为教师相关emd，然后设计一个V，即可得到学生映射后的emd，即隐藏状态，然后仿照上文进行概率分布对齐即可。教师向学生对齐的部分也是同理。</p><p>具体来说，对于当前句子在学生中的embeding表示，记为<spanclass="math inline">\(e_{1:n}^s\)</span>，其目标tokens的embeding表示记为<spanclass="math inline">\(e_{2:n+1}^s\)</span>，则 <spanclass="math display">\[Q = P^q([e_{1:n}^s; e_{2:n+1}^s];\theta_{P}^q)\in R^{n\times 2D}\]</span> 其中<span class="math inline">\(D\)</span>是教师emd size <spanclass="math inline">\(K\)</span>设计为 <span class="math display">\[K = [e_{1:m}^t;e_{2:m+1}^t]\in R^{m\times 2D}\]</span> <span class="math inline">\(V\)</span>设计为 <spanclass="math display">\[V = P^v(e_{2:m+1}^t+h_{1:m}^t;\theta_{P}^v)\in R^{m\times d}\]</span> 关键主要在于<spanclass="math inline">\(V\)</span>的设计，这里设计为目标tokens在教师中的embedding表示，再加上教师最后一个隐藏层emd，不懂为什么是这样。最终映射结果表示为 <span class="math display">\[softmax(\frac{QK^T}{\sqrt{ 2D }}V)\]</span></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>KD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Why Exposure Bias Matters: An Imitation Learning Perspective of Error Accumulation in Language Generation</title>
    <link href="/posts/cb5328a8/"/>
    <url>/posts/cb5328a8/</url>
    
    <content type="html"><![CDATA[<p>LM训练的时候，文本前缀用的是groundtruth，而推理生成语句的时候，是逐token生成的，文本前缀是自己生成的。由于LM本身生成的前缀相对训练语料分布可能会有很大的偏差，这会导致后续token的生成也出现偏差。这一现象称为exposure bias。</p><p>模型训练的时候，对于不同的前缀<spanclass="math inline">\(w_{0}^{t-1}\)</span>，loss可以表示为 <spanclass="math display">\[l(p_{\theta},w_{0}^{t-1};o) = \mathop{\mathbb{E}}\limits_{w_{t}\simo(\cdot|w_{0}^{t-1})}\log\frac{o(w_{t}|w_{0}^{t-1})}{p_{\theta}(w_{t}|w_{0}^{t-1})}\]</span> 其中<spanclass="math inline">\(w_{0}^{t-1}\)</span>代表到前面生成的长度为<spanclass="math inline">\(t-1\)</span>的前缀，<spanclass="math inline">\(w_{t}\)</span>代表第<spanclass="math inline">\(t\)</span>个生成的token，<spanclass="math inline">\(o\)</span>代表目标分布（生成策略）这实际上就是一个KLD对齐</p><p>从而在进行teacher forcing的过程中，总loss表示为 <spanclass="math display">\[L^{TF}(p_{\theta}) \approx\sum_{t=1}^{T}\  \mathop{\mathbb{E}}\limits_{\substack{w_{0}^{t-1}\simd_{o}^t \\w_{t}\sim o(\cdot|w_{0}^{t-1})}}\log\frac{o(w_{t}|w_{0}^{t-1})}{p_{\theta}(w_{t}|w_{0}^{t-1})}\]</span></p><p>从而在推理的过程中，可以将模型与目标的偏差表示为 <spanclass="math display">\[L^{I}(p_{\theta}) = \sum_{t=1}^{T}\mathop{\mathbb{E}}\limits_{\substack{w_{0}^{t-1}\simd_{p_{\theta},F}^t\\ w_{t}\sim o(\cdot| w_{0}^{t-1})}} \log\frac{o(w_{t}|w_{0}^{t-1})}{p_{\theta}(w_{t}|w_{0}^{t-1})}\]</span> 其中<span class="math inline">\(w_{0}^{t-1}\simd_{p_{\theta},F}\)</span>表示前缀由训练的模型得到，<spanclass="math inline">\(F\)</span>代表decoding 其记录了<spanclass="math inline">\(T\)</span>步累积之后的总偏差</p><p>记 <span class="math display">\[\epsilon_{t} = \mathop{\mathbb{E}}\limits_{\substack{w_{0}^{t-1}\simd_{o}^t\\ w_{t}\sim o(\cdot| w_{0}^{t-1})}} \log\frac{o(w_{t}|w_{0}^{t-1})}{p_{\theta}(w_{t}|w_{0}^{t-1})}\]</span>代表每一个时间步，模型目标目标分布之后的期望偏差，那么可以得到<spanclass="math inline">\(\epsilon=\frac{1}{T} \sum_{t=1}^{T}\epsilon_{t}\)</span>为总体的期望偏差。由此我们不难得到 <spanclass="math display">\[T\epsilon \leq L^I(p_{\theta}) \leq T^2 \epsilon\]</span>第一个不等号代表累积误差的期望最小值，即每一步的误差都与上一步无关，误差不会累积，这也是最理想的情况。而第二个不等号代表最坏情况，每一步的误差线性累积，最终表现出二次增长的趋势。</p><p>从而可以设计出两个指标： <span class="math display">\[AccErr_{\leq}(l) = \frac{L^I_{\leq l}(p_{\theta})}{\epsilon_{\leq l}}\]</span> 其中<span class="math inline">\(\epsilon_{ \leq l} = 1/l\sum_{t=1}^{l} \epsilon_{t}\)</span>，代表了前<spanclass="math inline">\(l\)</span>步的期望误差 如果exposurebias确实会导致误差累积的话，我们可以观察到<spanclass="math inline">\(\text{AccErr}\)</span>值是随着序列长度增加而超线性增长的。以及 <span class="math display">\[ExAccErr_{\leq}(l) = \frac{L^I_{\leq l}(p_{\theta}) - l \epsilon_{\leql}}{l \epsilon_{\leq l}} \cdot 100\%\]</span> 其中<span class="math inline">\(l\epsilon_{\leql}\)</span>是这<spanclass="math inline">\(l\)</span>步的最小损失，所以<spanclass="math inline">\(ExAccErr\)</span>值代表多出来的损失所占的比重，而这实际上就是由损失累积带来的。如果一个模型能够做到每一个的损失不会累积的话，那么这个值应当一直在0左右，否则，就会呈不断上升的趋势。</p><p>下图<spanclass="math inline">\((a)\)</span>给出了AccErr值的变化曲线，以及l的线性增长曲线，可以看到AccErr确实是超线性增长的，这肯定了损失累积现象。并且可以看到AccErr的增长是接近二次的，而这一点在<spanclass="math inline">\((b)\)</span>中可以观察到，每一步的多余累积误差是线性的，两者可以相互印证。这也证明损失累积的程度是比较大的。<img src="https://s2.loli.net/2025/06/23/CijJE1NtZ6g3Bym.png" /></p><p>另外一个有意思的点是，目前模型推理生成token时，所使用的指标往往是困惑度，而<span class="math display">\[\begin{flalign}\epsilon &amp;= \frac{1}{T} \sum_{t=1}^{T}\mathop{\mathbb{E}}\limits_{\substack{w_{0}^{t-1}\sim d_{o}^t\\w_{t}\sim o(\cdot| w_{0}^{t-1})}} \log\frac{o(w_{t}|w_{0}^{t-1})}{p_{\theta}(w_{t}|w_{0}^{t-1})}\\&amp; \approx -\frac{1}{|D|} \sum_{\substack{(w_{0}^{i-1}, w_{i})\in D}}\log p_{\theta}(w_{i}|w_{0}^{i-1}) + c\\&amp;=H(p_{\theta}; D) + c&#39;\end{flalign}\]</span> 这里<span class="math inline">\(H(p_{\theta};D)\)</span>代表log 困惑度</p><p>从而我们不难发现困惑度所关注的内容与<spanclass="math inline">\(\epsilon\)</span>是类似的，只能捕捉单步的损失，但是对多步累积的损失无法监督，这也是可以尝试突破的一个点。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>KD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NOT ALL LLM-GENERATED DATA ARE EQUAL: RETHINKING DATA WEIGHTING IN TEXT CLASSIFICATION</title>
    <link href="/posts/a6205548/"/>
    <url>/posts/a6205548/</url>
    
    <content type="html"><![CDATA[<p>现在LLM训练时会使用LLM产出的语料。但是LLM产出的分布与训练语料的分布往往会存在偏差，那么就会对训练带来影响。本文通过在CEloss中添加sample-wise的权重，调整不同样本对训练的贡献，来缓解这种分布的mismatch问题。</p><p>记<span class="math inline">\(P\)</span>为真实世界数据分布，<spanclass="math inline">\(P&#39;\)</span>为从其中采样得到的一个子集（<spanclass="math inline">\(|P&#39;|\approx 200\)</span>），期望<spanclass="math inline">\(P&#39;\)</span>能够反映分布<spanclass="math inline">\(P\)</span>。</p><p><span class="math inline">\(Q\)</span>为LLM产出的数据分布，<spanclass="math inline">\(\hat{P}\)</span>为模型预测的分布，训练时的数据记为<spanclass="math inline">\(x\)</span>,其对应的label记为<spanclass="math inline">\(y\)</span>。用<spanclass="math inline">\(Q\)</span>中采样的数据<spanclass="math inline">\(D_{Q}\)</span>进行训练的话，就有<spanclass="math inline">\(\{x,y\}\in D_{Q}\)</span>，可以将训练目标记为<span class="math display">\[\mathbb{E}_{Q}[-\log \hat{P}(y|x;\theta)]\tag{1}\]</span></p><p>为了缓解上述问题，一个比较直观的想法是，对于那些<spanclass="math inline">\(P(y|x),Q(y|x)\)</span>差距比较大的样本对<spanclass="math inline">\(\{x_{i,y_{i}}\}\)</span>，这意味着该样本偏离分布<spanclass="math inline">\(P\)</span>的程度是比较大的，因此在loss中尝试投入更大的权重来修正，而那些<spanclass="math inline">\(P(y|x),Q(y|x)\)</span>差距不算大的样本，可以投入相对小的权重。重要性采样可以实现类似操作，也就是在<spanclass="math inline">\((1)\)</span>式中插入<spanclass="math inline">\(P(y|x) / Q(y|x)\)</span>，得到训练目标为 <spanclass="math display">\[\mathbb{E}_{Q}\left[ -\frac{P(y|x)}{Q(y|x)} \log \hat{P}(y|x;\theta)\right]\tag{2}\]</span> 这就充当了差距比较以及赋权重的角色。</p><p>想要得到分布<spanclass="math inline">\(P,Q\)</span>的具体分布情况，就需要额外训两个model对其进行拟合。当然，分布<spanclass="math inline">\(P\)</span>实际上也是不能直接拟合的，因此用分布<spanclass="math inline">\(\hat{P}\)</span>进行近似，拟合得到的两个具体分布记为<spanclass="math inline">\(\hat{P}&#39;,\hat{Q}\)</span>，最终得到loss为<span class="math display">\[L(\theta,D_{Q}) = -\frac{1}{N} \sum_{i=1}^{N}\frac{\hat{P}&#39;(y_{i}|x_{i})}{\hat{Q}(y_{i}|x_{i})}\log\hat{P}(y_{i}|x_{i};\theta)\tag{3}\]</span></p><p>仔细观察这一式子，可以注意到在整个训练过程中，每一个样本所对应的权重其实是固定的，因此可以尝试根据训练状况为其赋以动态权重。</p><p>具体来说，由于训练数据来自<spanclass="math inline">\(D_{Q}\)</span>，从而分布<spanclass="math inline">\(\hat{P}\)</span>本来就是在拟合<spanclass="math inline">\(Q\)</span>，其与<spanclass="math inline">\(\hat{Q}\)</span>是类似的功能。因此将后者直接替换为<spanclass="math inline">\(\hat{P}(y_{i}|x_{i};\theta_{t})\)</span>，这里用<spanclass="math inline">\(\theta_{t}\)</span>来强调其是随训练进行而不断变化的。<spanclass="math inline">\(\hat{P}&#39;(y_{i}|x_{i})\)</span>是拟合分布<spanclass="math inline">\(P&#39;\)</span>得到的，也可以选择将<spanclass="math inline">\(\hat{P}(y_{i}|x_{i};\theta_{t})\)</span>过<spanclass="math inline">\(P&#39;\)</span>训一遍进行拟合，然后替换掉<spanclass="math inline">\(\hat{P}&#39;(y_{i}|x_{i})\)</span>，最终得到loss为<span class="math display">\[L_{\theta_{i},D_{Q}} = -\frac{1}{N} \sum_{i=1}^{N}\frac{\hat{P}(y_{i}|x_{i};\theta_{t},D_{P&#39;})}{\hat{P}(y_{i}|x_{i};\theta_{t})}\log\hat{P}(y_{i}|x_{i};\theta_{t})\tag{4}\]</span> 这里用<spanclass="math inline">\(\hat{P}(y_{i}|x_{i};\theta_{t},D_{P&#39;})\)</span>来代表<spanclass="math inline">\(\hat{P}(y_{i}|x_{i};\theta_{t})\)</span>过一遍分布<spanclass="math inline">\(P&#39;\)</span>拟合之后的结果。</p><p>这种动态权重，按照个人理解，其实是在根据训练效果调整样本的权重了。预测结果与实际分布接近的话，权重会较大，反之则较大。也就是说，实际上与式<spanclass="math inline">\((3)\)</span>的出发点已经不太一样了，并不是在根据分布P，Q的差距给权重。</p><p>另外，不管是式<span class="math inline">\((3)\)</span>还是式<spanclass="math inline">\((4)\)</span>，对于那些在P中概率较小的样本，都没有很好的赋权策略。如果在P中某个样本对<spanclass="math inline">\(P(y_{i}|x_{i})\)</span>比较小的话，训练得到的预测<spanclass="math inline">\(\hat{P}(y_{i}|x_{i};\theta)\)</span>更有可能是偏大的，那么最终得到的权重反而是一个较小的值。</p><p>最后，对于式<span class="math inline">\((4)\)</span>中的<spanclass="math inline">\(\hat{P}(y_{i}|x_{i};\theta_{t},D_{P&#39;})\)</span>，用<spanclass="math inline">\(\hat{P}(\cdot;\theta_{t})\)</span>再去拟合一遍<spanclass="math inline">\(P&#39;\)</span>是否有必要，直接用<spanclass="math inline">\((3)\)</span>中的<spanclass="math inline">\(\hat{P}&#39;(y|x)\)</span>是否也是可以的？</p><p><img src="https://s2.loli.net/2025/06/23/WRFG1DqZ7JT8j2s.png" /></p><p>在最终的实验结果中，两种Loss并没有一方是有完全胜过另一方的，这或许也可以印证我的观点：两种loss其实是在从不同的角度进行加权，走的是两条路，<spanclass="math inline">\((4)\)</span>并不能直接看成<spanclass="math inline">\((3)\)</span>的改进。从缓解分布mismatch对训练影响的角度看，或许还是(3)更加合理一些。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>KD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo+reveal指南</title>
    <link href="/posts/87c52bab/"/>
    <url>/posts/87c52bab/</url>
    
    <content type="html"><![CDATA[<h1 id="hexoreveal指南">hexo+reveal指南</h1><p>作为一个标准学生仔，slides我做的也不少了，之前一直用WPS，但是其在理工背景下有一些弊端，比如插入公式非常麻烦，以及格式总有些奇妙缩进/空格且难以修复。前段时间从学长那里了解到了可以用markdown+js来写slides，相比之下用markdown来写内容，格式就不再是问题了。（虽然相比WPS可能会有一些单一，不过我正好懒得搞花哨的东西hhh）</p><p>首先明确一下需要做的事：</p><ul><li>找到工具可以用markdown+js来写slides</li><li>将其嵌入到hexo框架下，做到渲染slides与渲染正常文章一样，不需要多余操作</li></ul><h2 id="reveal.js">Reveal.js</h2><p>对于第一点，有许多选择，包括nodeppt，reveal.js等等，但是前者现在已经不维护了，支持的node.js的版本似乎也比较落后了，因此我选择使用reveal.js。</p><h3 id="基本格式">基本格式</h3><p>reveal的官网在<ahref="https://revealjs.com/">这里</a>，其直接提供了一个js编写slides的框架。下载过程比较简单，这里略过，先简单看一下其编写的格式<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;dist/reveal.css&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;dist/theme/white.css&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;reveal&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;slides&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>Slide 1<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>Slide 2<span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;dist/reveal.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>      Reveal.initialize();<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>slides的主体在<code>&lt;body&gt;</code>里面，其需要两层<code>&lt;div&gt;</code>进行包裹，分别是<code>reveal</code>以及<code>slides</code>,编写的时候顺序就是<code>reveal</code>&gt; <code>slides</code> &gt;<code>sections</code>，其中每一个<code>section</code>里面就是一张<code>slide</code>。为了使用<code>reveal</code>和<code>slides</code>这两个<code>class</code>，我们需要在<code>&lt;head&gt;</code>部分提前引入。</p><h3 id="插件引用">插件引用</h3><p>另外如果需要其它插件，比如高亮，或者支持markdown编写等等，需要在Reveal.initialize中添加，具体格式为<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">dist/reveal.js</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">plugin/markdown/markdown.js</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">plugin/highlight/highlight.js</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>Reveal.initialize(&#123;<br>plugins: [ RevealMarkdown, RevealHighlight]<br>&#125;);<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>在前面引入对应的包，然后初始化时添加到<code>plugins</code>列表中。一般需要用到的功能，包括公式渲染，高亮，notes等等，对应的包都在reveal.js文件夹下，从而可以本地直接引用。当然也可以引cdn链接，比如我的reveal版本是5.2.1，那么我要highlight功能的话，引用时也可以写<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">https://cdn.jsdelivr.net/npm/reveal.js@5.2.1/plugin/highlight/highlight.js</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure> 具体的包可以自己去找一下</p><h3 id="公式渲染">公式渲染</h3><p>公式渲染需要引用mathjax，或者KaTex，这一点可以参考<ahref="https://revealjs.com/math/">官网</a>。我按照官网指示没成功，自己引用的是mathjax3，配置如下<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/reveal.js@5.2.1/plugin/math/math.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"> <span class="hljs-title class_">Reveal</span>.<span class="hljs-title function_">initialize</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">plugins</span>: [ ..., <span class="hljs-title class_">RevealMath</span> ],</span><br><span class="language-javascript"><span class="hljs-attr">math</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-attr">mathjax</span>: <span class="hljs-string">&#x27;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-attr">tex</span>: &#123;</span><br><span class="language-javascript"><span class="hljs-attr">packages</span>: [<span class="hljs-string">&#x27;base&#x27;</span>, <span class="hljs-string">&#x27;ams&#x27;</span>], <span class="hljs-comment">// 这里必须显式写上 ams, 为了支持flalign等换行</span></span><br><span class="language-javascript"><span class="hljs-attr">inlineMath</span>: [[<span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-string">&#x27;$&#x27;</span>], [<span class="hljs-string">&#x27;\\(&#x27;</span>, <span class="hljs-string">&#x27;\\)&#x27;</span>]],</span><br><span class="language-javascript"><span class="hljs-attr">displayMath</span>: [[<span class="hljs-string">&#x27;$$&#x27;</span>, <span class="hljs-string">&#x27;$$&#x27;</span>], [<span class="hljs-string">&#x27;\\[&#x27;</span>, <span class="hljs-string">&#x27;\\]&#x27;</span>]]</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript">...</span><br><span class="language-javascript"> &#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p>这样配置好之后一般的公式应该就能正常渲染了。写的时候跟正常也一样，行内公式用<code>$...$</code>，独立公式用<code>$$...$$</code>。但是此时对换行可能还是不支持。我一开始以为是mathjax与reveal的版本兼容问题，但是后面发现是<code>\\</code>被识别为<code>\</code>了，也就是公式中<code>\</code>被识别为转义符号了，那么换行时多打两个<code>\</code>就可以了，例子如下<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$$</span><br>\<span class="hljs-keyword">begin</span>&#123;flalign&#125;<br><span class="hljs-number">5</span> &amp;= <span class="hljs-number">1</span>+ <span class="hljs-number">4</span> \\\\<br>&amp;= <span class="hljs-number">2</span> + <span class="hljs-number">3</span><br>\<span class="hljs-keyword">end</span>&#123;flalign&#125;<br><span class="hljs-variable">$$</span><br></code></pre></td></tr></table></figure></p><h3 id="markdown编写">markdown编写</h3><p>最后是关于这个框架如何使用markdown。事实上并不需要太多操作，<ahref="https://revealjs.com/markdown/">官网</a>也提供了详细的说明，这里简单介绍一下。原本每一页slide的区分依靠<code>&lt;section&gt;</code>标签，然后内部再使用js进行排版和内容编写。换成markdown的话，只需要外面包两层标签，内部就可以正常使用markdown语法了，slide之间的区分依靠<code>---</code>符号<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">data-markdown</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">data-template</span>&gt;</span><br>    ## Slide 1<br>    A paragraph with some text and a [link](https://hakim.se).<br>    ---<br>    ## Slide 2<br>    ---<br>    ## Slide 3<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p>更多的内容，包括美化，子页等操作这里略过，看官网可能更加合适。</p><h2 id="嵌入hexo">嵌入hexo</h2><p>网上关于hexo与reveal结合的教程比较少，github项目也很少，相比之下hugo框架与reveal结合的相关资源会好很多。这里使用的是<ahref="https://github.com/jackey8616/hexo-generator-slidehtml">github上的一个项目</a></p><p>安装很简单，blog目录下输入 <figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i hexo-generator-slidehtml<br></code></pre></td></tr></table></figure> 即可。</p><p>之后对于slide的渲染步骤与正常文章是类似的，只要在slide的tag中添加一个<code>slidehtml: true</code>即可。但是此时还不能直接访问slide</p><p>比如slide渲染之后的link是<code>https://sophilex.top/posts/418a878e/</code>，这是与其它文章一样格式的地址，但是想访问slide，需要在后面添加<code>slide.html</code>，总体为<code>https://sophilex.top/posts/418a878e/slide.html</code></p><p>每次都这么做可能有点麻烦，所以我在第一个link里添加了一个按钮用于跳转。<code>blog\thems\your_theme\layout\post.ejs</code>提供了文章展示的相关js模板，只需要在里面写一个按钮，识别到文章中<code>slidehtml</code>tag为<code>true</code>就展示即可。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 加个横线与文章内容区分 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>/&gt;</span> <br>&lt;% if (page.slidehtml) &#123; %&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;mt-4 text-center&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&lt;%= url_for(page.path) %&gt;slide.html&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span>&gt;</span>View Slides<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  &lt;% &#125; %&gt;<br></code></pre></td></tr></table></figure>这块内容放在<code>markdown-body</code>下面即可，也就是在展示完文章内容（如果有）之后，放上这个按钮。</p><p>slide的渲染模板在<code>blog\node_modules\hexo-generated-slidehtml\layout\post-slide.ejs</code>中，其内容结构与第一部分介绍的reveal模板差不多，毕竟最终html代码就由其产出。slide主体内容被嵌入在如下代码中<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;reveal&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;slides&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">data-markdown</span></span><br><span class="hljs-tag"> <span class="hljs-attr">data-separator</span>=<span class="hljs-string">&quot;&lt;%- config.horizontalSeparator %&gt;&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">data-separator-vertical</span>=<span class="hljs-string">&quot;&lt;%- config.verticalSeparator %&gt;&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">data-separator-notes</span>=<span class="hljs-string">&quot;^Note:&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/template&quot;</span>&gt;</span>&lt;%- page %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>前两层是reveal格式要求，里面是markdown格式要求，slide内容在&lt;%- page%&gt;中，相关结构都处理好了，因此写的时候只需要按照正常markdown内容写就好了。不过写slide之前需要加上一句<code>&lt;!-- Slide Start --&gt;</code>用于表明接下来的内容是slide的，而前面的内容就会被正常渲染为文章页面的内容，格式如下<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">slide</span> <span class="hljs-string">tags...</span><br><br><span class="hljs-string">文章内容</span><br><span class="hljs-string">&lt;!--</span> <span class="hljs-string">Slide</span> <span class="hljs-string">Start</span> <span class="hljs-string">--&gt;</span><br><br><span class="hljs-comment">## 标题1</span><br><span class="hljs-number">123</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-comment">## 标题2</span><br><span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure></p><p>其余的reveal相关配置，参考本文第一部分，在<code>post-slide.ejs</code>中进行相关修改即可。这里分享一下我的<ahref="https://1drv.ms/f/c/33e22cb13c73a84a/Em95-mYfbkRJtOUZrLPI-7wBwtMqLQIIeWwsbIfxTuz9Eg?e=btxB0z">配置</a>（大部分都抄的学长的hhh）</p><h2 id="导出pdf">导出PDF</h2><p>有时候在线的slides有导出本地PDF文件的需求，但是直接在reveal框架渲染出的网页上按<code>Ctrl+P</code>进行下载的话，格式非常乱，完全不能看。这里提供两种方法</p><h3 id="reveal官方">reveal官方</h3><p>官方给的一个方法是在slides的url后面跟上<code>?print-pdf</code>，然后在对应页面按<code>Ctrl+P</code>进行打印。比如我的一个slide的url是<code>https://sophilex.top/posts/ef9972ec/slide.html</code>，加上对应后缀之后就是<code>https://sophilex.top/posts/ef9972ec/slide.html?print-pdf</code>，但是这个功能只能在Chrome和Chromium中使用。至于效果，至少在我这边跟原始方法的效果没啥区别，并不具备可用性。</p><h3 id="decktape">decktape</h3><p>一个专门用来导出网页slides的工具，<ahref="https://github.com/astefanutti/decktape">link</a>。除了reveal.js，其也支持各种网页渲染框架的导出，感兴趣可以去详细了解一下。使用方法也是非常简单，命令基本格式为 <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">decktape [<span class="hljs-keyword">options</span>] [<span class="hljs-keyword">command</span>] <span class="hljs-symbol">&lt;url&gt;</span> <span class="hljs-symbol">&lt;filename&gt;</span><br></code></pre></td></tr></table></figure>其中<code>[command]</code>参数代表了你的slides的渲染框架，这里就写<code>reveal</code>即可；<code>&lt;url&gt;</code>参数就代表你要导出的slides的网址；<code>&lt;filename&gt;</code>参数代表导出文件名</p><p>其它可选项都由<code>[optioins]</code>参数提供，包括导出的分辨率等等，具体可以去项目里详细了解。</p><p>举个栗子，如果我想导出<ahref="https://sophilex.top/posts/ef9972ec/slide.html">这份slides</a>，我的命令应该写为<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">decktape reveal https:<span class="hljs-regexp">//</span>sophilex.top<span class="hljs-regexp">/posts/</span>ef9972ec/slide.html hhh.pdf<br></code></pre></td></tr></table></figure></p><p>导出效果实测非常nice！</p><h2 id="总结">总结</h2><p>这种写slides的方式跟写日常写笔记差不多，但也意味着其排版比较固定（想要复杂点的，多写点css当然也可以实现，但是我懒），插入图片似乎也比较麻烦，位置大小啥的得慢慢调。不过公式编辑的便捷是一大优势，以及个人觉得很帅。（以及被迫重新学了一点前端hhh</p><p>好玩。</p>]]></content>
    
    
    <categories>
      
      <category>配置笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Different Designs For LLM KD Loss</title>
    <link href="/posts/418a878e/"/>
    <url>/posts/418a878e/</url>
    
    <content type="html"><![CDATA[<p>A talk about KLD and its associated improvements in the context ofLLM KD, and then extending to JSD, Wasserstein Distance.</p>]]></content>
    
    
    <categories>
      
      <category>slides</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>KD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器转发流量至本地</title>
    <link href="/posts/be9c436c/"/>
    <url>/posts/be9c436c/</url>
    
    <content type="html"><![CDATA[<h1 id="服务器转发流量至本地">服务器转发流量至本地</h1><p>ssh连着服务器时，想要访问github，huggingface之类的，基本是上不去的。所以需要给服务器配一个梯子。但是没有GUI，也没有root权限，本人也懒，所以使用另一种方式。利用ssh，在服务器上开一个端口，访问网址时将流量转发回本地，之后只要本地挂着梯子就可以了。</p><h2 id="配置ssh文件">配置ssh文件</h2><p>.ssh/config文件配置如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">Host Localc<br>  HostName 你连的服务器的IP<br>  Port 服务器上要转发流量的端口<br>  User 服务器登录用户名<br>  IdentityFile XXXX\.ssh\id_rsa (与你的ssh config文件在同一个目录下)<br>  RemoteForward [远程监听地址:远程端口] [本地目标地址:本地端口]<br></code></pre></td></tr></table></figure><p>本地使用clash的话，打开“局域网连接”选项。一般它的端口就是7890，所以上述格式中最后一行一般写为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">RemoteForward localhost:7890 localhost:7890<br></code></pre></td></tr></table></figure><h2 id="本地ssh连接">本地ssh连接</h2><p>本地连上刚刚配的ssh <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh Localc<br></code></pre></td></tr></table></figure> 此时一般就ok了。尝试 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -x localhost:7890 google.com<br></code></pre></td></tr></table></figure>可以收到如下内容 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">TITLE</span>&gt;</span>301 Moved<span class="hljs-tag">&lt;/<span class="hljs-name">TITLE</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">HEAD</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">BODY</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">H1</span>&gt;</span>301 Moved<span class="hljs-tag">&lt;/<span class="hljs-name">H1</span>&gt;</span><br>The document has moved<br><span class="hljs-tag">&lt;<span class="hljs-name">A</span> <span class="hljs-attr">HREF</span>=<span class="hljs-string">&quot;http://www.google.com/&quot;</span>&gt;</span>here<span class="hljs-tag">&lt;/<span class="hljs-name">A</span>&gt;</span>.<br><span class="hljs-tag">&lt;/<span class="hljs-name">BODY</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">HTML</span>&gt;</span><br></code></pre></td></tr></table></figure> 就代表ok了。</p><p>此时再去用git clone之类的就没问题了。</p><p>需要注意的是，wget这种默认不会走代理端口，需要手动设置一下<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">http_proxy</span>=http://127.0.0.1:7890<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">https_proxy</span>=http://127.0.0.1:7890<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>配置笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>练琴有感</title>
    <link href="/posts/4527e01a/"/>
    <url>/posts/4527e01a/</url>
    
    <content type="html"><![CDATA[<h1 id="练琴有感">练琴有感</h1><p>​作为学了四年指弹的吉他练习生，在今年4月初，在毕设做完之后，终于痛定思痛开始学习乐理，从头开始学吉他。</p><p>​之前在网上经常能看到有人批判说，大部分指弹玩家都是“指板运动员”：即所谓只练习手指机能，曲子旋律，却对旋律为何如此，又该如何改编等等一无所知，也不具备创造音乐的能力。我觉得这说的很对，事实上中间有好几次我都想开始，但又因为懒或者各种原因而搁置。偏偏指弹又确实需要花大功夫来磨砺，便一直在逃避这个问题...</p><p>​幸好，在积累了足够的演奏能力，而恰好这段时间又有闲，我又突然对即兴燃起兴趣时，我终于开始学乐理了。目前也学了几周了，有一定的理论基础，也能对音乐，对指板产生一些自己的理解了。这种感觉很奇妙，我练了四年琴，自认为对它也算熟了，但是CAGED系统和五度圈等东西还是让我对我的琴有了焕然一新的理解。感觉就像，之前我是小学四则运算大王，但现在我能开始探究自然数群的若干性质并进行拓展。</p><p>​其实仔细想想，最妙的是，我在活了二十多年之后，依然可以开始探索一个全新的领域，这里面的东西跟我之前积累的知识基本正交（至少目前来看是这样），就好像我重新开始上小学，开始学拼音，学写字。</p><p>​说到这里，其实科研也勉强能算是类似的事情吧，只是我之前已经有过一些积累罢了，但是我对真正做出自己的成果，发表文章，参加会议等等依然缺少足够的认知和体验，在这一领域也只能算是个小学生吧。也正因如此，我对未来可能到来的这些事情也充满了期待，就好像我一直在期待，我能够独立演奏，创造出音乐的那一天，那一刻。</p><figure><img src="https://s2.loli.net/2025/04/27/6v7zhmPkopGdWZB.png"alt="image-20250427094823579" /><figcaption aria-hidden="true">image-20250427094823579</figcaption></figure><p>​ （以及我是不是该琢磨一下怎么把练琴的音频放到这里来？</p>]]></content>
    
    
    <categories>
      
      <category>杂想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于浮点数存储精度</title>
    <link href="/posts/b32686f3/"/>
    <url>/posts/b32686f3/</url>
    
    <content type="html"><![CDATA[<h1id="关于浮点数存储精度ieee-754浮点标准">关于浮点数存储精度：IEEE-754浮点标准</h1><h2 id="背景">背景</h2><p>炼丹时常用的数据类型有FP32，FP16，其数据存储类型都遵循IEEE-754浮点标准，展示如下</p><blockquote><p>单精度（FP32） 符号位：1位 指数位：8位 尾数位：23位 总范围：<spanclass="math inline">\(\pm 3.4\times 10^{38}\)</span></p></blockquote><blockquote><p>半精度（FP16） 符号位：1位 指数位：5位 尾数位：10位 总范围：<spanclass="math inline">\(\pm 65504\)</span></p></blockquote><p>关于这些不同的位具体是如何组成浮点数的，详细内容可以参考<ahref="https://zhuanlan.zhihu.com/p/343033661">这篇文章</a>，接下来以FP32为例简单解释一下<img src="https://s2.loli.net/2025/04/09/eK546X7qItODUj3.png" /></p><ul><li><p>符号位符号位（sign）很好理解，0/1分别用于表示数字的正/负</p></li><li><p>尾数位尾数位记录的是浮点数的二进制表示，并且将小数点移到第一位之后，然后去除第一位，因为其一定是1（这里先不考虑0）比如考虑小数10.75 其二进制表示为 1010.11这是因为10.75=2+8+1/2+1/4，然后将其小数点左移，得到<spanclass="math inline">\(1.01011\times2^3\)</span>,那么尾数就是01011，剩下的位直接用0来补即可FP32下不难得到尾数位的表示范围为<spanclass="math inline">\(2^{23}\)</span></p></li><li><p>指数位指数位顾名思义，组成的是尾数位的指数，FP32下规定其表示范围为<spanclass="math inline">\([-127,128]\)</span>，也就是对半开，这也意味着其需要在没有符号位的情况下同时表示负数和正数。一个非常常见的处理手段就是所有数同时加上一个偏移量，这里这个偏移量就是127，此时所有表示都<spanclass="math inline">\(\geq 0\)</span>还是考虑小数10.75，其尾数的指数为3，加上偏移量之后为130,表示为01111000即可</p></li></ul><p>最后得到10.75在FP32下表示为0 10000010 01011000...</p><h2 id="误差的来源">误差的来源</h2><p>观察IEEE-754标准，不难发现，尾数用于提供存储的精度，指数用于提供存储的范围。需要指出的是，在存储范围内，整数的表示是没有误差的，但是小数有。这是因为对于整数位，二进制表示本身就是一种准确无误差的表示，但是对于小数位，只能通过<spanclass="math inline">\(\sum\frac{1}{2^{k_{i}}}\)</span>来不断拟合，而尾数所能表示的范围是有限的，也就意味着小数的拟合精度是受限的。</p><p>不过神奇的是，拟合精度带来的误差，并非是绝对误差，而是相对原数而言的。这一点是通过指数位实现的。</p><p>还是以FP32为例，其尾数有23位，那么拟合小数的时候，最高精度为<spanclass="math inline">\(\frac{1}{2^{23}}\approx0.0000001192092896\)</span>，这也意味着从小数点后第7位起，已经无法保证准确的拟合了。但是由于指数位的存在，如果原数的有效数字并不是从小数点后开始的话，可以通过指数位抹除中间多余的0，那么中间这几位的拟合精度将由指数位提供，那么最终拟合精度是大于7位的。这一点可以通过0.123456789和0.00000123456789来理解。</p><p>同样的，对于FP16来说，其尾数为10，就始终可以相对提供约3-4位的十进制有效数字。</p><p>从而不难发现，IEEE-754标准保证的是固定位的十进制有效数字，但是这是相对于原数字来说的，与数值量级无关。</p><p>这一点可以通过程序看看 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">pi = math<span class="hljs-selector-class">.pi</span><br>x = torch<span class="hljs-selector-class">.tensor</span>(pi, dtype = torch.float16)<br>y = torch<span class="hljs-selector-class">.tensor</span>(pi, dtype = torch.float32)<br>z = torch<span class="hljs-selector-class">.tensor</span>(pi, dtype = torch.float64)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(f<span class="hljs-string">&quot;pi: &#123;pi&#125;&quot;</span>)</span></span>  <br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(f<span class="hljs-string">&quot;FP16: &#123;x&#125;, &#123;math.fabs(pi-x.item())&#125;&quot;</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(f<span class="hljs-string">&quot;FP32: &#123;y&#125;, &#123;math.fabs(pi-y.item())&#125;&quot;</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(f<span class="hljs-string">&quot;FP64: &#123;z&#125;, &#123;math.fabs(pi-z.item())&#125;&quot;</span>)</span></span><br></code></pre></td></tr></table></figure> 分别用FP16，FP32，FP64存储<spanclass="math inline">\(\text{pi}=\pi\)</span>并输出，观察其结果与误差</p><div data-align="center"><p><img src="https://s2.loli.net/2025/04/09/HvZhXTgSEpwDacI.png" /></p></div><p>不出意料，FP16可以保留2位有效精度，FP32可以保留6位有效精度。</p><p>而当我们将<span class="math inline">\(\text{pi}\)</span>取做<spanclass="math inline">\(\pi \times 10^-2\)</span>时，得到的结果为</p><div data-align="center"><p><img src="https://s2.loli.net/2025/04/09/wpBS2l7XhrK5Ism.png" /></p></div><p>此时FP16的有效精度就变成了4位，这是因为它的尾数实际拟合的依然是3.1415926...，多出来的两位精度由指数位提供了。而FP32的有效精度也变成了8位，符合预期。</p><p>可以得到的另外一个有意思的结论就是对于极小的数，其存储的绝对误差可能是更小的，比如存储1e-7和存储1e3的区别</p><h2 id="总结">总结</h2><p>IEEE-754浮点标准下，浮点数存储存在精度误差，精度上限受到尾数位长度限制。</p><p>但是这里的误差是<strong>相对于有效数字的</strong>，不是绝对的小数点后位数，与数字量级无关。</p><p>FP16 始终<strong>相对</strong>提供约 <strong>3-4位十进制有效数字</strong>，FP32始终<strong>相对</strong>提供约<strong>6-7位十进制有效数字</strong>，当然这里的“始终”也是建立在数字处于指数位表示范围内的前提下的。</p><p>当然，如果面对的是大规模随机数的存储，那么也只能将其精度直接估成小数点的有效数字了。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bug聚集地</title>
    <link href="/posts/b0268bf8/"/>
    <url>/posts/b0268bf8/</url>
    
    <content type="html"><![CDATA[<h1 id="bug聚集地">bug聚集地</h1><h2 id="tmux-error-connecting">tmux error connecting</h2><p>常见报错格式为</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error </span>connecting to /tmp/tmux-xxxx/default (No such file or directory)<br></code></pre></td></tr></table></figure><p>其中xxxx 是不同的数字，应该是版本号 参考<ahref="https://blog.csdn.net/lianshaohua/article/details/109671105">这篇</a>blog，报错原因是/tmp/tmux-xxxx被误删导致的 在~/.tmux/tmp下创建对应的tmux-xxxx并输入tmuxls或者tmux a等命令尝试重新server，但是一直报错 <figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error </span>creating /home/xxx/.tmux/tmp/tmux-xxxx (Permission denied)<br></code></pre></td></tr></table></figure> 尝试chmod777，但是依然报这个错 在<ahref="https://unix.stackexchange.com/a/724538">这篇</a>回答下面，发现似乎并不用创建tmux-xxxx文件夹，直接pkill-USR1 tmux然后尝试重启server即可 <imgsrc="https://s2.loli.net/2025/02/28/brcCy3LQ59IBim7.png" />总结：一头雾水，莫名其妙（笑</p><h2 id="picgo-上传失败">picgo 上传失败</h2><p>失败日志为</p><blockquote><p>{ "method": "POST", "url": "https://smms.app/api/v2/upload","statusCode": 0, "message": "read ECONNRESET", "stack": "Error: readECONNRESETat TLSWrap.onStreamRead(node:internal/stream_base_commons:220:20)", "response": { "status": 0,"statusCode": 0, "body": "" }</p></blockquote><p>主要关注 <em>Error: read ECONNRESETat TLSWrap.onStreamRead(node:internal/stream_base_commons:220:20)</em>这句，我这边用的是sm.ms，picgo上传时尝试与服务器通信，但是失败了，猜测是网络问题。给picgo挂个代理之后就可以解决了</p><p><ahref="https://github.com/Molunerfinn/PicGo/issues/912">可以看看这个</a></p><h2 id="如何调整copilot字体大小">如何调整copilot字体大小</h2><p>参考<ahref="https://stackoverflow.com/questions/51456526/how-to-change-font-size-in-vs-code-sidebar/51464582#51464582">这篇回答</a>使用<code>ctrl</code>+<code>+/-</code>来控制vscode整体布局大小，然后再单独调整代码字体简单好用！</p>]]></content>
    
    
    <categories>
      
      <category>Bugs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tmux</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器炼丹手册</title>
    <link href="/posts/de558e84/"/>
    <url>/posts/de558e84/</url>
    
    <content type="html"><![CDATA[<h1 id="服务器炼丹手册">服务器炼丹手册</h1><p>从0开始完成ssh连接以及各种配置，边学边补充</p><h2 id="连接服务器">连接服务器</h2><h3 id="ssh远程连接服务器">ssh远程连接服务器</h3><ol type="1"><li>vscode安装Remote-SSH扩展</li><li>打开用户目录下配置文件<code>C:\Users\username\.ssh\config</code></li><li>在其中添加以下内容（如果之前有内容的话写在下面即可，不用覆盖）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">Host <span class="hljs-tag">&lt;<span class="hljs-name">NickName</span>&gt;</span><br><br>    HostName  <span class="hljs-tag">&lt;<span class="hljs-name">服务器IP地址</span>&gt;</span><br><br>    User <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span><br></code></pre></td></tr></table></figure><p><NickName>: 该连接的标识，用于与其它连接区分 <服务器IP地址>:你所要连接的服务器的IP地址 <username>: 你在服务器中的账号用户名</p><p>例如</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host Alephia<br><br>    HostName  <span class="hljs-number">10.1</span>.<span class="hljs-number">1.1</span><br><br>    <span class="hljs-keyword">User</span> <span class="hljs-title">hhh</span><br></code></pre></td></tr></table></figure><p>这之后点击vscode左侧远程资源管理器选项，可以看到已经出现刚刚写入的NickName了<img src="https://s2.loli.net/2025/01/08/fDGLmj2nSs4JcR1.png" /></p><p>右键点击连接，会让你输入服务器user的密码，正确输入之后即可连接成功，此时你在vscode界面左下角可以看到绿色的SSH:NiceName字样</p><p><img src="https://s2.loli.net/2025/01/08/f6TPGLN7KrQcXmq.png" /></p><p>当然这个过程可能会遇到一些问题</p><h4 id="学校服务器ip无法ping通">学校服务器IP无法ping通</h4><p>有些服务器IP想要ping通需要使用学校的VPN，一般每个学校都会给详细的连接教程这里以ecnu为例：</p><p>首先下载vpn工具 打开https://eoffice.ecnu.edu.cn/4e/ba/c6178a85690/page.htm之后，选择对应平台，版本安装即可，安装之后打开效果如下 <imgsrc="https://s2.loli.net/2025/01/08/YckjgCn7ZHV1eKE.png" /></p><p>输入连接vpn的地址之后填入账号密码即可连接， <imgsrc="https://s2.loli.net/2025/01/08/4VR7td8horuDSgH.png" /></p><p>有时候可能会出现连接一小会之后VPN自动断开的情况，可以检查本地梯子，wifi稳定性等等。</p><h3 id="ssh免密连接">ssh免密连接</h3><p>如果经常需要登录服务器的话，免密连接可以提供便捷性，否则每次登录都要输入user密码</p><ol type="1"><li>首先使用命令<code>ssh-keygen -t rsa</code>，之后会在<code>C:\Users\username\.ssh</code>下生成<code>id_rsa</code>以及<code>id_rsa.pub</code>，对应的是私钥和公钥。</li><li>在.ssh文件夹下打开gitbash，输入命令<code>ssh-copy-id host别名</code>，这里host别名就是config文件中提及的标识</li><li>此时已经可以ssh登录服务器了。在<code>powershell</code>中使用命令<code>ssh  host别名</code>即可</li><li>在config文件中追加<code>IdentityFile ~/.ssh/id_rsa</code>，类似如下形式<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host Alephia<br><br>    HostName  <span class="hljs-number">10.1</span>.<span class="hljs-number">1.1</span><br><br>    <span class="hljs-keyword">User</span> <span class="hljs-title">hhh</span><br><br>    IdentityFile ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure> 此时再去连接服务器就不需要密码了。</li></ol><h2 id="配置">配置</h2><h3 id="深度学习基础配置">深度学习基础配置</h3><p>因为实际使用的是服务器那边的文件和资源，vscode只是提供了一个跟本地操作一样的使用体验，所以一些配置是必须的。基础的炼丹环境，conda安装，conda pip换源，torch安装等等不再赘述</p><h3 id="文件传输">文件传输</h3><p>本地与服务器之间的文件传输是必不可少的，这里推荐FileZilla，安装教程略过。打开之后是这个样子 <imgsrc="https://s2.loli.net/2025/01/08/G4dh5sTWzeXJlNB.png" /></p><p>点击左上角“打开站点管理”，新建一个站点 <imgsrc="https://s2.loli.net/2025/01/08/tFszfGLDN54bpVW.png" />协议选择SFTP，之后主机输入服务器IP，之后填入用户密码即可。点击连接之后就可以实现本地与服务器的文件互传了。服务器文件架构位于页面右侧，只需将本地内容拖进对应位置即可。如果有从服务器下载内容的需求的话，在站点管理-高级-默认本地目录处可以设置文件的下载地址</p><h3 id="会话终端分离方案">会话终端分离方案</h3><p>在vscode中打开终端，同时也建立了一个会话，在这个终端中跑的代码，是建立在会话基础上的，当终端关闭的时候，会话也随之取消，训练也会中断。那么服务器/vpn有连接时长限制，或者网络不稳定等情况，就很容易导致训练中断，所以需要一种会话与终端分离的手段，训练开启之后，终端正常关闭，会话可以保持，并且可以在之后与另一个终端建立联系，便于后续操作。</p><p>市面上常见的是Tmux以及screen，这里推荐Tmux</p><p>Tmux最简单的安装就是如下命令，但是需要sudo权限。 <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install tmux<br></code></pre></td></tr></table></figure>对于非root用户可以按照参考<ahref="https://zhuanlan.zhihu.com/p/155662601">这个教程</a></p><p>常用的Tmux分离会话与终端步骤为 1. 终端使用Tmux新建一个会话<code>tmux new -s my_session</code>，其中my_session是你取的会话名字，之后就会进入一个新的界面，终端命令正常使用，只是这里鼠标滚轮被用于查看历史命令。2. 在该程序中开始炼丹 3. 按下快捷键<code>Ctrl+b</code>，然后按下d，即可实现会话与终端的分离，可以安心关上电脑睡觉去了。需要注意的是，直接按下<code>Ctrl+d</code>会退出该会话并且同时删除它，使用需谨慎5.睡醒之后使用命令<code>tmux attach-session -t my_session</code>来重新连接到该会话</p><p>常用Tmux快捷键</p><ul><li><code>Ctrl+b [</code>：使用滚轮/上下键查看历史内容，按q退出该模式</li><li><code>Ctrl+b d</code>：分离当前会话。</li><li><code>Ctrl+b s</code>：列出所有会话。</li><li><code>Ctrl+b $</code>：重命名当前会话。</li></ul><p>常用Tmux命令：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Tmux ls：查看已建立的会话<br>tmux <span class="hljs-keyword">rename</span>-<span class="hljs-keyword">session</span> -t &lt;<span class="hljs-built_in">old</span>-<span class="hljs-keyword">session</span>-<span class="hljs-type">name</span>&gt; &lt;<span class="hljs-built_in">new</span>-<span class="hljs-keyword">session</span>-<span class="hljs-type">name</span>&gt;：重命名会话<br></code></pre></td></tr></table></figure><p>更多使用指南可以参照<ahref="https://zhuanlan.zhihu.com/p/335818087">这篇</a></p><h3 id="跨服务器文件传输">跨服务器文件传输</h3><p>有时候可能会遇到在一台服务器A上的内容需要转移到另一台B上面的情况，但是又懒得从A下载到本地，再从本地上传到B，那么就可以选择跨服务器文件传输，直接从A将内容转移到B</p><p>可以使用rsync命令，这一般是系统自带的，因此不需要提前下载，同时它也不需要root权限。</p><p>在服务器A下使用如下命令即可 <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs elixir">rsync -avzP /path/to/source_folder username_b<span class="hljs-variable">@server_b</span><span class="hljs-symbol">:/path/to/destination/</span><br><br><span class="hljs-comment"># 参数说明：</span><br><span class="hljs-comment"># -a: 归档模式，保持文件属性</span><br><span class="hljs-comment"># -v: 显示详细信息</span><br><span class="hljs-comment"># -z: 压缩传输</span><br><span class="hljs-comment"># -P: 显示进度条，支持断点续传</span><br></code></pre></td></tr></table></figure></p><p>第一次连接另一台服务器时，会要求你确认是否连接 <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">This key <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> known <span class="hljs-keyword">by</span> any other names Are you sure you want <span class="hljs-keyword">to</span> <span class="hljs-keyword">continue</span> connecting (<span class="hljs-literal">yes</span><span class="hljs-regexp">/no/</span>[fingerprint])?<br></code></pre></td></tr></table></figure>确认并输入目标服务器上对应usr的密码即可进行传输。</p>]]></content>
    
    
    <categories>
      
      <category>配置笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从REINFORCE到PPO</title>
    <link href="/posts/3917039e/"/>
    <url>/posts/3917039e/</url>
    
    <content type="html"><![CDATA[<h1 id="从reinforce到ppo">从REINFORCE到PPO</h1><h2 id="梯度估计">梯度估计</h2><p>在RL中，考虑最简单的情况，直接<strong>取当前状态的期望reward之和作为loss</strong>，那么最终目标就是尝试最大化这个loss。形式化地说，记</p><ul><li><span class="math inline">\(\tau: (S_{0}, A_{0}, R_{0}, S_{1},A_{1}, R_{1},\dots)\)</span>代表model的行为序列，其中<spanclass="math inline">\(S\)</span>代表当前所处的状态， <spanclass="math inline">\(A\)</span>代表当前状态下采取的动作， <spanclass="math inline">\(R\)</span>表示动作<spanclass="math inline">\(A\)</span>之后得到的奖励</li><li><span class="math inline">\(\pi(a|s:\theta)\)</span>代表在状态<spanclass="math inline">\(s\)</span>下模型采用动作<spanclass="math inline">\(a\)</span>的概率。策略<spanclass="math inline">\(\pi\)</span>关于<spanclass="math inline">\(\theta\)</span>是可微的</li><li><span class="math inline">\(Q_{\pi}(s,a)\)</span>代表在当前状态为<span class="math inline">\(s\)</span>,采取动作为<span class="math inline">\(a\)</span>时的期望收益</li><li><span class="math inline">\(P((s&#39;,r)|(a,s))\)</span>代表当前状态为<spanclass="math inline">\(s\)</span>,采取动作为<spanclass="math inline">\(a\)</span>时， 转移到状态<spanclass="math inline">\(s&#39;\)</span>,获得reward为<spanclass="math inline">\(r\)</span>的概率。需要注意的是，这是一个与model，或者说策略<spanclass="math inline">\(\pi\)</span>无关的概率分布,它只与交互的环境有关</li></ul><p>那么在当前状态为<spanclass="math inline">\(s\)</span>时loss可以表达为 <spanclass="math display">\[loss(s) = V_{\pi}(s) = \sum_{a} \pi(a|s:\theta)Q_{\pi}(s,a)\]</span> 它既是loss，也代表了处于状态<spanclass="math inline">\(s\)</span>时的期望收益 <spanclass="math inline">\(Q_{\pi}(s,a)\)</span>包含了reward部分以及model的决策部分，前者关于参数<spanclass="math inline">\(\theta\)</span>是不可导的，后者与<spanclass="math inline">\(\theta\)</span>有关。如果直接将整个<spanclass="math inline">\(Q_{\pi}(s,a)\)</span>看成常数的话，loss求梯度倒是很方便了，但是显然是不够合理的。我们需要对其进行进一步的拆分。</p><p>我们可以继续展开为 <span class="math display">\[V_{\pi}(s) = \sum_{a}\pi(a|s:\theta) \sum_{s&#39;, r} P(s&#39;,r|a,s)(V_{\pi}(s&#39;)+ r)\]</span> 我们成功把reward <span class="math inline">\(r\)</span>拆出来了，它与<spanclass="math inline">\(\theta\)</span>无关，我们求个导试试 得到 <spanclass="math display">\[\nabla V_{\pi}(s) = \sum_{a}\nabla\pi(a|s:\theta)Q_{\pi}(s, a) +\pi(a|s:\theta)\sum_{s&#39;}P(s&#39;|a, s)\nabla V_{\pi}(s&#39;)\]</span> 纵观整个<span class="math inline">\(\nablaV_{\pi}(s)\)</span>,唯一有问题的还剩下<span class="math inline">\(\nablaV_{\pi}(s&#39;)\)</span>,它里面还是有r，我们无法显式地得到其<spanclass="math inline">\(\nabla\)</span>的封闭形式。没办法，只能展开 <spanclass="math display">\[\begin{flalign}\nabla V_{\pi}(s) &amp;= \sum_{a}(\nabla\pi(a|s:\theta)Q_{\pi}(s, a) +\pi(a|s:\theta)\sum_{s&#39;}P(s&#39;|a, s))\cdot\\&amp;[\sum_{a&#39;}\nabla\pi(a&#39;|s&#39;:\theta)Q_{\pi}(s&#39;,a&#39;) +\pi(a&#39;|s&#39;:\theta)\sum_{s&#39;&#39;}P(s&#39;&#39;|a&#39;,s&#39;)] \cdot \dots\end{flalign}\]</span> 方便起见，以下记<spanclass="math inline">\(\pi(a&#39;|s&#39;:\theta)\)</span>为<spanclass="math inline">\(\pi(a&#39;|s&#39;)\)</span>对于最终表达式，每一项<span class="math inline">\(\sum_{a}\nabla\pi(a_{k}|s_{k})Q_{\pi}(s_{k},a_{k})\)</span>的系数为 <spanclass="math display">\[\sum_{a_{0}}\pi(a_{0}|s_{0})\sum_{s_{1}}P(s_{1}|a_{0},s_{0})\sum_{a_{1}}\pi(a_{1}|s_{1})\sum_{s_{2}}P(s_{2}|a_{1},s_{1})\dots\sum_{a_{k-1}}\pi(a_{k-1}|s_{k-1})\sum_{s_{k}}P(s_{k}|a_{k-1},s_{k-1})\]</span> 可以简化系数为 <span class="math display">\[\sum_{s_{0},s_{1},\dots s_{k-1}}P(s_{1}|s_{0})P(s_{2}|s_{1})\dotsP(s_{k}|s_{k-1})\]</span> <strong>它实际代表了从状态<spanclass="math inline">\(s_{0}\)</span>经过k次决策之后到达状态<spanclass="math inline">\(s_{k}\)</span>的概率</strong>,可以简记为 <spanclass="math display">\[P(s_{0}\rightarrow x,k, \pi)\]</span> 这里<span class="math inline">\(x\)</span>就代表状态，即<spanclass="math inline">\(s_{k}\)</span></p><p>回到<span class="math inline">\(\nablaV_{\pi}(s)\)</span>,现在其可以整理为 <span class="math display">\[\nabla V_{\pi}(s) = \sum_{x\sim \pi}\sum_{k=0}^{\infty} P(s\rightarrowx,k, \pi) \sum_{a}\nabla \pi(a|x)Q(x,a)\]</span> <span class="math display">\[\nabla V_{\pi}(s) = \sum_{x\sim \pi} \eta(x) \sum_{a}\nabla\pi(a|x)Q(x,a)\]</span> 实际消除了r，得到了一个类封闭形式。但是<spanclass="math inline">\(\eta(x)\)</span>实际无法计算</p><p>归一化 <span class="math display">\[\mu(x) = \frac{\eta(x)}{\sum_{x_{i}\sim \pi} \eta(x_{i})}\]</span> 代表了状态<span class="math inline">\(x\)</span>在策略<spanclass="math inline">\(\pi\)</span>下所有行为序列中出现的概率<strong>在同一个策略<span class="math inline">\(\pi\)</span>下<spanclass="math inline">\(\sum_{x_{i}\sim\pi}\eta(x_{i})\)</span>是一个定值，系数统一除以一个定值，实际上计算得到的梯度与原梯度只是相差一个常数，这个常数可以由步长参数进行调整</strong></p><p>最终， 在初始状态为<spanclass="math inline">\(s\)</span>的情况下，得到对loss梯度的估计为 <spanclass="math display">\[\nabla loss(s) = \nabla V_{\pi}(s) \propto \sum_{x\sim \pi} \mu(x)\sum_{a}\nabla \pi(a|x)Q(x,a) = E_{x\sim \pi}[\sum_{a}\nabla\pi(a|x)Q(x,a)]\]</span></p><p>与一开始的式子进行对比，发现它与直接将<spanclass="math inline">\(Q\)</span>看成常数的效果非常相似，只是外面多了个期望</p><h2 id="reinforce">REINFORCE</h2><p>在<span class="math inline">\(\nabla loss\)</span>中对a也进行估计</p><p><span class="math display">\[\begin{flalign}\nabla loss(x) &amp;= E_{x\sim \pi}[\sum_{a}\nabla \pi(a|x)Q(x,a)]\\&amp;= E_{x\sim \pi}[\sum_{a}\pi(a|x)\frac{\nabla\pi(a|x)}{\pi(a|x)}  Q(x,a)]\\&amp;= E_{x\sim \pi}[\sum_{a}\pi(a|x)\nabla \log\pi(a|x) \  Q(x,a)]\\&amp;= E_{x, a\sim \pi}[\nabla \log\pi(a|x) \  Q(x,a)]\\\end{flalign}\]</span> 采样估计</p><p><span class="math display">\[\nabla loss = \nabla \log\pi(a_{t}|s_{t}) \  Q(s_{t},a_{t})\]</span></p><p>在实际操作中，<spanclass="math inline">\(Q(s_{t},a_{t})\)</span>的估计直接由之后每一个阶段的奖励加权求和得到，一般也记为<span class="math inline">\(G_{t}\)</span>，换句话说，<spanclass="math inline">\(G_{t}\)</span>是<spanclass="math inline">\(Q(s_{t},a_{t})\)</span>的一个估计，具体估计形式可以见下面的算法伪代码</p><p><strong>由于这里对<span class="math inline">\(Q(s_{t},a_{t})\)</span>的估计需要该步骤之后的奖励信息，因此这个算法的参数更新必须在整个决策轨迹都生成之后才能进行，不支持在线更新</strong></p><p><img src="https://s2.loli.net/2025/01/01/zEH3syxID26LeNv.png" ></p><p><strong>重新整理一下整个过程中蕴含的一些直觉：</strong>首先对rl背景进行建模，得到<span class="math inline">\(\nablaloss\)</span>的一般表达式： <span class="math display">\[\nabla V_{\pi}(s) = \sum_{a}\nabla\pi(a|s:\theta)Q_{\pi}(s, a) +\pi(a|s:\theta)\sum_{s&#39;}P(s&#39;|a, s)\nabla V_{\pi}(s&#39;)\]</span> 然后通过无限展开对上式的最后一项<spanclass="math inline">\(\nablaV_{\pi}(s&#39;)\)</span>进行估计，最后可以将对奖励的求梯度操作全部转移到决策轨迹中每一个状态上对模型的求梯度操作。然后再利用采样操作来近似这个值即可，得到结果<span class="math display">\[\nabla loss(x) = E_{(a_{t}, s_{t})\sim \pi}[\nabla \log\pi(a_{t}|s_{t})\  G(t)]\\\]</span></p><h2 id="减小估计的方差">减小估计的方差</h2><h2 id="reinforce-with-baseline">REINFORCE with baseline</h2><p>REINFORCE这种方法存在方差过大的问题：更新不稳定，难以收敛方差来源于对<span class="math inline">\(Q(s_{t},a_{t})\)</span>的估计<spanclass="math inline">\(G(t)\)</span>,而不是前者<spanclass="math inline">\(\nabla\log\pi(a_{t}|s_{t})\)</span>,这是精确计算的gradient</p><p><span class="math display">\[\begin{flalign}Var[\nabla \log\pi(a_{t}|s_{t}) \  G(t)] &amp;= E[(\nabla\log\pi(a_{t}|s_{t}) \  G(t))^2] - E[\nabla \log\pi(a_{t}|s_{t}) \G(t)]^2\\\end{flalign}\]</span>后一项是对实际梯度的无偏估计，对于方差没有影响，主要是前一项。对于<spanclass="math inline">\(Var[G(t)]\)</span>来说，轨迹过长， Var会不断累加<span class="math display">\[Var[G(t)] = Var[a_{t+1}R_{t+1}+ \dots + a_{T}R_{T}] =\sum_{R_{i}}Var[a_{i}R_{i}]\]</span></p><p>考虑引入一个baseline,记为<spanclass="math inline">\(b(s_{t})\)</span> <span class="math display">\[\nabla loss&#39; = \nabla \log\pi(a_{t}|s_{t}) \ ( G(t) - b(s_{t}))\]</span> 这一引入不会改变估计的无偏性，这是因为 <spanclass="math display">\[\sum_{a}b(s_{t})\nabla_{\theta} \log \pi(a_{t}|s_{t}) =b(s)\nabla_{\theta}\sum_{a}\log \pi(a_{t}|s_{t}) = b(s)\nabla_{\theta}1= 0\]</span></p><p>从而 <span class="math display">\[\begin{flalign}Var[\nabla \log\pi(a_{t}|s_{t})(G(t)-b(s_{t}))] &amp;= E[(\nabla\log\pi(a_{t}|s_{t})(G(t)-b(s_{t})))^2] - E[\nabla\log\pi(a_{t}|s_{t})(G(t)-b(s_{t}))]^2\\\end{flalign}\]</span></p><p>同理，后一项对方差没有影响，我们只需要关注前一项 <spanclass="math display">\[E[(\nabla \log\pi(a_{t}|s_{t})(G(t)-b(s_{t})))^2]\]</span> 为了减少方差，目标是选择<spanclass="math inline">\(b(s)\)</span>来最小化 <spanclass="math display">\[\mathbb{E}[(G(t)-b(s_{t}))^2] = \mathbb{E}[G(t)^2] -2\mathbb{E}[G(t)b(s_{t})] + \mathbb{E}[b(s_{t})^2]\ \ \ \ (1)\]</span></p><p>注意到<span class="math inline">\(\mathbb{E}[G(t)] =V(s_{t})\)</span>，从而 <span class="math display">\[\frac{\partial}{\partial b(s_{t})}\mathbb{E}[(G(t)-b(s_{t}))^2] =-2V(s_{t}) + 2b(s_{t})\]</span> <strong>从而梯度最小值在<spanclass="math inline">\(b(s_{t})\)</span>取为<spanclass="math inline">\(V(s_{t})\)</span>的时候取到</strong>，此时<spanclass="math inline">\(b(s_{t})\)</span>代表的实际含义就是当前状态下的期望收益。但是因为在状态<spanclass="math inline">\(s_{t}\)</span>的时候<spanclass="math inline">\(V(s_{t})\)</span>实际上也是未知的，所以可以考虑类似<spanclass="math inline">\(G(t)\)</span>的方式来拟合，或者使用神经网络来拟合。至于引入baseline的有效性：原始的REINFORCE就是取<spanclass="math inline">\(b(s_{t})\)</span>为0时候的情况，显然其对应的方差是大于<spanclass="math inline">\(v(s_{t})\)</span>取最优解<spanclass="math inline">\(V(s_{t})\)</span>时候的情况的，具体可以参考式子(1)</p><p>从而我们可以得到更新后的梯度表达式为 <span class="math display">\[\nabla loss(x) = E_{(a_{t}, s_{t})\sim \pi}[\nabla \log\pi(a_{t}|s_{t})\  A(t)]\\\]</span> 其中<span class="math inline">\(A(t) = G(t)-b(s_{t})\)</span>，其含义可以理解为在状态<spanclass="math inline">\(s_{t}\)</span>下，采用动作<spanclass="math inline">\(a_{t}\)</span>时可以获得的收益，相比状态<spanclass="math inline">\(s_{t}\)</span>的期望收益的差值，也称为优势。</p><h2 id="actor-critic-model">actor-critic model</h2><p><spanclass="math inline">\(b(s)\)</span>的选择很重要，因此考虑由另外一个mode来进行拟合，这个model拟合的内容就是在状态<spanclass="math inline">\(s\)</span>下期望获得的收益,称为critic，而<spanclass="math inline">\(\pi\)</span>就被称为actor <strong>而<spanclass="math inline">\(( Q(s_{t},a_{t}) -b(s_{t}))\)</span>被称为优势</strong>,它表明了当前决策相比原本决策会获得的额外收益，是更多还是更少。这个值的正负直接决定了优化的方向是鼓励还是抑制</p><p><img src="https://s2.loli.net/2025/01/01/bWB38CSaIOyLUie.png" ></p><p>上述梯度更新思路仍然存在一个问题，就是对样本的利用效率太低了。每次更新的时候需要等待一整轮决策生成完毕，并且只用一次。可以使用重要性采样来进行优化</p><p><span class="math display">\[\large\begin{flalign}\nabla loss(x) &amp;= E_{(a_{t}, s_{t})\sim \pi}[\nabla\log\pi(a_{t}|s_{t}) \  A(t)]\\&amp;= E_{(a_{t}, s_{t})\sim\pi_{\theta_{old}}}[\frac{\pi(s_{t},a_{t})}{\pi_{old}(s_{t},a_{t})}\nabla\log\pi(a_{t}|s_{t}) \  A(t)]\\&amp;= E_{(a_{t}, s_{t})\sim\pi_{old}}[\frac{\pi(s_{t},a_{t})}{\pi_{old}(s_{t},a_{t})}\nabla\log\pi(a_{t}|s_{t}) \  A(t)]\\\end{flalign}\]</span></p><p>可以进一步优化如下 <span class="math display">\[\large\begin{flalign}\nabla loss(x) &amp;= E_{(a_{t}, s_{t})\sim\pi_{old}}[\frac{\pi(s_{t},a_{t})}{\pi_{\theta_{old}}(s_{t},s_{t})}\nabla\log\pi(a_{t}|s_{t}) \  A(t)]\\&amp;= E_{(a_{t}, s_{t})\sim\pi_{old}}[\frac{\pi(a_{t}|s_{t})}{\pi_{old}(a_{t}|s_{t})}\frac{1}{\pi(a_{t}|s_{t})}\nabla\pi(a_{t}|s_{t}) \  A(t)]\\&amp;= E_{(a_{t}, s_{t})\sim \pi_{old}}[\frac{\nabla\pi(a_{t}|s_{t})}{\pi_{old}(a_{t}|s_{t})}A(t)]\ \ \ \ (2)\\\end{flalign}\]</span> 上述变形保持估计的无偏，但是估计的方差会随着策略<spanclass="math inline">\(\pi\)</span>与<spanclass="math inline">\(\pi_{old}\)</span>的比值 <spanclass="math display">\[\frac{\pi(a_{t}|s_{t})}{\pi_{old}(a_{t}|s_{t})}\ \ \ (3)\]</span> 而<strong>正比变化</strong>。这是因为<ahref="https://zhuanlan.zhihu.com/p/695130713">link</a>（之后再补充）</p><p>我们需要让<spanclass="math inline">\((2)\)</span>式尽可能小，也就是让更新尽可能的平缓，由此可以引入KLLoss来对两者得到的分布的距离进行限制</p><p>从而得到新的<span class="math inline">\(loss\)</span>为 <spanclass="math display">\[\largeloss = E_{(a_{t}, s_{t})\sim\pi_{old}}[\frac{\pi(a_{t}|s_{t})}{\pi_{old}(a_{t}|s_{t})}A(t) - \lambdaKL(\pi_{old}(a_{t}|s_{t}),\pi(a_{t}|s_{t}))]\ \ \ (4)\]</span> 原本用cross entropy更合理，但是<spanclass="math inline">\(\pi_{old}\)</span>的分布相对当前参数策略<spanclass="math inline">\(\pi\)</span>来说是固定的，所以可以直接减掉，那就用KLLoss就可以了。</p><h2 id="ppo">PPO</h2><p>但是实际计算KL Loss开销还是太大了，不现实，所以经验性地直接对<spanclass="math inline">\(\large r_{t} =\frac{\pi(a_{t}|s_{t})}{\pi_{old}(a_{t}|s_{t})}\)</span>进行clip操作,将其限制在<spanclass="math inline">\([1-\epsilon,1+\epsilon]\)</span>之间</p><p>得到loss为 <span class="math display">\[\largeloss = E_{(a_{t}, s_{t})\sim \pi_{old}}[min(r_{t}A(t) , clip(r_{t},1-\epsilon, 1+\epsilon)A(t))]\ \ \ (4)\]</span></p><p>这就是最终的PPO的式子了。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>LLM</tag>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>伍六七观后小感</title>
    <link href="/posts/4eaad3e7/"/>
    <url>/posts/4eaad3e7/</url>
    
    <content type="html"><![CDATA[<h1 id="伍六七观后小感">伍六七观后小感</h1><p>今天趁着实习结束，毕设开题答辩结束，抓紧划水，刷了一下伍六七的第三季。说实话原本是把这个番当作下饭喜剧片来看的，前两季的节奏也相对舒缓平和。但是随着剧情深入，似乎很难回到一开始慵懒的小鸡岛剧情了。我刚意识到这一点的时候，心里多少有些惋惜，因为打打杀杀的总还是有些抵触。但是后面想想，这又何尝不是剧情，伍六七的一种成长呢，谁又能在长大后又往回走呢</p><p>第五集结尾白狐在海滩边往回走，身后的事物逐一爆炸，配上非常应景的bgm，多少还是有点震撼到我了。很喜欢网友说的一段评论</p><blockquote><p>我看有小伙伴说这首歌白狐处刑曲，其实我记得这首歌响起来之前白狐的一句话∶“真羡慕你啊。”当时听完这句话我以为白狐只是恐吓阿七来着，不打算毁掉小鸡岛，但是他开始biubiubiu的时候真的吓了我一跳，上一刻还在感伤立马就开始动手摧毁了，平静几秒之后，看着夕阳下白狐没有表情的biubiu，其实突然明白了，这首歌不只写了阿七，也写了白狐。整个屏幕里，最让人难受的其实不是小鸡岛上四处被破坏，而是白狐始终平静的表情，不是不难过，是已经经历的伤已经让心足够承担，足够麻木，和这首歌里弥漫的孤独融为一体</p></blockquote><p>仔细想想，整个动画片里的每个人似乎都有一段或悲伤或不甘的过去，只是有些人，比如柒，比如赤牙，可以获得他人的陪伴，可以与过去和解；但又有另外一些人，比如白狐，又比如黑鸟，囿于宿命，又或者其它种种，只能自我消化，又难免不得其解。</p><p>站在这个角度，大家都是可怜人，只是有些幸运地获得了救赎。也难怪白狐在海滩边会说出羡慕两字，转头却又毁了这般场景。</p><p>真是个悲伤的故事啊。</p><figure><img src="https://s2.loli.net/2024/12/17/KFOCMRgev3apSuG.png"alt="image-20241217231314151" /><figcaption aria-hidden="true">image-20241217231314151</figcaption></figure><p>( 第五集bgm： Do I Matter To Me 赵寒</p>]]></content>
    
    
    <categories>
      
      <category>杂想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂想</tag>
      
      <tag>观后感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VAE学习笔记</title>
    <link href="/posts/7055bc91/"/>
    <url>/posts/7055bc91/</url>
    
    <content type="html"><![CDATA[<h1 id="vae学习笔记">VAE学习笔记</h1><p>在生成模型中，如果我们有一组数据<spanclass="math inline">\(X_1,X_2,...X_n\)</span>，那么最理想的情况就是能够建模出<spanclass="math inline">\(X\)</span>对应的实际分布<spanclass="math inline">\(p(X)\)</span>。那么之后要生成新的<spanclass="math inline">\(X\)</span>的话，只要选择<spanclass="math inline">\(p(X)\)</span>中对应概率密度比较大的<spanclass="math inline">\(X\)</span>，它就大概率是合理的样子但是只有分布的采样而且不清楚其具体的分布形式的话，我们无法构造概率密度，也就无法使用正常方法来建模。但是考虑到auto-encoder架构的话，我们可以利用encoder之后得到的隐向量<spanclass="math inline">\(Z\)</span>来对<spanclass="math inline">\(X\)</span>进行建模，具体来说 <spanclass="math display">\[q(X) = \sum_{Z}q(X|Z)q(Z) = \sum_{Z}q(X,Z)\]</span> 这里的<spanclass="math inline">\(q(Z)\)</span>是先验分布，我们的目标就是希望<spanclass="math inline">\(q(X)\)</span>能够逼近<spanclass="math inline">\(p(X)\)</span>,这样，我们既有了数据的实际分布，又可以通过采样<spanclass="math inline">\(Z\)</span>来进行生成工作。 不妨设<spanclass="math inline">\(p(X,Z) = p(Z|X)p(X)\)</span>,那么显然<spanclass="math inline">\(p(X)\)</span>也可以通过全概率公式转化为上述式子的模样。如果我们希望<spanclass="math inline">\(q(X)\)</span>逼近<spanclass="math inline">\(p(X)\)</span>,此时一个很好的方法就是让<spanclass="math inline">\(q(X,Z)\)</span>逼近<spanclass="math inline">\(p(X,Z)\)</span>。我不太确定这两者的效果是不是完全一样的，但在auto-encoder的背景下，利用好隐藏变量<spanclass="math inline">\(Z\)</span>显然是一个不赖的主意。那么衡量两个分布的距离，不妨用KL散度 <span class="math display">\[\begin{flalign}KL(p(X,Z)||q(X,Z)) &amp;= \int \int p(X,Z)\ln \frac{p(X,Z)}{q(X,Z)}dZdX\\&amp;= \int p(X) [\int p(Z|X)\ln \frac{p(X,Z)}{q(X,Z)}dZ]dX\\&amp;=E_{X\sim p(X)}[\int p(Z|X)\ln \frac{p(X,Z)}{q(X,Z)}dZ]\\&amp;= E_{X\sim p(X)} [\int p(Z|X)(\ln p(X) + \ln\frac{p(Z|X)}{q(X,Z)})dZ]\\\end{flalign}\]</span> 对于式子中的前者，有 <span class="math display">\[{\begin{flalign}E_{X\sim p(X)} [\int p(Z|X)\ln p(X)dZ] &amp;= E_{X\sim p(X)} [ \ln p(X)]\end{flalign}}\]</span> 其中<span class="math inline">\(p(X)\)</span>是关于<spanclass="math inline">\(X\)</span>的先验，它应当是一个常数，从而这整一项是一个常数C，从而<span class="math display">\[\begin{flalign}KL(p(X,Z)||q(X,Z)) &amp;= E_{X\sim p(X)} \left[ \int p(Z|X)\ln\frac{p(Z|X)}{q(X,Z)}dZ \right] +C\end{flalign}\]</span> 从而可以设计出Loss为 <span class="math display">\[\begin{flalign}Loss &amp;= E_{X\sim p(X)} \left[ \int p(Z|X)\ln\frac{p(Z|X)}{q(X,Z)})dZ \right]\\&amp;= E_{X\sim p(X)} \left[ \int p(Z|X)\ln \frac{p(Z|X)}{q(Z)q(X|Z)})dZ\right]\\&amp;= E_{X\sim p(X)} \left[- \int p(Z|X)\ln q(X|Z)dZ + \int p(Z|X) \ln\frac{p(Z|X)}{q(Z)})dZ \right]\\&amp;= E_{X\sim p(X)} \Big[E_{Z\sim p(Z|X)}[-\ln q(X|Z)] +KL(p(Z|X)||q(Z)) \Big]\\\end{flalign}\]</span> 让我们来仔细观察这个设计出来的Loss。首先<spanclass="math inline">\(X\sim p(X)\)</span>表示输入样本<spanclass="math inline">\(X\)</span>来自于一个已经存在的分布<spanclass="math inline">\(p(X)\)</span>,当然这个分布具体是什么样子我们并不知道，逼近该分布也正是我们的目标。对于<span class="math inline">\(E_{Z\sim p(Z|X)}[-\lnq(X|Z)]\)</span>这一项，<span class="math inline">\(Z\simp(Z|X)\)</span>表示该隐变量<spanclass="math inline">\(Z\)</span>的分布来自于<strong>某个</strong>样本<spanclass="math inline">\(X\)</span>,在auto-encoder中实际就是<spanclass="math inline">\(X\)</span>输入之后经过encoder得到<spanclass="math inline">\(Z\)</span>,这也是非常的合理，而整体来看这一项也就是一般auto-encoder的目标：通过隐变量<spanclass="math inline">\(Z\)</span>重建<spanclass="math inline">\(X\)</span>得到熵。所以这一项实际上就是希望重建之后与原样本的差距能够尽可能的小。对于后一项<spanclass="math inline">\(KL(p(Z|X)||q(Z)\)</span>,它是希望隐变量<spanclass="math inline">\(Z\)</span>关于<spanclass="math inline">\(X\)</span>的后验与其先验尽可能的接近。对于这一点我是这样理解的：<strong>首先隐变量<spanclass="math inline">\(Z\)</span>服从一个分布<spanclass="math inline">\(q(Z)\)</span>,这是一个与<spanclass="math inline">\(X\)</span>无关的分布。而我们实际做decoder的时候，肯定是从encoder之后的分布中去采样<spanclass="math inline">\(Z\)</span>的，也就是说，对于给定样本<spanclass="math inline">\(X\)</span>,我们是从分布<spanclass="math inline">\(p(Z|X)\)</span>中去采样的。分布<spanclass="math inline">\(p(Z|X)\)</span>中含有<spanclass="math inline">\(X\)</span>的信息，因此其decoder的结果在Loss前一项的约束下一定会往靠近<spanclass="math inline">\(X\)</span>的方向走，这回导致模型生成能力被削弱。而正是因为<spanclass="math inline">\(KL(p(Z|X)||q(Z)\)</span>的约束，<spanclass="math inline">\(p(Z|X)\)</span>也会受到分布<spanclass="math inline">\(q(Z)\)</span>的影响，而这是一个与<spanclass="math inline">\(X\)</span>无关的分布，那么感性理解，模型自然会拥有更强大的生成能力。</strong></p><p>到这里我们也不难看出，Loss中的两项其实是相互拮抗的，这有点类似于GAN。但是不同的是，这里对抗的两项都是在不断演化中，而在GAN中鉴别者往往是不动的，只有造假者在不断进化。因此在考虑这个Loss的时候，也不能指望两个分项能够同时下降：它们一个控制生成的精确程度，另一个控制生成的多样程度(用词匮乏，意会即可...)所以我在想也可以通过在它们之间添加超参的方式来人为控制趋势。</p><p>接下来尝试给出一些合理的设定，从而完成整个Loss的设置 目前我们的Loss是<span class="math display">\[\begin{flalign}Loss &amp;=  E_{X\sim p(X)} \Big[E_{Z\sim p(Z|X)}[-\ln q(X|Z)] +KL(p(Z|X)||q(Z)) \Big]\\\end{flalign}\]</span> 在这里，<spanclass="math inline">\(p(X)\)</span>是一个已经存在的分布，我们需要对其进行近似，所以这里不必对其进行建模。而之后的<spanclass="math inline">\(p(Z|X),q(X|Z),q(Z)\)</span>我们都不知道，需要将其显式表示。</p><p>首先看<spanclass="math inline">\(q(Z)\)</span>,根据之前所描述，它是一个与样本<spanclass="math inline">\(X\)</span>无关的分布，并且起到了牵制模型生成能力的作用，从而我们可以对其进行合理的假设，比如Gaussian分布,简单点的话就是<spanclass="math inline">\(N(0,I)\)</span>，也就是标准的多元gaussian分布接下来，<spanclass="math inline">\(p(Z|X)\)</span>表示encoder之后隐变量的分布，<spanclass="math inline">\(q(X|Z)\)</span>表示decoder之后生成结果的分布。接下来我们会假设这两个分布的具体形式，同时用模型来学习它们的参数（<strong>如果不用模型学习参数的话那这整个loss设计出来也没啥意义了，至于为啥两个分布都要通过模型来训练，而不是由<spanclass="math inline">\(q(Z)\)</span>和其中一个分布来尝试得到另外一个分布，这一点我后面再思考一下</strong>）</p><p>由于<span class="math inline">\(p(Z|X)\)</span>需要往<spanclass="math inline">\(q(Z) =N(0,I)\)</span>靠近，为了方便计算不妨假设其也是<strong>各分量独立</strong>的gaussian分布,那么对于每一个分量来说，都有<br /><span class="math display">\[p(Z|X)^{(k)} = N(u_{k},\sigma_{k}^2)\]</span> 从而对于<spanclass="math inline">\(KL(p(Z|X)||q(Z))\)</span>,其每一个分量的结果为<span class="math display">\[\begin{flalign}KL(N(\mu,\sigma^2)||N(0,1)) &amp;= \int \frac{1}{\sqrt{2\pi\sigma^2}}e^{-(x-\mu)^2/2\sigma^{2}}\left(\log\frac{e^{-(x-\mu)^2/2\sigma^{2}}/\sqrt{2\pi\sigma^2}}{e^{-(x)^2/2}/\sqrt{2\pi}} \right)dx\\&amp;= \int \frac{1}{\sqrt{2\pi\sigma^2}}e^{-(x-\mu)^2/2\sigma^{2}}\log\left\{ \frac{1}{\sqrt{ \sigma^2}}e^{-(x-\mu)^2/2\sigma^{2}+x^2/2} \right\}dx\\&amp;= \frac{1}{2}\int \frac{1}{\sqrt{2\pi\sigma^2}}e^{-(x-\mu)^2/2\sigma^{2}}\left[ -\log \sigma^2 + \left(x^2-\frac{(x-\mu)^2}{\sigma^2} \right)  \right]dx\\&amp;=\frac{1}{2}\int \frac{1}{\sqrt{2\pi\sigma^2}}e^{-(x-\mu)^2/2\sigma^{2}}(-\log \sigma^2)dx + \frac{1}{2}\int\frac{1}{\sqrt{2\pi \sigma^2}}e^{-(x-\mu)^2/2\sigma^{2}}\left(x^2-\frac{(x-\mu)^2}{\sigma^2} \right)dx\end{flalign}\]</span> 对于第一项，将<spanclass="math inline">\(-\log(\sigma^2)\)</span>提出来之后，里面就是一个完整的gaussian分布的积分，从而结果为<spanclass="math inline">\(-\frac{1}{2}\log(\sigma^2)\)</span>之后一项套用方差与二阶矩的定义之后得到结果为<spanclass="math inline">\(\frac{1}{2}(\mu^2 + \sigma^2 -1)\)</span>从而得到每一个分量的结果为 <span class="math display">\[KL(N(\mu,\sigma^2)||N(0,1)) =\frac{1}{2}(-\log\sigma^2 + \mu^2 +\sigma^2 -1)\]</span></p><p>那么整体考虑的话，最终得到 <span class="math display">\[KL(p(Z|X)||q(Z)) = \frac{1}{2}\sum_{k=1}^{d}(-\log \sigma_{k}^2+\mu_{k}^2 + \sigma_{k}^2-1)\]</span> 其中<spanclass="math inline">\(d\)</span>是隐变量的维度，这里的<spanclass="math inline">\(\sigma_{i},\mu_{i}\)</span>就作为可训练的参数来进行计算了，然后通过反向传播来实现优化。</p><p>最后我们来处理<spanclass="math inline">\(q(X|Z)\)</span>，这个分布只是在最后计算熵用的，作者在文中提供了两种选择：Bernoulli分布与gaussian分布。在各分量独立的假设下，具体到每一个分量的话，其实就是01分布与单变量的gaussian分布。这里简单讨论以下后者。</p><p>还是记其是一个各分量相互独立的gaussian分布，将其分布显式地写出来，为<span class="math display">\[q(X|Z) = \frac{1}{\prod_{k=1}^{D}\sqrt{2\tilde{\sigma}_{k}^2(Z)}}\exp\{-\frac{1}{2}\| \frac{x -\tilde{\mu}(Z)}{\tilde{\sigma^2(Z)}} \|^2\}\]</span> 其中<spanclass="math inline">\(D\)</span>表示最终输出结果的维度这里为了与之前做区分，将方差与均值记为<spanclass="math inline">\(\tilde{\sigma}(Z),\tilde{\mu}(Z)\)</span>,同时因为这是一个与<spanclass="math inline">\(Z\)</span>有关的分布，所以加了<spanclass="math inline">\((Z)\)</span>的后缀 那么不难得到 <spanclass="math display">\[-\ln q(X|Z) = -\frac{1}{2}\| \frac{x -\tilde{\mu}(Z)}{\tilde{\sigma^2(Z)}} \|^2\ +\frac{1}{2}\sum_{k=1}^{D}\tilde{\sigma}_{k}^2(Z) + \frac{D}{2}\ln 2\pi\]</span> 不过这里<strong>往往会把<spanclass="math inline">\(\sigma_{k}\)</span>固定为相同的值</strong>，从而得到<span class="math display">\[-\ln q(X|Z) \sim -\frac{1}{2\sigma^2}\| x - \tilde{\mu}(Z)\|^2\\]</span> 而这实际上是一个MSE最终我们也就完成了Loss的设计，这中间模型的架构也就逐渐清晰了<img src="https://s2.loli.net/2025/01/01/yLsgBY7lreJouOt.png" ></p><p>最后在训练阶段还有一个问题没有解决，那就是decoder阶段对隐变量<spanclass="math inline">\(Z\simp(Z|X)\)</span>进行了采样操作，所以需要重参数技巧进行处理来保证反向传播的可行性。这一点我也专门写过一篇<ahref="https://sophilex.github.io/Reparameterization-Trick/">文章</a>，自认为还是比较详细的。而这里<spanclass="math inline">\(Z\simp(Z|X)\)</span>假设为是一个gaussian分布，那么实际处理起来也很简单，这里不再赘述。</p><p>最后，我们注意到，从隐变量<spanclass="math inline">\(Z\)</span>的分布，到encoder，decoder阶段的后验<spanclass="math inline">\(p(Z|X)\)</span>以及似然<spanclass="math inline">\(q(X|Z)\)</span>都被假设为gaussian分布。由于<spanclass="math inline">\(q(X|Z)\)</span>最终是会逼近<spanclass="math inline">\(p(X|Z)\)</span>,我们不妨以后者代替之，然后看看三者都假设为gaussian分布的合理性。</p><p>可以这样来考虑: &gt; <spanclass="math inline">\(p(X)\)</span>是任意一个分布，<spanclass="math inline">\(p(Z) \simN(0,I)\)</span>的情况下，能否得到合理的<spanclass="math inline">\(p(X,Z)\)</span>，使得<spanclass="math inline">\(p(X|Z),p(Z|X)\)</span>都是gaussian分布</p><p>在<spanclass="math inline">\(p(X)\)</span>满足gaussian分布时，该问题存在一个解。但是当<spanclass="math inline">\(p(X)\)</span>不满足gaussion分布的时候，以上命题应该是不成立的。这一点我之后应该会补充。</p><p>总之，我们发现，VAE的假设的合理性其实是依靠输入数据<spanclass="math inline">\(p(X)\)</span>的分布类型的，这并不是非常合理，应该也是其生成图像较模糊的原因。以一个gaussion分布来近似一个未知分布，就像以椭圆去拟合矩形，椭圆再怎么样也只有两个参数，拟合能力终究有限。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SGD收敛性学习笔记</title>
    <link href="/posts/5d8a3079/"/>
    <url>/posts/5d8a3079/</url>
    
    <content type="html"><![CDATA[<p>之前就对sgd的看似无脑的贪心策略感到十分新奇，为什么每次随机用一个子集的梯度来更新就可以近似整体的梯度？正好最近重新实现了一遍sgd，就顺便补一下它的理论证明。</p><h1 id="准备工作">准备工作</h1><p>不妨假设我们模型的损失函数为<spanclass="math inline">\(L(x,\theta)\)</span>,其中<spanclass="math inline">\(x\)</span>是训练数据，<spanclass="math inline">\(\theta\inR^d\)</span>是模型参数，一般来说我们优化的目标是找到最优的<spanclass="math inline">\(\theta^*\)</span>使得<spanclass="math inline">\(L(x,\theta^*)\)</span>最小，也就是 <spanclass="math display">\[\theta^* = argmin_{\theta\in R^d} L(x,\theta)\]</span> 随机梯度下降(SGD)的策略是每次随机取数据<spanclass="math inline">\(x\)</span>的一个子集，我们不妨将第<spanclass="math inline">\(t\)</span>次取出的子集记为<spanclass="math inline">\(x^t\)</span>,那么更新方式为 <spanclass="math display">\[\theta^{t+1} = \theta^t - \eta^tg(x^t,\theta^t)\]</span> 其中<span class="math inline">\(\eta^t\)</span>表示第<spanclass="math inline">\(t\)</span>次更新的学习率，<spanclass="math inline">\(g(x^t,\theta^t) = \nabla_\thetaL(x^t,\theta)\)</span>表示损失函数关于参数<spanclass="math inline">\(\theta\)</span>的梯度。</p><p>我们当然可以直接写出<spanclass="math inline">\(\theta^t\)</span>的通项为 <spanclass="math display">\[\theta^t = \theta^1-\sum_{s=1}^{t-1} \eta^sg(x^s,\theta^s)\]</span> 当然这么看的话似乎很难说明参数<spanclass="math inline">\(\theta\)</span>会收敛，更别说收敛到<spanclass="math inline">\(\theta^*\)</span>了。所以我们尝试制定一个评价指标。</p><p>那么我们要如何评价这个策略？一个比较合理的目标是最小化 <spanclass="math display">\[L(T) = \frac{1}{T}\sum_{t=1}^{T}L(x^t,\theta^t)\]</span> 其中<spanclass="math inline">\(T\)</span>表示我们的迭代总轮数</p><p>又注意到<spanclass="math inline">\(L(T)\)</span>的最小值我们可以表示为<spanclass="math inline">\(L(T)&#39; =\frac{1}{T}\sum_{t=1}^{T}L(x^t,\theta^*)\)</span>那么我们的评价指标可以选择为 <span class="math display">\[\frac{1}{T}\sum_{t=1}^{T}L(x^t,\theta^t)-\frac{1}{T}\sum_{t=1}^{T}L(x^t,\theta^*)=\frac{1}{T}R(T)\\ \ \ \ \ (1)\]</span> 其中 <span class="math display">\[R(T)=\sum_{t=1}^{T}L(x^t,\theta^t)-\sum_{t=1}^{T}L(x^t,\theta^*)\]</span> 被称为"regret"</p><p>当 <span class="math display">\[\lim_{T\rightarrow \infty}\frac{1}{T}R(T)=0\]</span> 时，我们就可以说这个策略确实是收敛的，参数<spanclass="math inline">\(\theta\rightarrow\theta^*\)</span>,也就是说，它不仅收敛，而且收敛于最优参数<spanclass="math inline">\(\theta^*\)</span></p><h1 id="证明过程">证明过程</h1><p>现在我们考虑对<spanclass="math inline">\((1)\)</span>式的收敛性进行证明。不过在此之前，我们需要假设对于任意的<spanclass="math inline">\(t,x^t\)</span>,损失函数<spanclass="math inline">\(L(x^t,\theta)\)</span>都是关于<spanclass="math inline">\(\theta\)</span>的convex函数，也就是说，<spanclass="math inline">\(\forall \theta^i,\theta^j\)</span>,都有 <spanclass="math display">\[L(x^t,\theta^i)-L(x^t,\theta^j)\geq (\theta^i-\theta^j)\cdotg(x^t,\theta^j)\ \ \ \ \ (2)\]</span> 其中<span class="math inline">\(\cdot\)</span>表示向量内积</p><p>现在我们就可以正式开始证明了！</p><p>想要证明<spanclass="math inline">\((1)\)</span>式收敛于0，一个常见的办法就是为其找一个关于<spanclass="math inline">\(T\)</span>的上界<spanclass="math inline">\(f(T)\)</span>，如果<spanclass="math inline">\(f(T)\rightarrow 0,T\rightarrow\infty\)</span>的话，结论就得证了。</p><p>利用<span class="math inline">\((2)\)</span>式，我们现在就能为<spanclass="math inline">\(R(T)\)</span>找一个上界 <spanclass="math display">\[\begin{flalign}R(T)&amp;=\sum_{t=1}^{T}L(x^t,\theta^t)-\sum_{t=1}^{T}L(x^t,\theta^*)\\&amp;=\sum_{t=1}^{T}(L(x^t,\theta^t)-L(x^t,\theta^*))\\&amp;\leq \sum_{t=1}^{T}(\theta^t-\theta^*)\cdot g(x^t,\theta^t)\end{flalign}\]</span> 最后一个不等号由<spanclass="math inline">\((2)\)</span>式变形之后即得</p><p>为了后面方便区分内积与数乘，我们将上式重新表述如下 <spanclass="math display">\[R(T)\leq \sum_{t=1}^{T}\left \langle \theta^t-\theta^*,g(x^t,\theta^t)\right \rangle \ \ \ \ \ (3)\]</span> 接下来尝试为不等式右端找到替代，这一点可以从SGD的迭代公式出发<span class="math display">\[\begin{flalign}\theta^{t+1} &amp;= \theta^t - \eta^tg(x^t,\theta^t)\\\theta^{t+1}-\theta^* &amp;= \theta^t-\theta^*-\eta^tg(x^t,\theta^t)\\\left \| \theta^{t+1}-\theta^* \right \|^2 &amp;= \left \|\theta^t-\theta^*-\eta^tg(x^t,\theta^t) \right \|^2 \\\left \| \theta^{t+1}-\theta^* \right \|^2 &amp;= \left \|\theta^{t}-\theta^* \right \|^2 +(\eta^t)^2 \left \| g(x^t,\theta^t)\right \|^2 -2\eta^t \left \langle\theta^t-\theta^*,\eta^tg(x^t,\theta^t) \right \rangle\\\end{flalign}\]</span> 从而 <span class="math display">\[\left \langle \theta^t-\theta^*,\eta^tg(x^t,\theta^t) \right \rangle =\frac{1}{2\eta^t} \left [   \left \| \theta^{t}-\theta^* \right \|^2-\left \| \theta^{t+1}-\theta^* \right \|^2  \right ] + \frac{\eta^t}{2}\left \| g(x^t,\theta^t) \right \|^2\]</span> 代入<span class="math inline">\((3)\)</span>式，我们就有 <spanclass="math display">\[R(T)\leq \underbrace{\sum_{t=1}^{T} \frac{1}{2\eta^t} \left [   \left \|\theta^{t}-\theta^* \right \|^2 -\left \| \theta^{t+1}-\theta^* \right\|^2  \right ] }_{(a)}+ \underbrace{\sum_{t=1}^{T} \frac{\eta^t}{2}\left \| g(x^t,\theta^t) \right \|^2}_{(b)}\]</span> 我们先来看第一部分<span class="math inline">\((a)\)</span><span class="math display">\[\begin{flalign}(a) &amp;= \sum_{t=1}^{T} \frac{1}{2\eta^t} \left [   \left \|\theta^{t}-\theta^* \right \|^2 -\left \| \theta^{t+1}-\theta^* \right\|^2  \right ]\\&amp;= \frac{1}{2\eta^1} \left [   \left \| \theta^{1}-\theta^* \right\|^2 -\left \| \theta^{2}-\theta^* \right \|^2  \right ] + ... +\frac{1}{2\eta^T} \left [   \left \| \theta^{T}-\theta^* \right \|^2-\left \| \theta^{T+1}-\theta^* \right \|^2  \right ]\\&amp;= \frac{1}{2\eta^1}\left \| \theta^{1}-\theta^* \right\|^2-\frac{1}{2\eta^T}\left \| \theta^{T+1}-\theta^* \right \|^2 +\sum_{t=2}^{T} \left \| \theta^{t}-\theta^* \right\|^2(\frac{1}{2\eta^t}-\frac{1}{2\eta^{t-1}})\end{flalign}\]</span> 这里我们还需要添加几个假设</p><ul><li><spanclass="math inline">\(\eta_t\)</span>序列是单调不递增的，即<spanclass="math inline">\(\eta^{t+1}\geq \eta^t,\forall t\geq1\)</span></li><li><span class="math inline">\(D = max\{\left \| \theta^{t}-\theta^*\right \|\}&lt;\infty\)</span></li></ul><p>第一点其实比较好理解，因为我们在实际训练的过程中也是保证学习率逐渐变小的，第二点在大部分情况下其实也是成立的。</p><p>从而 <span class="math display">\[\begin{flalign}(a)&amp;\leq \frac{1}{2\eta^1}D^2 + \sum_{t=2}^{T}D^2(\frac{1}{2\eta^t}-\frac{1}{2\eta^{t-1}})\\&amp;=\frac{1}{2\eta^1}D^2 +D^2(\frac{1}{2\eta^T}-\frac{1}{2\eta^{1}})\\&amp;= \frac{D^2}{2\eta^T}\end{flalign}\]</span> 再来看看第二部分 <span class="math display">\[(b) = \sum_{t=1}^{T} \frac{\eta^t}{2} \left \| g(x^t,\theta^t) \right\|^2\]</span> 我们做与上一部分类似的假设 <span class="math display">\[G = max{\left \| g(x^t,\theta^t) \right \|^2}&lt;\infty\]</span> 从而 <span class="math display">\[(b)\leq \sum_{t=1}^{T}\frac{G^2}{2}\eta^t =\frac{G^2}{2}\sum_{t=1}^{T}\eta^t\]</span> 最终我们得到下式 <span class="math display">\[R(T)=\sum_{t=1}^{T}L(x^t,\theta^t)-\sum_{t=1}^{T}L(x^t,\theta^*)\leq\frac{D^2}{2\eta^T} + \frac{G^2}{2}\sum_{t=1}^{T}\eta^t\ \ \ \ \ (4)\]</span> 如果我们将上界取高的话，<spanclass="math inline">\(D,G\)</span>完全可以视作常数，从而右式就是一个只跟学习率<spanclass="math inline">\(\eta^t\)</span>有关的式子了</p><p>我们没能做到一开始期望的将右式处理成只跟T有关，事实上这也不太现实。不过只跟<spanclass="math inline">\(\eta^t\)</span>有关的话，这也意味着只要我们的学习率策略取的足够好，使得右式关于T的最高阶小于1，那么SGD的收敛性就还是存在的。</p><p>例如，如果我们取学习率为<span class="math inline">\(C\cdott^{-1/2}\)</span>,其中<spanclass="math inline">\(C&gt;0\)</span>为常数，那么 <spanclass="math display">\[\begin{flalign}R(T)&amp;\leq \frac{D^2\sqrt{T}}{2C} +\frac{CG^2}{2}\sum_{t=1}^{T}\frac{1}{\sqrt{t}}\\&amp;\leq  \frac{D^2\sqrt{T}}{2C} +\frac{CG^2}{2}\sum_{t=1}^{T}\frac{2}{\sqrt{t-1}+\sqrt{t}}\\&amp;\leq \frac{D^2\sqrt{T}}{2C} +\frac{CG^2}{2}\sum_{t=1}^{T}2(\sqrt{t}-\sqrt{t-1})\\&amp;\leq \frac{D^2\sqrt{T}}{2C} + CG^2\sqrt{T}\end{flalign}\]</span> 从而 <span class="math display">\[\frac{1}{T}R(T) \leq \frac{D^2}{2C\sqrt{T}} + \frac{CG^2}{\sqrt{T}}\]</span></p><p>而如果将学习率取为常数<spanclass="math inline">\(\eta\)</span>的话，<spanclass="math inline">\((4)\)</span>式右端为 <span class="math display">\[\frac{D^2}{2\eta^T} + \frac{G^2}{2}\sum_{t=1}^{T}\eta^t =\frac{D^2}{2\eta} + \frac{G^2}{2}T\eta\geq \frac{DG\sqrt{T}}{2}\]</span> 从而当学习率<span class="math inline">\(\eta\)</span>取为<spanclass="math inline">\(\frac{D}{D\sqrt{T}}\)</span>时，有 <spanclass="math display">\[\frac{1}{T}R(T)\leq \frac{DG}{2\sqrt{T}}\]</span> 可以看到两者都是<spanclass="math inline">\(O(\frac{1}{\sqrt{T}})\)</span>级别的，当<spanclass="math inline">\(T\rightarrow \infty\)</span>时，都是能收敛的。</p><p>当然我们也能看出来，当学习率取的不好的时候，<spanclass="math inline">\(R(T)\)</span>的上界可能会非常松，那么所谓收敛性也就无从谈起了。</p><h1 id="实验">实验</h1><p><spanclass="math inline">\((4)\)</span>式与学习率的关系如此紧密，这也难怪SGD这种方法会对超参数如此敏感。本人简单做了一个不同学习率下的对比实验，学习率都设置为常数，可以看到不同情况下loss的下降曲线差异也是很大的。</p><p><img src="https://s2.loli.net/2024/07/25/NPQJ7uIa6xTpRy9.png" alt="image-20240725154036553" style="zoom:50%;" /></p><p>同时做了另一组，学习率取为<spanclass="math inline">\(Ct^{-1/2}\)</span>,结果为</p><p><img src="https://s2.loli.net/2024/07/25/ySD13pCLmI6AuHb.png" alt="image-20240725155002436" style="zoom:50%;" /></p><p>可以看到学习率取常数的话，最终的loss普遍是要比取<spanclass="math inline">\(Ct^{-1/2}\)</span>要好的，这一点从上面的分析中也许可以解释一下：前者的理论上界为<spanclass="math inline">\(\frac{DG}{2\sqrt{T}}\)</span>,而后者的理论上界为<spanclass="math inline">\(\frac{D^2}{2C\sqrt{T}} +\frac{CG^2}{\sqrt{T}}\)</span>,是要更大的</p><p>但是取常数貌似受随机性的影响会更大</p><p>以及学习率如果过小的话，loss下降速度也会受到影响，对应的最终的loss仿佛也会偏高。</p><p>以上是笔者作为初学者的一些探究，或许在之后的学习过程中能找到更加合理的解释。如果文章有错误的话也欢迎指教。</p><h1 id="总结">总结</h1><p>我们证明了SGD在一定的假设下确实可以收敛，这些假设为：</p><ul><li>损失函数<span class="math inline">\(L(x^t,\theta^t),\forall t\geq1\)</span>关于<spanclass="math inline">\(\theta\)</span>是convex函数</li><li>学习率<spanclass="math inline">\(\eta_t\)</span>序列是单调不递增的，即<spanclass="math inline">\(\eta^{t+1}\geq \eta^t,\forall t\geq1\)</span>，非常合理</li><li><span class="math inline">\(D = max\{\left \| \theta^{t}-\theta^*\right\|\}&lt;\infty\)</span>，实际上它要求参数位于线性空间的一个有界集合内</li><li><span class="math inline">\(G = max{\left \| g(x^t,\theta^t) \right\|^2}&lt;\infty\)</span>，也就是梯度有界</li></ul><p>其余诸如损失函数可导等条件略过。</p><p>证明的重要一环便是<span class="math inline">\((1)\)</span>式 <spanclass="math display">\[\frac{1}{T}\sum_{t=1}^{T}L(x^t,\theta^t)-\frac{1}{T}\sum_{t=1}^{T}L(x^t,\theta^*)=\frac{1}{T}R(T)\]</span>它衡量了实际迭代过程与理论最优过程的差距，在学习率的选择上我们或许也可以以最小化这个式子的理论上界为目标。当然这只是加了很多假设的理论分析，实操不见得有效。</p><p>最终得到在给定假设下上式的理论上界为 <span class="math display">\[\frac{1}{T}R(T)=\sum_{t=1}^{T}\frac{1}{T}L(x^t,\theta^t)-\frac{1}{T}\sum_{t=1}^{T}L(x^t,\theta^*)\leq\frac{D^2}{2T\eta^T} + \frac{G^2}{2T}\sum_{t=1}^{T}\eta^t\]</span> 感觉还是很有收获的！</p><h1 id="参考文献">参考文献</h1><p>[1] M. Zinkevich, “Online convex programming and generalizedinfinitesimal gradient ascent,” in Proceedings of the 20th internationalconference on machine learning (ICML-03), 2003, pp. 928– 936.</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Reparameterization-Trick</title>
    <link href="/posts/9c7e35cb/"/>
    <url>/posts/9c7e35cb/</url>
    
    <content type="html"><![CDATA[<p>之前在学蒸馏的时候接触了gumbel-softmax，顺势了解了一下重参数技巧，还是很有意思的一个东西</p><h1 id="引入">引入</h1><p>重参数技巧主要是尝试对这样形式的一个东西<strong>求梯度</strong> <spanclass="math display">\[\large L_{\theta} = E_{z\sim p_{\theta}(z)}[f_{\theta}(z)] \quad\quad(1)\]</span> 其中<span class="math inline">\(z\simp_{\theta}(z)\)</span>表示随机变量<spanclass="math inline">\(z\)</span>服从概率密度函数<spanclass="math inline">\(p_{\theta}(z)\)</span>,<strong>显然这个密度函数是跟模型参数<spanclass="math inline">\(\theta\)</span>有关的</strong>；<spanclass="math inline">\(f_{\theta}(z)\)</span>一般可以表示模型某一层关于变量<spanclass="math inline">\(z\)</span>的输出,显然它也跟模型参数<spanclass="math inline">\(\theta\)</span>有关</p><p>不妨先来想想这个式子要如何处理。一个非常naive的思路：采样估计。但是如果直接采样的话，每次采样我们只能获得<spanclass="math inline">\(\nabla_\thetaf_\theta(z)\)</span>,而不同样本之间的信息是无法共用的，我们也就无从得到<spanclass="math inline">\(\nabla_\thetaL_\theta\)</span>。所以我们想想看，有没有什么好的处理方法，能在估计出<spanclass="math inline">\((1)\)</span>式的同时还能保留梯度信息</p><p>不妨先来做一个简化，我们先假设<spanclass="math inline">\(p_{\theta}(z)\)</span>是一个跟<spanclass="math inline">\(\theta\)</span>无关的概率密度函数，简记为<spanclass="math inline">\(p(z)\)</span>,我们很快注意到现在是可以采样估计梯度了：<span class="math display">\[\begin{flalign}\nabla_{\theta} L_{\theta} &amp;= \nabla_{\theta}E_{z\simp(z)}[f_{\theta}(z)] = \nabla_{\theta}[\int_z p(z)f_{\theta}(z)dz]\\&amp;=\int_z p(z)\nabla_{\theta}f_{\theta}(z)dz\\&amp;=E_{z\sim p(z)}[\nabla_{\theta}f_{\theta}(z)]\end{flalign}\]</span> 从而 <span class="math display">\[\large \nabla_{\theta} L_{\theta} \approx \frac{1}{n}\sum_{i=1}^{n}\nabla_{\theta}f_{\theta}(z_i),z_i\sim p(z)\]</span> 这是因为求梯度的操作成功转移到了<spanclass="math inline">\(f_\theta(z)\)</span>上面上述过程可以用一句话来总结：期望的梯度等于梯度的期望</p><p>那我们回到<spanclass="math inline">\(p_\theta(z)\)</span>,并尝试类似的步骤： <spanclass="math display">\[\large \begin{flalign}\nabla_{\theta} L_{\theta} &amp;= \nabla_{\theta}E_{z\simp_\theta(z)}[f_{\theta}(z)] = \nabla_{\theta}[\int_zp_\theta(z)f_{\theta}(z)dz]\\&amp;=\int_z p_\theta(z)\nabla_{\theta}f_{\theta}(z)dz+\int_z\nabla_{\theta}p_\theta(z)f_{\theta}(z)dz\\&amp;=E_{z\simp_\theta(z)}[\nabla_{\theta}f_{\theta}(z)]+\underbrace{\int_z\nabla_{\theta}p_\theta(z)f_{\theta}(z)dz}_{???}\end{flalign}\]</span>前面一块还是可以仿照之前的处理的，但是后者就显得比较诡异了，求梯度操作转移到<spanclass="math inline">\(p_\theta(z)\)</span>上面去，也就意味着我们无法将其整理成正常的关于某个东西的期望的形式。或许我们可以将<spanclass="math inline">\(\nabla_{\theta}p_\theta(z)\)</span>求出来，但在大部分情况下这是不现实的。</p><p>此时就可以引入重参数技巧了</p><h1 id="重参数">重参数</h1><p>顾名思义，我们需要引入新的参数来处理上述问题： 考虑一个新的无参数分布<span class="math display">\[\large \epsilon\sim{q(\epsilon)}\]</span> 以及变换 <span class="math display">\[\large z = g_\theta(\epsilon)\]</span> 保证变换之后得到的<spanclass="math inline">\(z\)</span>服从<spanclass="math inline">\(p_\theta\)</span> 那么对<spanclass="math inline">\((1)\)</span>式求梯度可以变成： <spanclass="math display">\[\large \begin{flalign}\nabla_{\theta} L_{\theta} &amp;= \nabla_{\theta}E_{z\simp_\theta(z)}[f_{\theta}(z)] \\&amp;= E_{\epsilon\sim q(\epsilon)}[f_\theta(g_\theta(\epsilon))]\quad\quad (a)\\&amp;=E_{\epsilon\simq(\epsilon)}[\nabla_{\theta}f_\theta(g_\theta(\epsilon))]\ \ \ (b)\end{flalign}\]</span> 从而 <span class="math display">\[\large \nabla_{\theta} L_{\theta} \approx \frac{1}{n}\sum_{i=1}^{n}\nabla_{\theta}f_\theta(g_\theta(\epsilon_i)),\epsilon_i\sim q(\epsilon)\]</span></p><p>我们就成功实现了在采样的同时保持了梯度</p><p>注意，在这个过程中最重要的一步转化就是： <spanclass="math display">\[\large L_\theta = E_{\epsilon\simq(\epsilon)}[f_\theta(g_\theta(\epsilon))]\]</span> 它将随机性从参数<spanclass="math inline">\(\theta\)</span>转移到了内部无参数的<spanclass="math inline">\(\epsilon\)</span>上面，从而可以利用我们之前讨论过的对无参数分布（或者说无可变参数）而言成立的“期望的梯度等于梯度的期望”这一性质来处理</p><h2 id="例子">例子</h2><p>不妨就取<spanclass="math inline">\(p_\theta(z)\)</span>是一个正态分布，即 <spanclass="math display">\[\large p_\theta(z) = N(\mu_\theta,\sigma_\theta^2)\]</span> 那么<spanclass="math inline">\(q(\epsilon)\)</span>我们就取标准正态分布 <spanclass="math display">\[\large q(\epsilon) = N(0,1)\]</span> 那么显然有 <span class="math display">\[\large \sigma_\theta\epsilon+\mu_\theta \simN(\mu_\theta,\sigma_\theta^2)\]</span> 所以我们就取 <span class="math display">\[\large g_\theta(\epsilon) = \sigma_\theta\epsilon+\mu_\theta\]</span> 最后有 <span class="math display">\[\large E_{z\sim N(\mu_\theta,\sigma_\theta^2)}[f_{\theta}(z)] =E_{\epsilon\sim N(0,1)}[f_\theta(\sigma_\theta\epsilon+\mu_\theta)]\]</span></p><h1 id="离散情况的重参数处理">离散情况的重参数处理</h1><p>上述过程处理的是分布为连续密度函数的情况，但我们也经常遇到离散分布的情况，这种该如何处理？为做区分，我们换一种写法： <span class="math display">\[\large L_{\theta} = E_{y\sim p_{\theta}(y)}[f_{\theta}(y)] =\sum_{y}p_\theta(y)f_\theta(y) \quad \quad (2)\]</span> 一般来说，此时<spanclass="math inline">\(y\)</span>是可枚举的，它在大部分情况下都对应了一个k分类问题，也就是说，<spanclass="math inline">\(y\)</span>可以表示为 <span class="math display">\[\large p_\theta(y) = softmax(o_1,o_2,...o_k)_y = \frac{1}{\sume^{o_i}}e^{o_y}\quad \quad(3)\]</span> 其中<spanclass="math inline">\(o_i\)</span>一般就是模型的logits，它当然也是关于参数<spanclass="math inline">\(\theta\)</span>的函数</p><p>还是同一个问题，<spanclass="math inline">\((2)\)</span>式直接用求和的形式是没法计算梯度的，我们还是得试试重参数方法。</p><p>所以现在问题就变成了： &gt;找到一个合适的无参数分布<spanclass="math inline">\(q(\epsilon)\)</span>以及对应的变换<spanclass="math inline">\(g_\theta(\epsilon)\)</span>保证它服从<spanclass="math inline">\(p_\theta\)</span>这个分布</p><p>事实上也确实已经有对应的成果了，它叫做</p><h2 id="gumbel-max">Gumbel Max</h2><p>取 <span class="math display">\[\large \epsilon\sim U(0,1)\]</span> 对应的<spanclass="math inline">\(q_{\theta}(\epsilon)\)</span>为： <spanclass="math display">\[\large argmax_i(log p_i-log(-log \epsilon_i))_{i=1}^{k}\quad \quad (4)\]</span> 这里第<spanclass="math inline">\(p_{\theta}(i)\)</span>简记为<spanclass="math inline">\(p_i\)</span>了 我们只需证明<spanclass="math inline">\((3)\)</span>式与<spanclass="math inline">\((4)\)</span>式是同一个分布，即<spanclass="math inline">\((4)\)</span>式输出数字<spanclass="math inline">\(i\)</span>的概率为<spanclass="math inline">\(p_i\)</span></p><p>不失一般性地，我们考虑<spanclass="math inline">\((4)\)</span>式输出数字1的概率： 此时意味着<spanclass="math inline">\(log p_1-log(-log \epsilon_1)\)</span>是<spanclass="math inline">\(1-k\)</span>中最大的，即 <spanclass="math display">\[\large log p_1-log(-log \epsilon_1)\geq log p_i-log(-log \epsilon_i),\forall i\in (1,k]\]</span> 得到 <span class="math display">\[\large \epsilon_i\leq \epsilon_1^{p_i/p_1}\leq 1,\forall i\in (1,k]\]</span> 又<span class="math inline">\(e_i\sim U(0,1)\)</span>,从而<span class="math display">\[\large P(\epsilon_i\leq\epsilon_1^{p_i/p_1})=\epsilon_1^{p_i/p_1},\forall i\in (1,k]\]</span> 从而<span class="math inline">\((4)\)</span>式输出1的概率为<span class="math display">\[\large P(\epsilon_2\leq \epsilon_1^{p_2/p_1},\epsilon_3\leq\epsilon_1^{p_3/p_1},...\epsilon_k\leq \epsilon_1^{p_k/p_1}) =\prod_{i=2}^{k}\epsilon_1^{p_i/p_1}=\epsilon_1^{(1-p_1)/p_1}\]</span> 对<spanclass="math inline">\(\epsilon_1\)</span>的所有情况求个平均，得到 <spanclass="math display">\[\large \int_0^1 \epsilon_1^{(1-p_1)/p_1}d\epsilon_1 = p_1\]</span> 这就是<spanclass="math inline">\((4)\)</span>式输出1的概率，它恰好为<spanclass="math inline">\(p_1\)</span> 从而我们证明了<spanclass="math inline">\((4)\)</span>式与<spanclass="math inline">\((3)\)</span>式确实是同分布，所以我们就成功找到了合理的无参数分布<spanclass="math inline">\(q(\epsilon)\)</span>以及对应的变换<spanclass="math inline">\(g_\theta(\epsilon)\)</span> <spanclass="math inline">\(\square\)</span>那么所有过程似乎到这里就圆满结束了。</p><p><strong>但是</strong>！但是，这里还是有点问题：<font color='red'>argmax这个运算本身也是无法求导的...</font>也就是说，我们将求梯度运算转移到了<spanclass="math inline">\(argmax\)</span>运算上面，结果它还是没有办法求梯度？不过没关系，这一步其实并不是很难处理。我们知道<spanclass="math inline">\(argmax\)</span>其实可以扩展成<spanclass="math inline">\(one\_hot(argmax)\)</span>,而后者的一个光滑近似就是<spanclass="math inline">\(softmax\)</span>:对于这一点，我相信接触过蒸馏的同学肯定是很清楚的，我们只需要调整蒸馏的温度就能使得<spanclass="math inline">\(softmax\)</span>无限趋近于<spanclass="math inline">\(ont\_hot\)</span> 而<spanclass="math inline">\(softmax\)</span>显然是可以求梯度的，我们就顺利解决了这个遗留的问题。这种策略被称为</p><p>​</p><h2 id="gumbel-softmax">Gumbel Softmax</h2><p>具体来说，我们的<spanclass="math inline">\(g_\theta(\epsilon)\)</span>要改成： <spanclass="math display">\[\large softmax_i((log p_i-log(-log \epsilon_i))/\tau)_{i=1}^{k}\quad\quad (5)\]</span> 其中<spanclass="math inline">\(\tau\)</span>就是蒸馏的温度，当<spanclass="math inline">\(\tau\rightarrow 0\)</span>的时候，<spanclass="math inline">\(softmax\)</span>就可以看成<spanclass="math inline">\(ont\_hot\)</span>,当然此时梯度消失现象也会很严重。由此我们也可以得到训练策略：对参数<spanclass="math inline">\(\tau\)</span>进行退火，最后得到接近于<spanclass="math inline">\(ont\_hot\)</span>形式对应的结果。常见的一个退火策略为：<span class="math display">\[\large \tau_p = \tau_0(\tau_p/\tau_0)^{p/P}\]</span> 其中<span class="math inline">\(\tau_p\)</span>是第<spanclass="math inline">\(p\)</span>次训练的温度，<spanclass="math inline">\(\tau_0\)</span>是初始温度，<spanclass="math inline">\(P\)</span>是总轮数。</p><hr /><p>总结一下，对于总体的<spanclass="math inline">\(k\)</span>个情况，我们从0到1的均匀分布中取<spanclass="math inline">\(k\)</span>个值，利用Gumbel softmax得到一个<spanclass="math inline">\(k\)</span>维向量<spanclass="math inline">\(\tilde{p}\)</span>, 那么 <spanclass="math display">\[\sum_y \tilde{p}_yf_\theta(y)\]</span> 就是<spanclass="math inline">\(L_\theta\)</span>的一个良好估计，并且它成功保留了梯度信息</p><p>需要指出的是，Gumbel Max是原式的等价形式，但是GumbelSoftmax并不是，它是Gumbel Max的一个光滑近似，当<spanclass="math inline">\(\tau\)</span>足够小的时候，它可以近似看成GumbelMax</p><p>顺便提一嘴这个东西为啥叫<strong>Gumbel</strong> Max/Softmax:</p><p>我们仔细观察<span class="math inline">\((5)\)</span>式： <spanclass="math display">\[\large softmax_i((log p_i-log(-log \epsilon_i))/\tau)_{i=1}^{k}\]</span> 按照原本的思路，我们可以先从均匀分布里采样<spanclass="math inline">\(\epsilon\)</span>，然后再做log运算，再做log运算，再与<spanclass="math inline">\(logp_i\)</span>做差，不过实际上实际从一个<spanclass="math inline">\(-log(-log\epsilon)\)</span>服从的分布里直接采样也是完全OK的，那我们就来看看这个分布长什么样子：记 <span class="math display">\[x = -log(-log \epsilon)\]</span> 那么 <span class="math display">\[F_X(x) = P_X(X\leq x) = P_\epsilon(-log(-log \epsilon)\leq x) =P_\epsilon(\epsilon\leq e^{-e^{-x}}) = F_\epsilon(e^{-e^{-x}})\]</span> 从而 <span class="math display">\[F_X(x) = exp(-exp(-x))\]</span>这就是这个分布的累积分布函数，它就被称为<strong>Gumbel分布</strong>。实际上Gumbel分布还带有另外两个参数<span class="math display">\[F_X(x,\mu,\beta) = exp(-exp(-\frac{x-\mu}{\beta}))\]</span> 也就是说这里是<spanclass="math inline">\(\mu=\beta=0\)</span>的特殊情况。不过这一点不必细讲，感兴趣的读者可以再去了解一下。</p><p>最后讲一个实现细节： 在求原分布<spanclass="math inline">\(q_\theta\)</span>的时候，我们需要从<spanclass="math inline">\(\{o_i\}\)</span>出发做softmax得到<spanclass="math inline">\(\{p_i\}\)</span>,但是实际上<spanclass="math inline">\((5)\)</span>式可以直接替换为 <spanclass="math display">\[\large softmax_i((o_i-log(-log \epsilon_i))/\tau)_{i=1}^{k}\]</span> 那么我们就不必去做softmax了 至于证明其实也很简单： <spanclass="math display">\[\large log p_i = log(softmax(o_i)) = log(\frac{e^{o_i}}{\sum_j e^{o_j}})\]</span> 从而 <span class="math display">\[logp_i = o_i-C\]</span> 从而 <span class="math display">\[softmax((logp_i+g_i)/\tau) = \frac{e^{(logp_i+g_i)/\tau}}{\sum_je^{(logp_j+g_j)/\tau}} = \frac{e^{(o_i-C+g_i)/\tau}}{\sum_je^{(o_j-C+g_j)/\tau}}\]</span> 显然可以将常数<spanclass="math inline">\(C\)</span>对应的部分提出来 <spanclass="math display">\[= \frac{e^{(o_i+g_i)/\tau}}{\sum_j e^{(o_j+g_j)/\tau}} =softmax((o_i+g_i)/\tau)\]</span> 这里<spanclass="math inline">\(g_i\)</span>就指之前讲的Gumbel分布</p><h1 id="总结">总结</h1><p>以上就是重参数在连续和离散两个场景的应用了，它最初也是最多的应用应该是在VAE里面，我以后应该也会接触，到时候也许会对这篇文章加以补充。</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dilworth 定理</title>
    <link href="/posts/a37c8172/"/>
    <url>/posts/a37c8172/</url>
    
    <content type="html"><![CDATA[<h2 id="偏序集">偏序集</h2><p>偏序集是由集合<spanclass="math inline">\(S\)</span>以及其上的一个偏序关系<spanclass="math inline">\(R\)</span>定义的，记为<spanclass="math inline">\((S,R)\)</span></p><h3 id="偏序关系">偏序关系：</h3><p>对于一个二元关系<span class="math inline">\(R\subset S\timesS\)</span>,如果其满足： * <span class="math inline">\(\forall x\inS,xRx\)</span> <strong>自反性</strong> * <spanclass="math inline">\(\forall x,y\in S\)</span>,若<spanclass="math inline">\(xRy\)</span>且<spanclass="math inline">\(yRx\)</span>,则<spanclass="math inline">\(x=y\)</span> <strong>反对称性</strong> * <spanclass="math inline">\(xRy,yRz\rightarrow xRz\)</span><strong>传递性</strong> 显然自然数集<spanclass="math inline">\(N\)</span>以及最常见的小于等于关系<spanclass="math inline">\(\leq\)</span>,<spanclass="math inline">\((N,\leq)\)</span>就构成了一个偏序集 事实上<spanclass="math inline">\((N^*,|)\)</span>也是一个偏序集，其中<spanclass="math inline">\(|\)</span>表示正整数的整除关系</p><p>以下为了讨论方便，我们将<spanclass="math inline">\(R\)</span>简记为<spanclass="math inline">\(\leq\)</span>,当然它可以指代小于等于关系之外的其它关系</p><p>此外，<span class="math inline">\(\forall x,y\in S\)</span>,如果<spanclass="math inline">\(x\leq y\)</span>或<spanclass="math inline">\(y\leqx\)</span>，那么我们就说它们是<strong>可比</strong>的，否则说它们是<strong>不可比</strong>的</p><p>定义完了偏序集，我们可以从图上来看看它具体的样子</p><h2 id="哈斯图hasse-图">哈斯图(Hasse 图)</h2><p>考虑一个偏序集<span class="math inline">\((S,\leq)\)</span>,<spanclass="math inline">\(\forall x,y\in S\)</span>,如果<spanclass="math inline">\(x\leq y\)</span>且不存在<spanclass="math inline">\(z\ S.T. \ x\leq z\leq y\)</span>,我们称为<spanclass="math inline">\(y\)</span>覆盖<spanclass="math inline">\(x\)</span>,那么此时我们就连一条从<spanclass="math inline">\(x\)</span>指向<spanclass="math inline">\(y\)</span>的有向边，最后得到的图就称为这个偏序集<spanclass="math inline">\((S,\leq)\)</span>的Hasse图</p><p>比如下图是<spanclass="math inline">\({x,y,z}\)</span>的幂集关于包含关系得到的Hasse图<img src="https://s2.loli.net/2024/05/24/RbtO1csLZlwU3me.png"alt="image.png|370" /></p><p>由于偏序关系满足了反对称性，所以Hasse图里面一定没有自环（否则就会合并成一个点），所以我们可以说<strong>Hasse图一定是一张DAG</strong></p><h2 id="其它偏序集的前置芝士">其它偏序集的前置芝士</h2><p>还是记我们要讨论的偏序集为<spanclass="math inline">\((S,\leq)\)</span></p><p><strong>链</strong>： 偏序集中的一个全序子集。形式化地说，若集合<spanclass="math inline">\(C\subset S\)</span>,且<spanclass="math inline">\(\forall a,b\in C\)</span>,<spanclass="math inline">\(a,b\)</span>是可比的，那么<spanclass="math inline">\(C\)</span>就是<spanclass="math inline">\(S\)</span>的一个链链这个名字起的就很有水平，因为我们不难发现，偏序集中的一个全序子集，其在Hasse图中<strong>似乎</strong>就一定表现为一条链。比如上图中的<spanclass="math inline">\(\{\{x,y,z\},\{x,z\},\{x\},\{\phi\}\}\)</span>就是一个全序子集，在图中刚好也表现成一条链。但我没有严格证明，这边搁置。类似地，我们定义一个反链 <strong>反链</strong>： 若集合<spanclass="math inline">\(C\subset S\)</span>,且<spanclass="math inline">\(\forall a,b\in C\)</span>,<spanclass="math inline">\(a,b\)</span>是不可比的，那么<spanclass="math inline">\(C\)</span>就是<spanclass="math inline">\(S\)</span>的一个反链 在图上看的话，<spanclass="math inline">\(\{\{x\},\{y\},\{z\}\}\)</span>就是一个反链</p><p><strong>深度</strong>: 最长链大小</p><p><strong>宽度</strong>： 最长反链大小</p><p>以上两个定义也是相当的形象。因为我们不难发现，如果把Hasse图按照偏序关系从低到高排列的话，链在图中往往就是一条竖着的，而反链是横着的，由此给出如上定义</p><p><strong>最小链划分</strong>： 将集合<spanclass="math inline">\(S\)</span>划分为最少的若干个不相交的链</p><p><strong>最小反链划分</strong>： 将集合<spanclass="math inline">\(S\)</span>划分为最少的若干个不相交的反链</p><h2 id="dilworth-定理">Dilworth 定理</h2><p>现在可以给出Dilworth 定理的具体内容了</p><blockquote><p>Lemma1对于任意<font color='red'>有限</font>偏序集，其<strong>最长反链大小</strong>必等于<strong>最小链划分中链的数目</strong>其对偶形式也成立： Lemma2对于任意<font color='red'>有限</font>偏序集，其<strong>最长链大小</strong>必等于其<strong>最小反链划分中反链的数目</strong></p></blockquote><p><strong>以下讨论均假定偏序集有限</strong></p><p>总结以下： 最小链划分 = 最长反链大小 = 偏序集宽度 最小反链划分 =最长链大小 = 偏序集深度</p><p><font color='green'>先来证Lemma2：</font></p><p>记定理中的最长链大小为n，我们对n做数学归纳法 显然n=1时定理成立若n=k时定理成立，我们来证 n=k+1时定理成立此时偏序集中的最长链长度为k+1,我们取出集合<spanclass="math inline">\(S\)</span>的所有极大元，组成集合<spanclass="math inline">\(M\)</span>,显然<spanclass="math inline">\(M\)</span>是一个反链，并且考虑<spanclass="math inline">\(S-M\)</span>,其最大链长一定为k（因为取出了所有的极大元），根据之前的归纳假设，<spanclass="math inline">\(S-M\)</span>的最小反链划分数目为k，再加上M自己是一个反链，从而此时S的最小反链划分数为 k+1 = 最长链长度<span class="math inline">\(\square\)</span></p><p><font color='green'>再来看Lemma1：</font></p><p>考虑偏序集<span class="math inline">\((S,\leq)\)</span>,记<spanclass="math inline">\(|S|=m\)</span>，我们对m进行归纳 <spanclass="math inline">\(m=1\)</span>时Lemma1显然成立 若<spanclass="math inline">\(m=k\)</span>时定理成立，我们来证<spanclass="math inline">\(m=k+1\)</span>时定理成立:</p><p>设<span class="math inline">\(A\)</span>是集合<spanclass="math inline">\(S\)</span>的一条最长反链，记为 <spanclass="math display">\[A = \{a_1,a_2,...a_w\}\]</span> 其中<span class="math inline">\(|A|=w\)</span> 我们取 <spanclass="math display">\[D(A) = \{x\notin A|\exists \alpha \in S,x\leq a\}\]</span> <span class="math display">\[U(A) = \{x\notin A|\exists \alpha \in S,a\leq x\}\]</span> 显然<span class="math inline">\(D(A)\bigcup U(A)\bigcup A =S\)</span></p><p>若存在最长反链<span class="math inline">\(A\)</span>使得<spanclass="math inline">\(D(A),U(A)\)</span>均非空： <spanclass="math inline">\(A\)</span>是<spanclass="math inline">\(S\)</span>的最长反链，故<spanclass="math inline">\(A\)</span>也是<span class="math inline">\(A\bigcupD(A)\)</span>的一个最长反链。注意到<spanclass="math inline">\(|U(A)|\geq 1\)</span>,故<spanclass="math inline">\(|A\bigcup D(A)|\leqk\)</span>，从而由归纳假设，<span class="math inline">\(A\bigcupU(A)\)</span>可以划分为<span class="math inline">\(w\)</span>条链<spanclass="math inline">\(c_1,c_2,...c_w\)</span>，其中<spanclass="math inline">\(c_i\)</span>的极大元是<spanclass="math inline">\(a_i\)</span>.(这一点显然) 同理，<spanclass="math inline">\(A\bigcup D(A)\)</span>也可以划分为<spanclass="math inline">\(w\)</span>条链<spanclass="math inline">\(d_1,d_2,...d_w\)</span>,其中<spanclass="math inline">\(d_i\)</span>的极小元是<spanclass="math inline">\(a_i\)</span> 从而，我们就可以将<spanclass="math inline">\(S\)</span>划分为<spanclass="math inline">\(w\)</span>条链：<spanclass="math inline">\(c_1\cup d_1,....c_w\cup d_w\)</span></p><p>若对于任意最长反链<span class="math inline">\(A\)</span>,都有<spanclass="math inline">\(D(A)=\phi\)</span>或<spanclass="math inline">\(U(A)=\phi\)</span> 由假设，任一条反链<spanclass="math inline">\(A\)</span>必定构成全上界或者全下界。在<spanclass="math inline">\(S\)</span>中选一个极大元<spanclass="math inline">\(y\)</span>,再选一个极小元<spanclass="math inline">\(x\)</span>满足<span class="math inline">\(x\leqy\)</span>,<span class="math inline">\(\{x,y\}\)</span>构成一条链<spanclass="math inline">\(C\)</span>,从而在集合<spanclass="math inline">\(S-C\)</span>中，任一条最长反链的大小为<spanclass="math inline">\(w-1\)</span>（必定去除了一个元素），从而根据归纳假设，<spanclass="math inline">\(S-C\)</span>的最小链划分数为<spanclass="math inline">\(w-1\)</span>,再加上<spanclass="math inline">\(C\)</span>自己是一条链，故<spanclass="math inline">\(S\)</span>的最小链划分数为<spanclass="math inline">\(w\)</span></p><p><span class="math inline">\(\square\)</span> ### 应用举例</p><p>求一个序列的最大非递增序列长度以及其最少可以划分为多少个非递增序列</p><p>考虑由(位置，元素大小)这个二元组组成的集合，再定义一个偏序关系<spanclass="math inline">\(&lt;\)</span>: <spanclass="math inline">\(a&lt;b\)</span>当且仅当 <spanclass="math inline">\(a\)</span>的位置&lt;<spanclass="math inline">\(b\)</span>的位置且<spanclass="math inline">\(a\)</span>的值<spanclass="math inline">\(&lt;b\)</span>的值</p><p>从而这就构成了一个偏序集<spanclass="math inline">\((s,&lt;)\)</span>,并且要求的分别就是集合的最长反链以及最小反链划分数第一个问题可以直接dp即可，第二个问题，根据Dilworth定理，实际上就是求偏序集的最长链大小，实际上也就是序列的LIS，非常妙的一个转化。</p><h2 id="与dag">与DAG</h2><p>之前说过，Hasse图就是一个DAG，而反过来，我们将DAG的点作为集合<spanclass="math inline">\(S\)</span>的元素，将偏序关系<spanclass="math inline">\(\leq\)</span>定义为点之间的可达性，就定义了一个偏序集<spanclass="math inline">\((S,\leq)\)</span>从而DAG上的最小可重路径覆盖（要求覆盖所有点）就等价于偏序集<spanclass="math inline">\((S,\leq)\)</span>上的最小链覆盖</p><p>同理，将DAG上的有向边作为集合<spanclass="math inline">\(T\)</span>的元素，将偏序关系<spanclass="math inline">\(\leq&#39;\)</span>定义为边之间的可达性，就得到的另一个偏序集<spanclass="math inline">\((T,\leq&#39;)\)</span>从而DAG上的最小可重路径覆盖(要求覆盖所有<strong>边</strong>)就等价于偏序集<spanclass="math inline">\((T,\leq&#39;)\)</span>上的最小链覆盖</p><h2 id="erdősszekeres-定理">Erdős–Szekeres 定理</h2><p>含至少<span class="math inline">\(rs+1\)</span>个元素的实数序列<spanclass="math inline">\(\{a\}\)</span>要么有一个长为<spanclass="math inline">\(r+1\)</span>的不下降子序列，要么有一个长为<spanclass="math inline">\(s+1\)</span> 的不上升子序列<font color='orange'>Proof:</font> 设序列长度为<spanclass="math inline">\(n\geq rs+1\)</span>,定义偏序集<spanclass="math inline">\(\{(i,a_i)\}_{i=1}^{n}\)</span>,其上的偏序关系<spanclass="math inline">\(\leq\)</span>定义为： <spanclass="math display">\[(i,a_i)\leq (j,a_i)\Leftrightarrow (i\leq j \ \wedge \ a_i\leq a_j)\]</span> 假设该偏序集的宽度<span class="math inline">\(\leqs\)</span>,则由Dilllworth定理可知其最小链覆盖数<spanclass="math inline">\(\leq s\)</span>,若这些链的长度都<spanclass="math inline">\(\leq r\)</span>,则总元素数<spanclass="math inline">\(\leq rs&lt; rs+1\leq n\)</span> 矛盾。 <spanclass="math inline">\(\square\)</span></p>]]></content>
    
    
    <categories>
      
      <category>组合数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>学习笔记</tag>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂想-抽奖问题平凡解</title>
    <link href="/posts/19a8f88a/"/>
    <url>/posts/19a8f88a/</url>
    
    <content type="html"><![CDATA[<h2 id="background">Background</h2><p>复习概率论的时候看到了对抽奖问题的讨论，突然就想推一下平凡解</p><p>总共有<span class="math inline">\(n\)</span>张票，其中有<spanclass="math inline">\(k\)</span>张中奖，问第<spanclass="math inline">\(i\)</span>个来抽奖的人中奖的概率。</p><p>这应该算是一个最平凡的情形了吧</p><h2 id="solution">Solution</h2><p>整个概率空间可以被划分为<spanclass="math inline">\(k+1\)</span>个部分，第<spanclass="math inline">\(j\)</span>个部分<spanclass="math inline">\(S_j\)</span>表示前<spanclass="math inline">\(i-1\)</span>个人中了<spanclass="math inline">\(j\)</span>张</p><p>那么 <span class="math display">\[ans=\sum_{j=0}^{k} P(S_j)P(A|S_j)\]</span> 其中<span class="math inline">\(P(A)\)</span>表示第<spanclass="math inline">\(i\)</span>个人中奖</p><p>对于前<span class="math inline">\(i-1\)</span>个人中了<spanclass="math inline">\(j\)</span>张的情况，有方案数为 <spanclass="math display">\[cnt_j=\binom{k}{j}\binom{n-k}{i-1-j}(i-1)!\]</span> 所以 <span class="math display">\[P(S_j)=\frac{cnt_j}{\sum_t cnt_t}\]</span> 其中 <span class="math display">\[\sum_t cnt_t=(i-1)!\sum_t \binom{k}{j}\binom{n-k}{i-1-j}\]</span> 后面部分是一个范德蒙德卷积，从而 <span class="math display">\[\sum_t cnt_t=(i-1)!\binom{n}{i-1}\]</span> 从而 <span class="math display">\[\begin{flalign}ans=&amp;\frac{1}{(i-1)!\binom{n}{i-1}}\sum_{j=0}^{k}cnt_jP(A|S_j)\\&amp;=\frac{1}{(i-1)!\binom{n}{i-1}}\sum_{j=0}^{k}\binom{k}{j}\binom{n-k}{i-1-j}(i-1)!\frac{k-j}{n-i+1}\\&amp;=\frac{k}{(n-i+1)\binom{n}{i-1}}\sum_{j=0}^{k}\binom{k-1}{j}\binom{n-k}{i-1-j}\\&amp;=\frac{k}{(n-i+1)\binom{n}{i-1}}\binom{n-1}{i-1}\\&amp;=\frac{k}{n-i+1}\frac{(i-1)!(n-i+1)!}{n!}\frac{(n-1)!}{(i-1)!(n-i)!}\\&amp;=\frac{k}{n}\end{flalign}\]</span> 从而中奖概率确实与抽奖顺序无关</p><p>over</p><p>（久违的推式子环节，真是太舒服了~)</p><p>update：</p><p>队友给出了一个更加优雅的解法：</p><p>考虑数学归纳法：</p><p>第一个人中奖的概率显然为<spanclass="math inline">\(\frac{k}{n}\)</span></p><p>假设对于第<spanclass="math inline">\(j\)</span>个人，他中奖的概率也为<spanclass="math inline">\(\frac{k}{n}\)</span>,我们来证对于第<spanclass="math inline">\(j+1\)</span>个人，其中奖的概率也为<spanclass="math inline">\(\frac{k}{n}\)</span></p><p>其中奖的概率为 <span class="math display">\[P_{j+1}=\sum_{i=0}^{p}\binom{p}{i}(\frac{k}{n})^i(\frac{n-k}{n})^{p-i}\frac{k-i}{n-j}\\其中p=min(k,j)\]</span> 这里将<span class="math inline">\(p\)</span>与<spanclass="math inline">\(j\)</span>做区分是因为中奖的人数最多只能有<spanclass="math inline">\(k\)</span>个</p><p>注意到式子中的<spanclass="math inline">\(\sum_{i=0}^{p}\binom{p}{i}(\frac{k}{n})^i(\frac{n-k}{n})^{p-i}\)</span>实际上就是一个伯努利分布，所以我们可以化为<span class="math display">\[\begin{flalign}P_{j+1}&amp;=\frac{k}{n-j}\sum_{i=0}^{p}\binom{p}{i}(\frac{k}{n})^i(\frac{n-k}{n})^{p-i}-\frac{1}{n-j}\sum_{i=0}^{p}\binom{p}{i}(\frac{k}{n})^i(\frac{n-k}{n})^{p-i}i\\&amp;=\frac{k}{n-j}-\frac{1}{n-j}\frac{k}{n}j\\&amp;=\frac{k}{n}\end{flalign}\]</span> 其中第二个式子实际上就是伯努利分布的期望</p><p>比我的证法短多了，思路也更加清晰。优雅，太优雅了！</p><p>over</p>]]></content>
    
    
    <categories>
      
      <category>杂想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LightGCN:简化和增强图卷积网络的推荐</title>
    <link href="/posts/92a96c01/"/>
    <url>/posts/92a96c01/</url>
    
    <content type="html"><![CDATA[<h1id="lightgcn简化和增强图卷积网络的推荐">LightGCN:简化和增强图卷积网络的推荐</h1><h2 id="abstract">Abstract</h2><p>图卷积网络 (GCN)已成为协同过滤的最新技术。然而，它推荐有效性的原因并没有得到很好的理解。该工作还发现GCN中最常见的两种设计——<strong>特征变换和非线性激活</strong>——对协同过滤的性能贡献不大，并且还增加了训练的难度，降低了推荐性能。在这项工作中，作者提出了一种新的模型LightGCN，只包含GCN中最基本的组件——<strong>邻域聚合</strong>。具体来说，LightGCN通过在用户-项目交互图上线性传播来学习用户和项目嵌入，并使用所有层学习到的嵌入的<strong>加权和</strong>作为最终嵌入。这种简单、线性和整洁的模型更容易实现和训练，与同一个组之前提出的NGCF相比，有明显的改进（平均约16.0% 的相对改进）。最后对LightGCN的合理性进行了分析。本文的主要贡献：</p><ul><li>通过实验说明GCN中的非线性激活以及特征变换对协同过滤没有积极影响<br /></li><li>提出了LightGCN，结构更加简洁，并且性能更好<br /></li><li>对LightGCN的合理性进行分析</li></ul><h2 id="ngcf">NGCF</h2><p>先简单介绍一下NGCF。NGCF主张在协同过滤中加入对user-item对信息的编码，而不仅仅是只考虑user，item的emmbedding，从而能够获得更多信息，进而进行推荐。实际场景中user-item对的信息很多，所以它借鉴了GCN中的领域聚合的思想，仿照GCN的结构，每一层聚合周围邻居的信息，从而在多层之后实现对多跳邻居的信息的收集。具体来说，每一层的信息传播公式为 <span class="math display">\[m_{u\leftarrowi}^{(l)}=\frac{1}{\sqrt{|N_u||N_i|}}(W_1^{(l)}e_i^{(l-1)}+W_2^{(l)}(e_i^{(l-1)}⊙e_u^{(l-1)}))\]</span> <span class="math display">\[m_{u\leftarrow u}^{(l)}=W_1^{(l)}e_u^{(l-1)}\]</span></p><p>这是对user而言的，item的传播公式同理 其中<spanclass="math inline">\(m_{u\leftarrow i}\)</span>表示<spanclass="math inline">\(item_i\)</span>与<spanclass="math inline">\(user_u\)</span>之间的协作信息，<spanclass="math inline">\(\frac{1}{\sqrt{|N_u||N_i|}}\)</span>借鉴了GCN的思路，不过作者在文中把它理解为信息的衰减系数，也就是当前信息应该随着层的传播而比重变小。考虑到自己到自己的信息不用衰减，所以第二个式子没有乘上对称归一化的系数。<spanclass="math inline">\(W_1,W_2\)</span>是可训练系数，<spanclass="math inline">\(e_i,e_u\)</span>就是item和user的当前特征embedding，最后加了一个<spanclass="math inline">\(e_i⊙e_u\)</span>,也就是两者的哈达玛积，用来编码两者的信息交互（有点像attention？）最后得到每一层的新的特征表示： <span class="math display">\[e_u^{(l)} = LeakyReLU(m_{u\leftarrow u}^{(l)}+\sum_{i\inN_u}m_{u\leftarrow i}^{(l)})\]</span>这是NGCF的基本结构。首先在embedding层获得每一个user，item的embedding，这里展示了<spanclass="math inline">\(e_{u_1}^{(0)}\)</span>以及<spanclass="math inline">\(e_{i_4}^{(0)}\)</span>的embedding。然后逐层传播并更新每一层的embedding，在最后一层将每一层的embedding进行<strong>拼接</strong>，然后拿去做预测。这里拼接应该也是为了进行特征增强，不过后面LightGCN也还是改掉了。<img src="https://s2.loli.net/2024/03/28/HnMszK8L3F6bJag.png" alt="image.png|475" style="zoom:67%;" /></p><h2 id="lightgcn">LightGCN</h2><p>可以看到NGCF其实大量借鉴了GCN的结构，但是其中也有一些操作是毫无理由就搬上来了。所以作者对其进行了大量的消融分析，包括对非线性激活和特征变化结构的质疑。作者建立了四个模型进行比较，分别是</p><ul><li><p>NGCF,也就是原模型</p></li><li><p>NGCF-n 去掉了特征变换，也就是上一节中的<spanclass="math inline">\(W_1,W_2\)</span>参数矩阵的NGCF</p></li><li><p>NGCF-f 去掉了非线性激活的NGCF</p></li><li><p>NGCF-fn 去掉了特征变换以及非线性激活的NGCF</p><p>然后在<span class="math inline">\(Gowalla\)</span>和<spanclass="math inline">\(Amazon-Book\)</span>数据集上进行测试，得到结果如下：<img src="https://s2.loli.net/2024/03/28/fIGPmyxuSr2KU1O.png" alt="image.png|850" style="zoom:150%;" />可以看出NGCF-fn的性能是远好于NGCF的，作者将这一点归因于特征变换以及非线性激活操作加大了训练的难度，从而提出对其进行简化，得到如下的传播公式<span class="math display">\[e_{u}^{(k+1)}=\sum_{i\in N_u}\frac{1}{\sqrt{|N_u||N_i|}}e_i^{(k+1)}\\e_{i}^{(k+1)}=\sum_{u\in N_i}\frac{1}{\sqrt{|N_u||N_i|}}e_u^{(k+1)}\]</span> 在最后一层进行每一层特征的加权求和得到最终特征 <spanclass="math display">\[e_u=\sum_{k=0}^{K}\alpha_ke_u^{(k)}\\e_i=\sum_{k=0}^{K}\alpha_ke_i^{(k)}\]</span> 最终得到user-item项目的最终得分为 <spanclass="math display">\[\hat{y}_{ui}=e_u^{T}e_i\]</span> 上面的式子不方便实现，我们将其转换为矩阵形式 假设user有<spanclass="math inline">\(N\)</span>个，item有<spanclass="math inline">\(M\)</span>个，每一个user/item的特征长度为<spanclass="math inline">\(T\)</span>,那么定义邻接矩阵<spanclass="math inline">\(A\inR^{(N+M)\times(N+M)}\)</span>表示user-item的邻接矩阵，矩阵<spanclass="math inline">\(E\in R^{(N+M)\timesT}\)</span>表示每一个user/item的embedding，显然<spanclass="math inline">\(E^{0}\)</span>就表示了大家的初始embedding。再定义矩阵<spanclass="math inline">\(D\in R^{(N+M)\times(N+M)}\)</span>表示度数矩阵。从而得到传播公式为 <span class="math display">\[E^{k+1} = (D^{-\frac{1}{2}}AD^{-\frac{1}{2}})E^{k}\]</span> 最终每一个user/item的embedding为 <span class="math display">\[E =\alpha_0E^{0}+\alpha_1E^{1}+....+\alpha_KE^{K}=\alpha_0E^{0}+\alpha_1\tilde{A}E^{0}+....+\alpha_K\tilde{A}^{K}E^{0}=\sum_{i=0}^{K}\alpha_i\tilde{A}^iE^0\]</span> 其中<spanclass="math inline">\(\tilde{A}=D^{-\frac{1}{2}}AD^{-\frac{1}{2}}\)</span></p></li></ul><hr /><p>与NGCF的式子进行对比，可以发现LightGCN总共去掉了如下几个构造：</p><ul><li><strong>特征变换，非线性激活</strong></li><li><strong>自连接</strong></li><li><strong>user-item的哈达玛积</strong>对于哈达玛积的移除作者没有详细介绍，只是在后面实验时提了一嘴LightGCN效果比NGCF-fn效果更好，所以可能也没啥用，就移掉了。除此之外，在实现细节上，LightGCN相比GCN还有如下变化</li><li><strong>在最后一层将每一层特征的concat操作变成了加权求和</strong></li><li><strong>去掉了每一层的dropout操作</strong></li></ul><h2 id="模型分析">模型分析</h2><p>分析一下每一个操作的合理性<br />### 加权求和与去除自连接<br />作者去除自连接的原因与最后一步的加权求和有关系。注意到最后的特征表示为<span class="math display">\[E =\sum_{i=0}^{K}\alpha_i\tilde{A}^iE^0\]</span>这与之前的一些工作具有相同的形式，所以作者指出该模型同样可以享用它们的优点#### SGCN<br />这是之前的一篇简化GCN的工作，它同样是去除了非线性激活函数，并且将每一层的权重矩阵简化成了一个，其传播公式为<span class="math display">\[E^{(k+1)}=(D+I)^{-\frac{1}{2}}(A+I)(D+I)^{-\frac{1}{2}}E^{k}\]</span>它包含了自连接操作，我们将其在式子中提取出来了，然后进行化简，得到 <spanclass="math display">\[E^{(k)}=(\tilde{A}+(D+I)^{-1})E^{k-1}=(\tilde{A}+(D+I)^{-1})^KE^{0}=(\tilde{A}+\tilde{D})^KE^0\]</span> 其中 <span class="math display">\[\tilde{A}=D^{-\frac{1}{2}}AD^{-\frac{1}{2}},\tilde{D}=(D+I)^{-1}\]</span> 对前面的系数二项展开，得到 <span class="math display">\[E^{(k)}=\binom{K}{0}\tilde{D}^KE^{0}+\binom{K}{1}\tilde{D}^{K-1}AE^{0}+...+\binom{K}{K}A^KE^{0}=\sum_{i=0}^{K}\binom{K}{i}\tilde{D}^{K-i}\tilde{A}^iE^0\]</span>没错，与LightGCN的式子相比还多了一个对角矩阵，形式上是不一样的。原文是用另一个方法推导的，省略了<spanclass="math inline">\((D+I)^{-\frac{1}{2}}\)</span>,理由是它只缩放了embedding，但是个人认为每一维的缩放系数不同，不能直接这样忽略。这里存疑。总之作者在这里得到结论是两个模型在结构上相同，所以没有添加自环也没有关系，实际效果上已经添加了。#### APPNP<br />这个工作宣称可以在没有过度平滑的风险的情况下传播远程，其传播公式为 <spanclass="math display">\[E^{K}=\beta E^0+(1-\beta)\tilde{A}E^{K-1}\]</span> 显然这是一个可以求通项的式子，化简得到 <spanclass="math display">\[E^{K}=\beta E^0+(1-\beta)\tilde{A}E^{K-1}\\=\beta E^0+\beta(1-\beta)\tilde{A}E^{0}+(1-\beta)^2\tilde{A}^2E^{K-2}\\=\betaE^0+\beta(1-\beta)\tilde{A}E^{0}+(1-\beta)^2\tilde{A}^2E^{0}+...+(1-\beta)^K\tilde{A}^KE^0\]</span></p><p>注意到该式子与LightGCN的传播公式也就只有系数差别，所以LightGCN在减少过拟合方面有较好的效果，后面的实验也佐证了这一点</p><h3 id="去除哈达玛积">去除哈达玛积</h3><p>作者引入它是为了强调user-item的交互，有点类似attention，但是个人感觉模型已经是在gcn的基础上做改进了，而gcn的一个最大特点就是逐层聚合邻域信息，这一点本身就已经在实现信息的交互了，所以可能这也是在LightGCN中将其移除的原因吧</p><h3 id="去除dropout">去除dropout</h3><p>注意到LightGCN整个模型其实已经只有初始化embedding的一些矩阵参数了，每一层传播的时候是没有参数的了，所以也没有做dropout的必要了，<spanclass="math inline">\(L_2\)</span>正则化就足够保证避免过拟合了</p><h3 id="嵌入的平滑性">嵌入的平滑性</h3><p>我们考虑两个共享同一个item的节点的信息传递</p><p><span class="math display">\[e_u^{(2)}=\sum_{i\in N_u}\frac{1}{\sqrt{|N_u||N_i|}}e_i^{(1)}=\sum_{i\inN_u}\frac{1}{|N_i|}\sum_{v\in N_i}\frac{1}{\sqrt{|N_u||N_v|}}e_v^{(0)}\]</span> 注意到<span class="math inline">\(user_v\)</span>与<spanclass="math inline">\(user_u\)</span>之间的信息传递的系数为 <spanclass="math display">\[c_{v\rightarrow u}\frac{1}{\sqrt{|N_u||N_v|}}\sum_{i\in N_u\capN_v}\frac{1}{|N_i|}\]</span> 这一系数符合很多直观的想法，二阶邻居 v 对 u 的影响由 1)共同交互项目的数量、越大； 2)共同交互项目的流行程度越低（即更能指示用户个性化偏好）越大； 3) v的活动，越大越活跃。 这种可解释性很好地满足了 CF 在测量用户相似度中的假设，并证明了 LightGCN 的合理性。</p><h2 id="留的坑">留的坑</h2><p>作者在文末指出对<spanclass="math inline">\(\alpha_i\)</span>的个性化调节，即稀疏用户可能需要更多来自高阶邻居的信号，而活动用户只需要更少</p><h2 id="总结">总结</h2><p>总体来说，LightGCN在NGCF的基础上，指出特征变换与非线性激活在推荐模型上的冗余性，充分简化了其模型结构，并且提高了性能。但是这是建立在推荐的场景下，原始的GCN是用于节点分类的，此时每一个节点包含更多信息，而不是只有id信息，所以还是需要非线性激活与特征变换的。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Machine</tag>
      
      <tag>Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Attention-Machanism</title>
    <link href="/posts/8370aead/"/>
    <url>/posts/8370aead/</url>
    
    <content type="html"><![CDATA[<h1 id="attention-mechanism">Attention Mechanism</h1><p>现在给定一组数据，假设包含若干个 特征-值 对 <spanclass="math inline">\((Key,Value)\)</span>,那么现在我们拿着一个特征<spanclass="math inline">\(Query\)</span>,要如何利用这组数据确定一个合理的<spanclass="math inline">\(value\)</span>?有一些比较naive的想法，比如取最近邻的对应<spanclass="math inline">\(Value\)</span>,或者取较近的几个<spanclass="math inline">\(Key\)</span>,再拿它们的<spanclass="math inline">\(Value\)</span>做个平均啥的。这些想法有其合理性，并且都蕴含一个核心点就是：&gt;我们在尽可能地将注意力集中在与<spanclass="math inline">\(Query\)</span>相近的<spanclass="math inline">\(Key\)</span>对应的<spanclass="math inline">\(Value\)</span>上，因为这些<spanclass="math inline">\(Value\)</span>更大概率会与我们要确定的值更加接近</p><p>所以就有了<spanclass="math inline">\(Attention\  Mechanism\)</span></p><h2 id="低维">低维</h2><p>我们首先在一维空间<spanclass="math inline">\(\mathbb{R}\)</span>下讨论这件事情。下面是一个非常直观的过程.我们有若干组<spanclass="math inline">\((Key_i,Value_i)\)</span>,以及一个查询<spanclass="math inline">\(Query\)</span>,我们的目标是得到<spanclass="math inline">\(Output\)</span>.首先我们会让<spanclass="math inline">\(Query\)</span>与各个<spanclass="math inline">\(Key_i\)</span>做一个<spanclass="math inline">\(a\)</span>运算，得到结果<spanclass="math inline">\(a(Query,Key_i)\)</span>,它表示<spanclass="math inline">\(Query\)</span>与<spanclass="math inline">\(Key_i\)</span>的相似程度，显然它与我们之后要在<spanclass="math inline">\(Key_i,Value_i\)</span>上投入的注意力大小成正比，我们就记为注意力评分函数(attentionscoring function).然后我们就拿<spanclass="math inline">\(a_i=a(Query,Key_i)\)</span>转换成概率分布<spanclass="math inline">\(s_i\)</span>,再与<spanclass="math inline">\(Value_i\)</span>相乘并求和得到 <spanclass="math display">\[Output = \sum_i s_iValue_i\]</span> 这就是最后的结果了。 这里<spanclass="math inline">\(a_i\)</span>到<spanclass="math inline">\(s_i\)</span>我们简单点，可以直接取 <spanclass="math display">\[s_i=\frac{a_i}{\sum_{j=1}^{n} a_j}\]</span>可以看到这个求法还是有一定的合理性的，因为它不仅考虑到了注意力要偏向重点，还考虑到了整体的数据，而不是像之前那样只关注一小部分。接下来还剩下一个问题，就是我们的注意力评分函数<spanclass="math inline">\(a(Query,Key_i)\)</span>要怎么算。一个方法就是可以使用核回归：这里我们核函数选择<span class="math inline">\(Gauss\)</span>核函数 <spanclass="math display">\[K(u)=\frac{1}{\sqrt{2\pi}}exp(-\frac{u^2}{2})\]</span> 从而<span class="math inline">\(u\)</span>就取<spanclass="math inline">\(Query-Key_i\)</span>,得到 <spanclass="math display">\[Output = \sum_i\frac{exp(-\frac{1}{2}(Query-Key_i)^2)}{\sum_jexp(-\frac{1}{2}(Query-Key_j)^2)}Value_i\]</span> 注意到第一个求和号里面其实就是一个softmax，从而 <spanclass="math display">\[Output = \sum_i softmax(-\frac{1}{2}(Query-Key_i)^2)Value_i\]</span>为了给整个模型加入一点可学习的东西，我们可以在softmax里面加入一个参数<spanclass="math inline">\(w\)</span>,得到 <span class="math display">\[Output = \sum_i softmax(-\frac{1}{2}(Query-Key_i)^2w)Value_i\]</span> 这就是最终结果了。</p><h2 id="高维">高维</h2><p>现在不管是<span class="math inline">\(Query,Key\)</span>还是<spanclass="math inline">\(Value\)</span>,都从原本的一维数据变成了高维的向量，然后我们再重新审视这个问题。下面这张图是非常形象的。<img src="https://s2.loli.net/2024/03/13/XigM7pTvh8AH2bu.png"alt="image-20240313151037340" /> 用一个函数<spanclass="math inline">\(f\)</span>来形式化地描述整个过程。有<spanclass="math inline">\(n\)</span>个键值对<spanclass="math inline">\(\boldsymbol{k_i}\in\mathbb{R}^k,\boldsymbol{v_i}\in \mathbb{R}^v\)</span>,给定一个查询<spanclass="math inline">\(\boldsymbol{q}\in \mathbb{R}^q:\)</span> <spanclass="math display">\[Output =f(\boldsymbol{q},(\boldsymbol{k_1},\boldsymbol{v_1}),\cdots,(\boldsymbol{k_n},\boldsymbol{v_n}))=\sum_{i=1}^{n}\alpha(\boldsymbol{q},\boldsymbol{k_i})\boldsymbol{v_i}\in\mathbb{R}^v\]</span> 其中 <span class="math display">\[\alpha(\boldsymbol{q,k_i})=\frac{exp(a(\boldsymbol{q,k_i}))}{\sum_{j=1}^{n}exp(a(\boldsymbol{q,k_j}))}\]</span>由于把核函数的一部分抽象成了softmax操作，所以在低维情况下我们的<spanclass="math inline">\(a(q,k_i)\)</span>函数实际对应的是<spanclass="math inline">\(-\frac{1}{2}(q-k_i)^2\)</span>而在高维向量情况下，我们有对<spanclass="math inline">\(a\)</span>一般有两种处理方式</p><h3 id="加性注意力">加性注意力</h3><p>一般来说，当查询和键<font color='red'>是不同长度的矢量时</font>，可以使用加性注意力作为评分函数。此时给定<spanclass="math inline">\(\boldsymbol{q}\in \mathbb{R}^q,\boldsymbol{k}\in\mathbb{R}^k\)</span>,有 <span class="math display">\[a(\boldsymbol{q,k})=\boldsymbol{w}_v^T\tanh(\boldsymbol{W}_q\boldsymbol{q+\boldsymbol{W}_k\boldsymbol{k}})\]</span> 其中<span class="math inline">\(\boldsymbol{W}_q\in\mathbb{R}^{h\times q},\boldsymbol{W}_k\in \mathbb{R}^{h\timesk},\boldsymbol{w}_v\in \mathbb{R}^{h}\)</span>都是可学习的参数，而<spanclass="math inline">\(h\)</span>是作为一个可以调整的超参数，tanh就是一个激活函数。仔细观察一下就是，括号里面将<spanclass="math inline">\(\boldsymbol{q}\)</span>和<spanclass="math inline">\(\boldsymbol{k}\)</span>都转化成了一个<spanclass="math inline">\(h\)</span>维向量，然后再与外面的<spanclass="math inline">\(\boldsymbol{w}_v^T\)</span>一乘，就得到了一个实数作为最终结果</p><h3 id="缩放点积注意力">缩放点积注意力</h3><p>当查询和键的长度相同时，我们就可以不必这么麻烦，把它们统一转化成一个长度的向量了。我们可以直接做向量内积，从而有<spanclass="math inline">\(\boldsymbol{q,k}\in \mathbb{R}^d\)</span>, <spanclass="math display">\[a(\boldsymbol{q},\boldsymbol{k})=\boldsymbol{q}^T\boldsymbol{k}\]</span> 但是这样其实有一个问题。因为我们的结果<spanclass="math inline">\(a(\boldsymbol{q},\boldsymbol{k})\)</span>是要拿去做softmax的，而softmax由于是由指数函数实现的，当指数差距过大时，概率的偏差就会变的极大，从而失去参考价值。所以我们可以统一除以一个<spanclass="math inline">\(\sqrt{d}\)</span>来减少差距,至于为什么是<spanclass="math inline">\(\sqrt{d}\)</span>,我们在最后讨论一下</p><p>以上都是考虑样本数为1的情况，实际情况中有多个样本，多个数据,记为查询<spanclass="math inline">\(\boldsymbol{Q}\in \mathbb{R}^{m\timesd}\)</span>,键值<span class="math inline">\(\boldsymbol{K}\in\mathbb{R}^{n\times d},\boldsymbol{V}\in \mathbb{R}^{n\timesv}\)</span>,就有</p><p><span class="math display">\[f=softmax(\frac{\boldsymbol{QK}^T}{\sqrt{d}})\boldsymbol{V}\in\mathbb{R}^{m \times v}\]</span> 这里softmax操作就是对每一行进行softmax操作的意思总体可以用这一张图表示 <imgsrc="https://s2.loli.net/2024/03/13/heWdDc7K4BqrwiL.png"alt="image.png|170" /> 首先<spanclass="math inline">\(\boldsymbol{Q,K}\)</span>做内积，然后放缩(除以<spanclass="math inline">\(\sqrt{d}\)</span>)，然后做softmax，最后与<spanclass="math inline">\(\boldsymbol{V}\)</span>点乘</p><h1 id="self-attention-mechanism">Self-Attention Mechanism</h1><p>说是叫self-attention，不过我觉得这里的self更多的应该是指一个集合本身，而不是集合中的某一个元素回忆一下Attention Mechanism：有<spanclass="math inline">\(m\)</span>个长度为<spanclass="math inline">\(d\)</span>的查询向量<spanclass="math inline">\(\boldsymbol{q_1,q_2,...q_n}\)</span>,就记为行向量好了，它们组成一个矩阵<spanclass="math inline">\(\boldsymbol{Q\in \mathbb{R}^{m\timesd}}\)</span>,同理有n个键行向量组成的矩阵<spanclass="math inline">\(\boldsymbol{K}\in \mathbb{R}^{n\timesd}\)</span>,以及<spanclass="math inline">\(n\)</span>个值行向量组成的矩阵<spanclass="math inline">\(\boldsymbol{V}\in \mathbb{R}^{n\times v}\)</span>&gt;（这里为了方便我们就只讨论查询向量与键值向量的长度相等的情况了，然后就直接用ScaledDot-Product Attention来处理了，另一种情况的处理显然也会是类似的）</p><p>然后就有结果矩阵 <span class="math display">\[f=softmax(\frac{\boldsymbol{QK}^T}{\sqrt{d}})\boldsymbol{V}\in\mathbb{R}^{m \times v}\]</span> 这里有几点要指出： * f的行大小是与<spanclass="math inline">\(Q\)</span>相同的，它相当于是对每一个询问行向量<spanclass="math inline">\(q_i\)</span>的所有特征进行了一个回答 *任意两个询问行向量<spanclass="math inline">\(q_i,q_j\)</span>之间是可以没有任何关系的，相当于<spanclass="math inline">\(m\)</span>次互不影响的询问那么自注意力机制就是在次基础上做的改进 --- 我们现在有<spanclass="math inline">\(m\)</span>个事物，它们是一个整体，<spanclass="math inline">\(m\)</span>个事物之间有可能某个集合的事物之间是包含一定的关系的。如果我们想只用这<spanclass="math inline">\(m\)</span>个事物的当前特征去做attention，得到一些信息，那么显然我们的查询矩阵<spanclass="math inline">\(\boldsymbol{Q}\)</span>的每一行就要取对应事物的特征。那么<spanclass="math inline">\(\boldsymbol{K,V}\)</span>呢?我们还是取这个集合内每一个事物的对应信息。相当于从集合内部的事物之间的隐含的关系来找到信息从而我们的<spanclass="math inline">\(\boldsymbol{Q,K,V}\)</span>的第<spanclass="math inline">\(i\)</span>个行向量来自第<spanclass="math inline">\(i\)</span>个事物的信息。为此我们需要引入<spanclass="math inline">\(\boldsymbol{W_q,W_k,W_v}\in \mathbb{R}^{d\timesb}\)</span>三个矩阵来提取信息，当然它们是可学习的,而这<spanclass="math inline">\(m\)</span>个事物本身的信息可以写成一个<spanclass="math inline">\(\boldsymbol{X}\in \mathbb{R}^{m\timesd}\)</span>,从而， <span class="math display">\[\boldsymbol{Q=XW_q,K=XW_k,V=XW_v}\]</span> 最后套用原本的attention机制，我们得到 <spanclass="math display">\[f=softmax(\frac{\boldsymbol{QK}^T}{\sqrt{d}})\boldsymbol{V}\in\mathbb{R}^{m \times d}\]</span> <spanclass="math inline">\(f\)</span>的每一个行向量就是第<spanclass="math inline">\(i\)</span>个事物从这n个事物当中提取到的信息了注意到自注意力机制与普通的注意力机制的区别就在于：它的信息来源是一个固定的集合，集合的每一个元素既为其它元素提供信息，也从其它元素那里提取信息。所以我在这一节的一开始说，<strong>self更多的应该是指一个集合本身，而不是集合中的某一个元素</strong>这样做的意义是：对于集合中的每一个元素<spanclass="math inline">\(a\)</span>,它可以从与它相近的其它元素中得到更多信息，而不仅仅是只有自己的信息</p><h1 id="multi-head-attention-mechanism">Multi-head AttentionMechanism</h1><p>注意到之前对于每一个事物，我们只用了一组矩阵<spanclass="math inline">\(W_q,Q_k,Q_v\)</span>来提取其特征。一个很自然的问题：这样提取够吗？会不会导致提取的信息不足？解决方案也很简单，那就多用几组<spanclass="math inline">\(W_q,Q_k,Q_v\)</span>来提取就好了，然后再把它们的结果放到一起，再拼在一起就可以啦。第<spanclass="math inline">\(i\)</span>组用的矩阵就是<spanclass="math inline">\(W_{q_i},Q_{k_i},Q_{v_i}\)</span>,不同组之间显然是可以并行计算的，互不影响。</p><h1 id="关于缩放系数sqrtd">关于缩放系数<spanclass="math inline">\(\sqrt{d}\)</span></h1><p>前面讲到了，attention操作最后需要做一个softmax，而softmax里面含有指数运算，如果数据的方差过大的话，最后得到的分布就会非常接近一个onehot分布，从而导致严重的梯度消失，为此我们需要对点积进行放缩。但是为什么放缩的系数是<spanclass="math inline">\(\sqrt{d}\)</span>呢？（其中<spanclass="math inline">\(d\)</span>是向量的长度）</p><p>我们考虑 <span class="math display">\[softmax(\frac{\boldsymbol{QK}^T}{\sqrt{d}})\boldsymbol{V}\in\mathbb{R}^{m \times v}\]</span> 中的任意两个<span class="math inline">\(d\)</span>维向量<spanclass="math inline">\(q,k\)</span>,假设它们采样自均值为0，方差为1的分布，那么它们内积的二阶矩为<span class="math display">\[\begin{flalign}\mathbb{E}[(q\cdot k)^2] &amp;= \mathbb{E}[(\sum_{i=1}^{d}q_ik_i)^2] =\mathbb{E}[(\sum_{i=1}^{d}q_ik_i)\cdot (\sum_{j=1}^{d}q_jk_j)]\\&amp;=\mathbb{E}[\sum_{i,j}^{d}(q_iq_j)(k_ik_j)]=\sum_{i,j}\mathbb{E}[q_iq_j]\mathbb{E}[k_ik_j]\\&amp;=\sum_{i,j}\mathbb{E}[q_i]^2\mathbb{E}[k_i]^2 = d\end{flalign}\]</span></p><p>又<span class="math inline">\(\mathbb{E}[q\cdotk]^2=0\)</span>，从而<span class="math inline">\(\mathbb{V}ar[q\cdotk]=d\)</span> 根据正态分布的3<spanclass="math inline">\(\sigma\)</span>原则，我们不妨假定<spanclass="math inline">\(q\cdot k\)</span>分布在<spanclass="math inline">\([-3\sqrt{d},3\sqrt{d}]\)</span>中,那么在softmax中先做指数运算的时候，数据分布区间会变成<spanclass="math inline">\([e^{-3\sqrt{d}},e^{3\sqrt{d}}]\)</span>中，一般来说<spanclass="math inline">\(d\)</span>都是一个较大的值，从而左界会极小，右界又会极大，所以求梯度的时候很容易导致梯度消失，为此我们经验性地除上一个<spanclass="math inline">\(\sqrt{d}\)</span>,使得<spanclass="math inline">\(\mathbb{V}ar[q\cdotk]=1\)</span>，这会使得最后的区间大致分布在<spanclass="math inline">\([e^{-3},e^3]\)</span>,这是一个相对来说可以接受的区间，会有效缓解该问题，让网络能够更加稳定地更新。</p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>环论</title>
    <link href="/posts/1d9cc7d4/"/>
    <url>/posts/1d9cc7d4/</url>
    
    <content type="html"><![CDATA[<table><thead><tr class="header"><th></th><th>子环</th><th>环同态</th><th>理想</th></tr></thead><tbody><tr class="odd"><td>单位元（乘法单位元）</td><td>环与子环的单位元无必然关系,即子环不一定有单位元，有也不一定和环的单位元相同比如<font color='red'><spanclass="math inline">\(Z_6\)</span>有单位元1，其子环<spanclass="math inline">\((2)\)</span>单位元为4;Z有单位元1，其子环2Z没有单位元</font></td><td>若R有单位元，则<spanclass="math inline">\(ImR\)</span>也有单位元，且<spanclass="math inline">\(ImR\)</span>的单位元为f(1)<font color='red'>(同态满射)</font></td><td>环与子环的单位元无必然关系。即子环不一定有单位元，有也不一定和环的单位元相同</td></tr><tr class="even"><td>零元（加法单位元）</td><td>保持存在且不变</td><td>保持存在且不变</td><td>保持存在且不变</td></tr><tr class="odd"><td>零因子</td><td>无关</td><td><font color='red'>同构映射下，零因子保持（若<spanclass="math inline">\(a\)</span>为<spanclass="math inline">\(G\)</span>的零因子，则<spanclass="math inline">\(F(a)为G&#39;\)</span>的零因子）</font>，但是在普通环同态下没啥关系</td><td>无关</td></tr></tbody></table><ul><li>零元保持不变是因为它是加法的单位元，而环<spanclass="math inline">\(R\)</span>关于加法是做成群的，众所周知群的性质是相当优秀的，无论在子群还是群同态下都保持单位元</li><li>理想一定是子环，只是在此基础上满足了强吸收性，所以子环的性质它都满足。</li></ul><h1 id="环的基本性质">环的基本性质</h1><h2 id="零因子">零因子：</h2><p>环<spanclass="math inline">\(R\)</span>中必定存在0元(关于加法的群的单位元),对于<span class="math display">\[a\neq 0\in R,若\exist b\neq 0,S.T. ab=0\]</span> 则<span class="math inline">\(a\)</span>是环<spanclass="math inline">\(R\)</span>的左零因子。同理可以定义环<spanclass="math inline">\(R\)</span>的右零因子。</p><p>若<span class="math inline">\(a\)</span>既是环<spanclass="math inline">\(R\)</span>的左零因子，又是环<spanclass="math inline">\(R\)</span>的右零因子，它就是环<spanclass="math inline">\(R\)</span>的零因子。</p><p>1.1</p><blockquote><p>如果一个环<spanclass="math inline">\(R\)</span>有左零因子，它也一定有右零因子</p></blockquote><p><strong><font color='orange'>Proof:</font></strong></p><p>注意到若<span class="math inline">\(a\neq 0\inR\)</span>是左零因子，则<span class="math inline">\(\exist b\neq0,ab=0\)</span>，故<span class="math inline">\(b\)</span>是<spanclass="math inline">\(R\)</span>的右零因子。 <spanclass="math inline">\(\square\)</span></p><p>该结论将左右零因子的地位反过来也是同理的。</p><p>1.2</p><blockquote><p><span class="math inline">\(R\)</span>为无零因子环<spanclass="math inline">\(\LeftrightarrowR\)</span>中关于乘法的左(右)消去律成立（此处消去律是针对非零元的）</p></blockquote><p><strong><font color='orange'>Proof:</font></strong></p><p><span class="math inline">\(\Leftarrow:\)</span></p><p>若<span class="math inline">\(R\)</span>中左消去律成立。若<spanclass="math inline">\(a\neq 0\)</span>，有<spanclass="math inline">\(ab=0\)</span>,则<spanclass="math inline">\(a*b=0=a*0\)</span>,故由左消去律知<spanclass="math inline">\(b=0\)</span>,故<spanclass="math inline">\(R\)</span>中没有左零因子，同理可得<spanclass="math inline">\(R\)</span>中没有右零因子。</p><p><span class="math inline">\(\Rightarrow:\)</span></p><p>设环<span class="math inline">\(R\)</span>无左零因子。若有<spanclass="math inline">\(ab=ac\)</span>,则<spanclass="math inline">\(ab-ac=a(b-c)=0\)</span>,<spanclass="math inline">\(a\neq 0\)</span>时，由<spanclass="math inline">\(R\)</span>无左零因子，故<spanclass="math inline">\(b-c=0\)</span>，即<spanclass="math inline">\(b=c\)</span>,左消去律得证。</p><p>由<strong>环<span class="math inline">\(R\)</span>无左零因子，故<spanclass="math inline">\(R\)</span>也没有右零因子</strong>，同理得右消去律成立<span class="math inline">\(\square\)</span></p><p>由此我们马上就知道：</p><p>1.3</p><blockquote><p>环<span class="math inline">\(R\)</span>中左右消去律等价</p></blockquote><p>这是因为左消去律成立，就能知道<spanclass="math inline">\(R\)</span>是无零因子环，从而<spanclass="math inline">\(R\)</span>满足右消去律。反之同理。</p><h2 id="单位元">单位元：</h2><p>定义为环<spanclass="math inline">\(R\)</span>关于乘法的群的单位元。</p><p>即 <span class="math display">\[若e为R的单位元，则\forall x\in R,ex=xe=x\]</span> 一般默认<span class="math inline">\(e\neq 0\)</span></p><h3 id="可逆元">可逆元：</h3><p>对于<span class="math inline">\(a\in R\)</span>,若<spanclass="math inline">\(\exist b\in R,S.T.\)</span> <spanclass="math inline">\(ab=ba=e\)</span>,则<spanclass="math inline">\(a\)</span>是环<spanclass="math inline">\(R\)</span>的可逆元</p><h2 id="可逆元与零元">可逆元与零元</h2><h3 id="z_n中的可逆元与零元"><spanclass="math inline">\(Z_n中的可逆元与零元\)</span></h3><p>1.4</p><blockquote><p><span class="math inline">\(\bar{x}\)</span>为<spanclass="math inline">\(Z_n\)</span>的可逆元<spanclass="math inline">\(\Leftrightarrow\)</span> <spanclass="math inline">\((x,n)=1\)</span></p></blockquote><p><strong><font color='orange'>Proof:</font></strong></p><p><span class="math inline">\(\bar{x}\)</span>为<spanclass="math inline">\(Z_n\)</span>的可逆元<spanclass="math inline">\(\Leftrightarrow\)</span> <spanclass="math inline">\(\exist \bar{y}\in R,xy\equiv 1(mod n)\)</span>$kZ,xy+kn=1 $ <span class="math inline">\(\Leftrightarrow\)</span> <spanclass="math inline">\((x,n)=1\)</span></p><p><span class="math inline">\(\square\)</span></p><p>1.5</p><blockquote><p><span class="math inline">\(\bar{x}\)</span>为<spanclass="math inline">\(Z_n\)</span>的零因子<spanclass="math inline">\(\Leftrightarrow\)</span> <spanclass="math inline">\((x,n)\neq 1\)</span></p></blockquote><p><strong><font color='orange'>Proof:</font></strong></p><p>考虑 <span class="math display">\[n=\prod_{i=1}^{k} p_i^{\alpha_i},x=\prod_{i=1}^{d}q_i^{\beta_i}\]</span> 若<span class="math inline">\((x,n)=d&gt;1\)</span>,则<spanclass="math inline">\(x(n/d)\equiv 0(mod n)\)</span>,故<spanclass="math inline">\(x\)</span>为<spanclass="math inline">\(Z_n\)</span>的零因子</p><p>反之，若<span class="math inline">\(x\)</span>为<spanclass="math inline">\(Z_n\)</span>的零因子,则<spanclass="math inline">\(\exist d,xd\equiv 0(mod n)\)</span>,即<spanclass="math inline">\(n|xd\)</span></p><p>若<span class="math inline">\((x,n)=1\)</span>,则<spanclass="math inline">\(n|d\)</span>,这与<spanclass="math inline">\(d&lt;n\)</span>矛盾。故<spanclass="math inline">\((x,n)&gt;1\)</span></p><p><span class="math inline">\(\square\)</span></p><p>从而，我们得知，在环<span class="math inline">\(Z_n\)</span>中，<font color='green'><strong>零因子与可逆元交集为空</strong></font>。这不是偶然</p><p>1.6</p><blockquote><p>环<span class="math inline">\(R\)</span>的可逆元一定不是零因子</p></blockquote><p><strong><font color='orange'>Proof:</font></strong></p><p>若<span class="math inline">\(a\)</span>为环<spanclass="math inline">\(R\)</span>的可逆元，且<spanclass="math inline">\(a\)</span>为零因子，则<spanclass="math inline">\(\exist b\neq 0,ab=0=a0\)</span>,又<spanclass="math inline">\(a\)</span>为可逆元，由左消去律知<spanclass="math inline">\(b=0\)</span>,这与<span class="math inline">\(b\neq0\)</span>矛盾。</p><p><span class="math inline">\(\square\)</span></p><p>若<spanclass="math inline">\(a\)</span>同时为可逆元，零因子，则与上述结论矛盾。故得可逆元一定不是零因子，零因子一定不是可逆元。</p><p>由证明过程不难得到如下推论：</p><p>1.6.2</p><blockquote><p>环<spanclass="math inline">\(R\)</span>的左右零因子一定不是可逆元</p></blockquote><p><spanclass="math inline">\(Z_n\)</span>的例子仿佛告诉我们虽然两者交集为空，但是覆盖了所有非零元。但是</p><p>1.7</p><p><strong><font color='red'>事实上两者并不一定覆盖所有非零元</font></strong>。</p><p><font color='red'>比如环<spanclass="math inline">\(2Z\)</span>没有零因子（毕竟<spanclass="math inline">\(Z\)</span>都没有），但是也没有单位元，自然也没有可逆元的说法。</font></p><p>不过事实上在<spanclass="math inline">\(R\)</span>为有单位元的有限环的时候还是有点关系的。</p><p>1.8</p><blockquote><p>在有单位元的有限交换环<spanclass="math inline">\(R\)</span>中，任一不是零因子的非零元一定是可逆元</p></blockquote><p><strong><font color='orange'>Proof:</font></strong></p><p>可以设<spanclass="math inline">\(R=\{a_1,a_2,...a_n\}\)</span>,若<spanclass="math inline">\(a_i\neq 0\)</span>,且不为零因子，则<spanclass="math inline">\(a_iR=\{a_ia_1,a_ia_2,...a_ia_n\}\)</span>的元素两两不等（若<spanclass="math inline">\(a_ia_x=a_ia_y\)</span>,则<spanclass="math inline">\(a_i(a_x-a_y)=0\)</span>,由<spanclass="math inline">\(a_i\)</span>不为零因子，故<spanclass="math inline">\(a_x=a_y\)</span>,这与初始条件矛盾），故<spanclass="math inline">\(|a_iR|=|R|\)</span>,又<spanclass="math inline">\(a_iR\subseteq R\)</span></p><p>故<span class="math inline">\(a_iR=R\)</span>，故<spanclass="math inline">\(\exist a_j\neq 0 ,a_ia_j=1\)</span>,故<spanclass="math inline">\(a_i\)</span>为<spanclass="math inline">\(R\)</span>的左逆元。</p><p>又<span class="math inline">\(R\)</span>交换，故<spanclass="math inline">\(a_ja_i=1\)</span>,从而<spanclass="math inline">\(a_i\)</span>为可逆元 <spanclass="math inline">\(\square\)</span></p><h2 id="整环">整环：</h2><p>有单位元，无零因子，交换的环</p><h2 id="除环">除环：</h2><p>至少有两个元素，非零元关于乘法做成群的环</p><p>由定义可知除环一定有单位元，无零因子。（非零元关于乘法做成群，必定有单位元，也必定满足封闭性）</p><h2 id="域">域：</h2><p>交换除环</p><p>由除环性质可知，域在除环的基础上加了交换性，从而<strong>域一定是一个整环</strong></p><p>1.9</p><blockquote><p>有限整环是一个域</p></blockquote><p><strong><font color='orange'>Proof:</font></strong></p><p>显然只需证非零元关于乘法做成群即可，又只需证每一个元素可逆。这一点的证明与1.8的证明几乎一样。<span class="math inline">\(\square\)</span></p><p>需要注意的是，该证明显然只对有限环成立。</p><p>1.10</p><blockquote><p><span class="math inline">\(Z_m\)</span>为域<spanclass="math inline">\(\Leftrightarrow\)</span> m为素数</p></blockquote><p><strong><font color='orange'>Proof：</font></strong></p><p><span class="math inline">\(Z_m\)</span>是一个域<spanclass="math inline">\(\Leftrightarrow\)</span> <spanclass="math inline">\(Z_m\)</span>是一个整环<spanclass="math inline">\(\Leftrightarrow\)</span> <spanclass="math inline">\(Z_m\)</span>无零因子<spanclass="math inline">\(\Leftrightarrow\)</span> <spanclass="math inline">\(m\)</span>为素数</p><p>第二个等价符号是因为<spanclass="math inline">\(Z_m\)</span>本身已经满足可交换和有单位元的性质了</p><p><span class="math inline">\(\square\)</span></p><h2 id="环的特征">环的特征</h2><p>设<spanclass="math inline">\(R\)</span>是一个环，如果存在最小的正整数<spanclass="math inline">\(n\)</span>，使得 <span class="math display">\[\forall x\in R,nx=0\]</span> 则称<span class="math inline">\(n\)</span>为环<spanclass="math inline">\(R\)</span>的特征，记为<spanclass="math inline">\(ChR\)</span></p><p>若不存在这样的<span class="math inline">\(n\)</span>，称环<spanclass="math inline">\(R\)</span>的特征为<strong>无限</strong></p><p><font color='red'><strong>不难发现,<spanclass="math inline">\(ChR\)</span>就是环内所有元素关于加法的阶的</strong><spanclass="math inline">\(Lcm\)</span></font></p><p>1.11</p><blockquote><p>若<span class="math inline">\(R\)</span>有单位元，则<spanclass="math inline">\(ChR\)</span>等于单位元1关于加法的阶<spanclass="math inline">\(n\)</span></p></blockquote><p><strong><font color='orange'>Proof:</font></strong></p><p>显然<span class="math inline">\(ChR\geq |1|=n\)</span>。</p><p><span class="math inline">\(\forall x\inR,nx=n(1*x)=(n1)*x=0*x=0\)</span>,故<span class="math inline">\(|x||n\)</span></p><p>从而<span class="math inline">\(ChR\leq n\)</span></p><p>从而<span class="math inline">\(ChR=n\)</span> <spanclass="math inline">\(\square\)</span></p><p>1.12</p><blockquote><p>若环<spanclass="math inline">\(R\)</span><font color='red'><strong>无零因子</strong></font>，则<spanclass="math inline">\(R\)</span>中所有非零元关于加法的阶都相同，从而<spanclass="math inline">\(ChR\)</span>等于任意非零元的关于加法的阶。另外，此时<strong><spanclass="math inline">\(ChR\)</span>为素数</strong></p></blockquote><p><strong><font color='orange'>Proof:</font></strong></p><p>若<spanclass="math inline">\(R\)</span>中所有元素的阶都是无限的，该结论显然正确。</p><p>否则<span class="math inline">\(\exist x\inR,|x|=n\)</span>为一个有限正整数。从而<spanclass="math inline">\(nx=0\)</span>。此时 <span class="math display">\[\forall y\neq 0 \in R,x*(ny)=(nx)*y=0*y=0\]</span> 又环中无零因子，从而<spanclass="math inline">\(ny=0\)</span>，从而<spanclass="math inline">\(|y|\leq |x|\)</span></p><p>此时<spanclass="math inline">\(|y|\)</span>也有限，我们交换一下x，y的位置马上得到：<spanclass="math inline">\(|y|\geq |x|\)</span></p><p>从而<span class="math inline">\(|x|=|y|\)</span>。从而<spanclass="math inline">\(R\)</span>中所有非零元关于加法的阶都相同。</p><p>接下来证明第二个子结论。若<span class="math inline">\(\exist1&lt;k,t&lt;n\in Z,k*t=n\)</span>,即<spanclass="math inline">\(n\)</span>为一个合数，</p><p><span class="math inline">\(\forall x\in R^{*},x^2\inR\)</span>,从而<span class="math inline">\(|x|=|x^2|=n\)</span>,故 <spanclass="math display">\[0=n*x^{2}=kt*x^{2}=(kx)(tx)=0\]</span> 又<font color='red'><spanclass="math inline">\(R\)</span>没有零因子</font>，故<spanclass="math inline">\(kx=0或tx=0\)</span>,这与<spanclass="math inline">\(|x|=n\)</span>矛盾。</p><p>从而<span class="math inline">\(n\)</span>为素数</p><p><span class="math inline">\(\square\)</span></p><p>不难得到以下推论</p><p>1.13</p><blockquote><p>整环的特征为素数，从而域的特征为素数</p></blockquote><h1 id="子环">子环</h1><p><img src="https://s2.loli.net/2023/12/27/jCHtAnwarGSDZ8v.png" alt="绘图1" style="zoom:40%;" /></p><h2 id="定义">定义：</h2><p>设<span class="math inline">\(S\)</span>是环<spanclass="math inline">\(R\)</span>的<font color='red'>非空子集</font>，若<spanclass="math inline">\(S\)</span>关于<spanclass="math inline">\(R\)</span>的加法，乘法也做成环，则<spanclass="math inline">\(S\)</span>是环<spanclass="math inline">\(R\)</span>的子环</p><h3 id="判定">判定</h3><p>2.1</p><blockquote><p>若<span class="math inline">\(S\)</span>是环<spanclass="math inline">\(R\)</span>的非空子集，则<spanclass="math inline">\(S\)</span>是<spanclass="math inline">\(R\)</span>的子环的充要条件： <spanclass="math display">\[\forall a,b\in S\\\begin{flalign}&amp;(1)a-b\in S,\\&amp;(2)ab\in S\end{flalign}\]</span></p></blockquote><p><strong><font color='orange'>Proof:</font></strong></p><p>条件(1)与<spanclass="math inline">\(S\)</span>关于加法做成群等价。接下来证<spanclass="math inline">\(S\)</span>是半群即可。<spanclass="math inline">\(R\)</span>已经满足运算的合理性，结合律，我们只要封闭性即可。这一点由(2)保证，且是等价的。</p><p><span class="math inline">\(\square\)</span></p><h2 id="循环环的子环">循环环的子环：</h2><p>2.2</p><blockquote><p>循环环的子环<span class="math inline">\(\Leftrightarrow\)</span>循环环的加法子群</p></blockquote><p><font color='orange'><strong>Proof：</strong></font></p><p>设<span class="math inline">\(R=(a)=\{ka|k\inZ\}\)</span>为循环环</p><p><span class="math inline">\(\Leftarrow:\)</span></p><p><span class="math inline">\(S\)</span>为<spanclass="math inline">\(R\)</span>的子群，则<spanclass="math inline">\(\exist l\in Z,S=(la)=\{k(la)|k\inZ\}\)</span>,从而 <span class="math display">\[\forall k_1(la),k_2(la)\in R,k_1(la)*k_2(la)=k_1k_2l^2a^2\\a^2\in R,故\exist s\in Z,sa=a^2\\从而\\k_1(la)*k_2(la)=k_1k_2ls(la)\in (la)=S\]</span> 故<spanclass="math inline">\(S\)</span>关于乘法封闭。显然<spanclass="math inline">\(S\)</span>关于加法做成群，故<spanclass="math inline">\(S\)</span>是<spanclass="math inline">\(R\)</span>的子环。</p><p><span class="math inline">\(\Rightarrow:\)</span></p><p>显然</p><p><span class="math inline">\(\square\)</span></p><h2 id="子环关于交的封闭性">子环关于交的封闭性</h2><p>2.3</p><blockquote><p>环<spanclass="math inline">\(R\)</span>的若干个子环的交仍是子环。将子环换成子整环，子除环，子域显然也是正确的。</p></blockquote><p>这个不证了。</p><p>从而我们可以引出生成子环的概念。至于为什么生成子环是由该性质引出的，看证明就能明白。</p><h3 id="生成子环">生成子环</h3><p>设<span class="math inline">\(T\)</span>是<spanclass="math inline">\(R\)</span>的一个非空子集，若<spanclass="math inline">\(R\)</span>的子环<spanclass="math inline">\(S\)</span>满足 <span class="math display">\[\begin{flalign}&amp;(1) T\subseteq S\\&amp;(2) \forall S&#39;&lt;R且T\subseteq S&#39;,S\subseteq S&#39;\end{flalign}\]</span> 则<span class="math inline">\(S\)</span>称为<spanclass="math inline">\(T\)</span>生成的子环，记为<spanclass="math inline">\(S=[T]\)</span></p><h4 id="生成子环的存在性">2.4 生成子环的存在性</h4><p><font color='orange'><strong>Proof:</strong></font></p><p>我们需要对于一个集合<spanclass="math inline">\(T\)</span>,其生成子环总是存在的，并且满足上述性质。概括一下就是包含<spanclass="math inline">\(T\)</span>的<strong>最小</strong>子环。可以取所有包含<spanclass="math inline">\(T\)</span>的子环的交，先证其最小，再证其为子环。</p><p>记<span class="math inline">\(\{S_i|i\in I\}\)</span>为包含<spanclass="math inline">\(T\)</span>的子环集合。显然<spanclass="math inline">\(T\subseteq R,R为环\)</span>,故<spanclass="math inline">\(\{S_i|i\in I\}\)</span>非空。</p><p>取<span class="math inline">\(S=\bigcap_{i\inI}S_i,S\)</span>的最小性显然。注意到 <span class="math display">\[\forall i\in I,T\subseteq S_i\]</span> 故 <span class="math display">\[T\subseteq \bigcap_{i\in I}S_i=S\]</span> 又<spanclass="math inline">\(S\)</span>是若干个子环的交，故<spanclass="math inline">\(S\)</span>是一个子环。从而<spanclass="math inline">\(S\)</span>是包含<spanclass="math inline">\(T\)</span>的最小子环，<spanclass="math inline">\(S=[T]\)</span></p><p>存在性得证,且 <span class="math display">\[[T]=\bigcap_{i\in I}S_i\]</span> <span class="math inline">\(\square\)</span></p><h4 id="生成子环t的元素形式">生成子环[T]的元素形式</h4><p>任取<span class="math inline">\(t_1,t_2,...t_k\in T\)</span>,则 <spanclass="math display">\[\pm t_1t_2...t_k\in [T]\]</span> 从而由子环对加法的封闭性知 <span class="math display">\[\{\sum \pm t_1t_2...t_k|t_i\in T,k\in Z^{+}\}\subseteq [T]\]</span> 又不难证明 <span class="math display">\[\{\sum \pm t_1t_2...t_k|t_i\in T,k\in Z^{+}\}是一个子环\]</span> 且显然它包含<span class="math inline">\(T\)</span>。由<spanclass="math inline">\([T]\)</span>的最小性可知 <spanclass="math display">\[[T]\subseteq \{\sum \pm t_1t_2...t_k|t_i\in T,k\in Z^{+}\}\]</span> 从而 <span class="math display">\[[T]= \{\sum \pm t_1t_2...t_k|t_i\in T,k\in Z^{+}\}\]</span> 这就是生成子环<spanclass="math inline">\([t]\)</span>的元素形式。</p><p>2.5</p><blockquote><p>当<span class="math inline">\(T=\{a\}\)</span>时, <spanclass="math display">\[[T]=\{\sum n_ia^{i}|i\in Z^{+},n_i\in Z\}\]</span></p></blockquote><h1 id="环同态">环同态</h1><p>其实与群同态是类似的，要求映射满足加法保持运算，乘法保持运算即可。</p><h4 id="性质">性质：</h4><ul><li>0元保持不变</li><li>像的逆等于逆的像</li></ul><p>以上两条由加法群同态保证.若f是一个<spanclass="math inline">\(R\)</span>到<spanclass="math inline">\(R&#39;\)</span>的<font color='red'>满射</font>，则</p><ul><li>若<span class="math inline">\(R\)</span>是交换群，则<spanclass="math inline">\(R&#39;\)</span>也是交换群</li><li>若<span class="math inline">\(R\)</span>有单位元1，则<spanclass="math inline">\(R&#39;\)</span>也有单位元<spanclass="math inline">\(f(1)\)</span></li></ul><p>以上四条的逆均未必成立。</p><p>3.1</p><blockquote><p>构造<span class="math inline">\(Z_n\)</span>到<spanclass="math inline">\(Z_m\)</span>的环同态</p></blockquote><p><font color='orange'><strong>Start:</strong></font></p><p>环同态首先是群同态，由此我们需要满足： <span class="math display">\[\begin{flalign}&amp;(1) f(0)=0\\&amp;(2) nf(1)\equiv 0(mod m)\end{flalign}\]</span> 此时只需要保证<spanclass="math inline">\(f\)</span>关于乘法保持运算即可。</p><p>下面给出在加法满足群同态的情况下f关于乘法保持运算的充要条件： <spanclass="math display">\[f(1)\equiv f^{2}(1)(mod m)\]</span> <font color='green'><strong>Proof:</strong></font></p><p><span class="math inline">\(\Leftarrow:\)</span></p><p>已知<span class="math inline">\(f(1)\equiv f^{2}(1)(modm)\)</span>，<span class="math inline">\(\forall x,y\in R\)</span> <spanclass="math display">\[\begin{flalign}f(xy)&amp;=f(\underbrace{(1+1+...+1)}_{x个}*y)=f(\underbrace{y+y+...+y}_{x个})\\&amp;=xf(y)=x(yf(1))=xyf^{2}(1)=(xf(1))(yf(1))=f(x)f(y)\end{flalign}\]</span> <span class="math inline">\(\Rightarrow:\)</span></p><p>已知<span class="math inline">\(\forall x,y\inR,f(xy)=f(x)f(y)\)</span></p><p>带入<span class="math inline">\(x=y=1\)</span>即得证。</p><p><span class="math inline">\(\square\)</span></p><p>从而，f是<span class="math inline">\(Z_n\)</span>到<spanclass="math inline">\(Z_m\)</span>的充要条件为： <spanclass="math display">\[\begin{flalign}&amp;(1) f(0)=0\\&amp;(2) nf(1)\equiv 0(mod m)\\&amp;(3) f(1)\equiv f^{2}(1)(mod m)\end{flalign}\]</span> <font color='orange'><strong>End</strong></font></p><h1 id="理想">理想</h1><p><img src="https://s2.loli.net/2023/12/27/kwFLon3ZBCl1H2r.png" alt="理想" style="zoom:25%;" /></p><p>从理想开始就算是正式进入环论了。</p><h2 id="定义-1">定义</h2><p>设<span class="math inline">\(I\)</span>是环<spanclass="math inline">\(R\)</span>的一个非空子集，若 <spanclass="math display">\[\begin{flalign}&amp;(1) \forall a,b\in I,a-b\in I\\&amp;(2) \forall a\in I,\forall b\in R,ab,ba\in I\end{flalign}\]</span> 则称<span class="math inline">\(I\)</span>是环<spanclass="math inline">\(R\)</span>的理想</p><p>显然理想必定是子环，但是子环不一定是理想。</p><p>任意一个非零环<span class="math inline">\(R\)</span>都含有<spanclass="math inline">\(\{0\}和R\)</span>本身这两个理想，它们称为平凡理想。除此之外的理想称为<spanclass="math inline">\(R\)</span>的真理想。</p><h2 id="单环">单环</h2><p>4.1</p><blockquote><p>设<span class="math inline">\(R\)</span>是一个有单位元的环，<spanclass="math inline">\(R\)</span>的每一个真理想都不可能含有单位元</p></blockquote><p><font color='orange'><strong>Proof:</strong></font></p><p>设<span class="math inline">\(I\)</span>是<spanclass="math inline">\(R\)</span>的一个真理想。若<spanclass="math inline">\(1\in I\)</span>，则 <span class="math display">\[\forall x\in R,x=1*x\in I\]</span> 从而<span class="math inline">\(I=R\)</span>,这与<spanclass="math inline">\(I\)</span>是<spanclass="math inline">\(R\)</span>的真理想矛盾。 <spanclass="math inline">\(\square\)</span></p><blockquote><p>不含有真理想的环<span class="math inline">\(R\)</span>称为单环</p></blockquote><p>4.2</p><blockquote><p>除环，域都是单环</p></blockquote><p><font color='orange'><strong>Proof:</strong></font></p><p>设<span class="math inline">\(I\)</span>是域<spanclass="math inline">\(F\)</span>的一个真理想,则<spanclass="math inline">\(\exist x\in I,x\neq 0\)</span></p><p>从而<span class="math inline">\(x\in I,x^{-1}\in I,xx^{-1}=1\inI\)</span>,这与4.1的结论矛盾。（这里用到了<spanclass="math inline">\(F^{*}\)</span>是一个群，从而保证逆元存在，这一点除环和域是一样的）</p><p>从而<span class="math inline">\(I\)</span>不是<spanclass="math inline">\(F\)</span>的真理想。 <spanclass="math inline">\(\square\)</span></p><p>4.3</p><blockquote><p>设<span class="math inline">\(R\)</span>是一个有单位元<spanclass="math inline">\(1\)</span>的交换环。若<spanclass="math inline">\(R\)</span>没有非平凡的理想，则<spanclass="math inline">\(R\)</span>是一个域</p></blockquote><p><font color='orange'><strong>Proof:</strong></font></p><p>要证<spanclass="math inline">\(R\)</span>是一个域，我们现在只需要证明<spanclass="math inline">\(R^{*}\)</span>关于乘法做成群即可。如此只需要验证乘法封闭性以及每一个非零元的可逆性即可。</p><p><strong><font color='red'>注意到可逆元一定不是非零元，从而保证了乘法封闭。</font></strong></p><p>所以我们只需验证每一个元素可逆即可。</p><p>任取<span class="math inline">\(a\in R\)</span>,考虑 <spanclass="math display">\[aR=\{ar|r\in R\}\]</span> 显然该集合关于加法做成群。且 <span class="math display">\[\forall ar\in aR,x\in R\\\exist d\in R,d=rx=xr\]</span> 从而 <span class="math display">\[(ar)*x=a*(rx)=ad\in aR\\x*(ar)=(xr)*a=ad\in aR\]</span> 故<span class="math inline">\(aR\)</span>是<spanclass="math inline">\(R\)</span>的一个理想。又<spanclass="math inline">\(R\)</span>不含真理想，且<spanclass="math inline">\(a\in aR\)</span>,从而<spanclass="math inline">\(aR=R\)</span></p><p>故 <span class="math display">\[\exist x\in R,ax=xa=1\]</span> 从而<spanclass="math inline">\(a\)</span>可逆。由此我们证得每一个非零元都是可逆的。</p><p>故<span class="math inline">\(R\)</span>是一个域。 <spanclass="math inline">\(\square\)</span></p><blockquote><p>这种算是一个常见套路了。通过构造环的左陪集=环本身来证明元素的可逆性，这一点在这里和证明有限整环是域的时候都用过。只不过之前是用无零因子来证明相等，而这里使用无真理想来证明，实际上也推出了无零因子</p></blockquote><p>从4.2和4.3我们不难得到下述结论</p><p>4.4</p><blockquote><p>这<spanclass="math inline">\(R\)</span>是一个有单位元的交换环，则<spanclass="math inline">\(R\)</span>是域<strong>当且仅当</strong><spanclass="math inline">\(R\)</span>没有非平凡理想，即<spanclass="math inline">\(R\)</span>是单环</p></blockquote><p>证明从略。</p><h2 id="理想关于交的封闭性">理想关于交的封闭性</h2><blockquote><p>环<span class="math inline">\(R\)</span>的若干个理想的交仍是理想</p></blockquote><p>证明从略。</p><p>理想它首先是一个子环，所以子环的很多结论它都是可以对应过来的。那么跟子环一样，我们同样在这里可以导出生成理想的概念</p><h3 id="生成理想">生成理想</h3><p>设<span class="math inline">\(T\)</span>是环<spanclass="math inline">\(R\)</span>的一个非空子集，若存在<spanclass="math inline">\(R\)</span>的理想<spanclass="math inline">\(I\)</span>,使得 <span class="math display">\[\begin{flalign}&amp;(1) T\subseteq I\\&amp;(2) \forall I&#39;是R的理想,且T\subseteq I&#39;,有I\subseteq I&#39;\end{flalign}\]</span> 则<span class="math inline">\(I\)</span>称为集合<spanclass="math inline">\(T\)</span>的生成理想。记为<spanclass="math inline">\(I=(T)\)</span></p><h4 id="生成理想的存在性">生成理想的存在性</h4><p>我们很快注意到这一块跟子环是完全类似的。证明的思路也是一模一样。</p><p>先证包含<spanclass="math inline">\(T\)</span>的理想总是存在，再构造<spanclass="math inline">\(I=\bigcap_{i\in I}I_i\)</span>,其中<spanclass="math inline">\(I_i\)</span>的意义就是包含<spanclass="math inline">\(T\)</span>的所有理想。证明<spanclass="math inline">\(I\)</span>的最小性和以及它是一个理想即可。</p><p>设<spanclass="math inline">\(T=\{a_1,a_2....a_n\}\)</span>,则记理想<spanclass="math inline">\((T)=(a_1,a_2,...a_n)\)</span>.当<spanclass="math inline">\(T=\{a\}\)</span>时，称<spanclass="math inline">\((T)=(a)\)</span>为<spanclass="math inline">\(a\)</span>生成的主理想。</p><p>再来看看理想关于和的封闭性。</p><h2 id="理想关于和的封闭性">理想关于和的封闭性</h2><p>4.5</p><blockquote><p>设<span class="math inline">\(I_1,I_2\)</span>为<spanclass="math inline">\(R\)</span>的两个理想，则<spanclass="math inline">\(I_1+I_2\)</span>也是理想。</p></blockquote><p><strong><font color='orange'>Proof：</font></strong></p><p><span class="math inline">\(\forall x,y\in I_1+I_2,\forall r\inR\)</span>,记<spanclass="math inline">\(x=x_1+x_2,y=y_1+y_2\)</span>,其中<spanclass="math inline">\(x_1,y_1\in I_1,x_2,y_2\in I_2\)</span>.则 <spanclass="math display">\[x-y=x_1+x_2-y_1-y_2=(x_1-y_1)+(x_2-y_2)\in I_1+I_2\\rx=r(x_1+x_2)=rx_1+rx_2\in I_1+I_2\\xr=(x_1+x_2)r=x_1r+x_2r\in I_1+I_2\\\]</span> 从而<span class="math inline">\(I_1+I_2\)</span>是<spanclass="math inline">\(R\)</span>的理想 <spanclass="math inline">\(\square\)</span></p><p>进而得到下述结论：</p><p>4.6</p><blockquote><p>设<span class="math inline">\(a_1,a_2,..a_n\in R\)</span>,</p><p>则<spanclass="math inline">\((a_1,a_2,...a_n)=(a_1)+(a_2)+...+(a_n)\)</span></p></blockquote><p><strong><font color='orange'>Proof:</font> </strong></p><p>记<spanclass="math inline">\(I_1=(a_1,a_2,...a_n),I_2=(a_1)+(a_2)+...+(a_n)\)</span></p><p><span class="math inline">\(\forall a_i,a_i\in (a_i)\subseteqI_2\)</span></p><p>又<span class="math inline">\(I_1\)</span>是包含所有<spanclass="math inline">\(a_i\)</span>的最小理想，故<spanclass="math inline">\(I_1\subseteq I_2\)</span></p><p>又<span class="math inline">\((a_i)\)</span>是包含<spanclass="math inline">\(a_i\)</span>的最小理想，故<spanclass="math inline">\(\forall i\in [1,n],(a_i)\subseteq I_1\)</span></p><p>由理想对加法的封闭性，<span class="math inline">\(I_2\subseteqI_1\)</span></p><p>故<span class="math inline">\(I_1=I_2\)</span> <spanclass="math inline">\(\square\)</span></p><h3 id="理想与主理想的关系">理想与主理想的关系</h3><p>根据4.6，我们得到如下结论：</p><blockquote><p>每一个理想都是若干个主理想之和</p></blockquote><p>有了以上铺垫，我们就可以来探究生成理想的元素形式了。</p><h2 id="生成理想的元素形式">生成理想的元素形式</h2><p>由于4.6的结论，实际上我们只需要探究主理想的元素形式。</p><p>给出结论</p><blockquote><p>在<span class="math inline">\(R\)</span>中，<spanclass="math inline">\((a)=\{\sum x_iay_i+sa+at+na|x_i,y_i,s,t\in R ,n\inZ\}\)</span></p></blockquote><p>4.7</p><p>若<span class="math inline">\(R\)</span>是一个有单位元的环，则 <spanclass="math display">\[(a)=\{\sum x_iay_i|x_i,y_i\in R\}\]</span> 若<span class="math inline">\(R\)</span>是一个交换环，则 <spanclass="math display">\[(a)=\{\sum ra+na|r\in R,n\in Z\}\]</span> 若<spanclass="math inline">\(R\)</span>是一个有单位元的交换环，则 <spanclass="math display">\[(a)=\{ra|r\in R\}=aR=Ra\]</span></p><h2 id="循环环的理想">循环环的理想：</h2><p>在子环中已经讲过，循环环的子环等价于循环环关于加法的子群，事实上，循环环的子环也一定是理想，且为主理想。</p><p>4.8</p><blockquote><p>循环环的理想都是主理想</p></blockquote><p>设<span class="math inline">\(I\)</span>是循环环<spanclass="math inline">\(R=(a)\)</span>的理想,则<spanclass="math inline">\(I\)</span>也是<spanclass="math inline">\(R\)</span>的加法子群，故<spanclass="math inline">\(I=(sa)\)</span></p><p>下证<span class="math inline">\(I就是sa\)</span>生成的主理想</p><p><span class="math inline">\(sa\)</span>生成的主理想 <spanclass="math display">\[&lt;sa&gt;=\{r(sa)+n(sa)|r\in R,n\in Z\}\]</span> 显然<span class="math inline">\(&lt;sa&gt;\subseteqI\)</span></p><p>又 <span class="math display">\[\forall x=m(sa)\in I,x=0*(sa)+m*(sa)\in &lt;sa&gt;\]</span> 故<span class="math inline">\(I\subseteq&lt;sa&gt;\)</span></p><p>故<span class="math inline">\(I=&lt;sa&gt;\)</span> <spanclass="math inline">\(\square\)</span></p><p>从而</p><blockquote><p>在循环环中，子环<spanclass="math inline">\(\Leftrightarrow\)</span>理想<spanclass="math inline">\(\Leftrightarrow\)</span>主理想</p></blockquote><p>4.9</p><blockquote><p>设<span class="math inline">\(f\)</span>是<spanclass="math inline">\(R\)</span>到<spanclass="math inline">\(R&#39;\)</span>的一个环同态满射。<spanclass="math inline">\(I\)</span>是环<spanclass="math inline">\(R\)</span>的子集，<spanclass="math inline">\(I&#39;\)</span>是环<spanclass="math inline">\(R&#39;\)</span>的子集</p><p>则: <span class="math display">\[\begin{flalign}&amp;(1) 若I是环R的理想，则f(I)是环R&#39;的理想\\&amp;(2)若I&#39;是环R’的理想，则f^{-1}(I&#39;)是环R的理想，且Kerf\subseteqf^{-1}(I&#39;)&amp;\end{flalign}\]</span></p></blockquote><p>证明不难，可以看书的课后习题 3.4 9</p><p>但定理告诉我们，<strong><font color='red'>理想在同态满射下是保持的</font></strong>。并且需要指出的是，第二条结论并不需要满射的条件。</p><hr /><h2 id="商环">商环</h2><p>同群论中由不变子群引出商群一样，利用理想的概念，我们就可以引出商环的概念了。</p><blockquote><p>设<span class="math inline">\(I\)</span>是环<spanclass="math inline">\(R\)</span>的一个理想，那么记 <spanclass="math display">\[R/I=\{a+I|a\in R\}\]</span> 为<span class="math inline">\(R/I\)</span>的商集。</p><p>定义运算为: <span class="math display">\[(a+I)+(b+I)=(a+b)+I\\(a+I)*(b+I)=(ab)+I\\\]</span> 容易验证，<spanclass="math inline">\(R/I\)</span>关于新定义的乘法和加法做成环，故称它是环<spanclass="math inline">\(R\)</span>关于理想<spanclass="math inline">\(I\)</span>的商环。</p></blockquote><p><span class="math inline">\(R/I\)</span>中的元素也可以称为模<spanclass="math inline">\(I\)</span>的同余类，这一点可以通过<spanclass="math inline">\(Z\)</span>中<spanclass="math inline">\(Z/(n)\)</span>来理解</p><p>考虑 <span class="math display">\[n\in Z,(n)=\{kn|k\in Z\}\]</span> 则 <span class="math display">\[Z/(n)=\{x+(n)|x\in Z\}=\{a+nk|k\in Z\}\]</span> 此时<spanclass="math inline">\(Z/(n)\)</span>的实际含义是模<spanclass="math inline">\(n\)</span>的剩余类了，即 <spanclass="math display">\[Z/(n)=\{\overline{0},\overline{1},....\overline{n-1}\}\]</span> 从而模的意义得以体现。</p><p>eg：习题3.4 8</p><h1 id="环同态基本定理">环同态基本定理</h1><p>5.1</p><blockquote><p>环同态基本定理：</p><p>设<span class="math inline">\(f:R\rightarrowR&#39;\)</span>是一个环同态映射，则<spanclass="math inline">\(Kerf=\{x\in R|f(x)=0&#39;\}\)</span>是环<spanclass="math inline">\(R\)</span>的理想，且在<spanclass="math inline">\(R/Kerf\)</span>到<spanclass="math inline">\(R&#39;\)</span>之间存在唯一的<strong>单同态</strong>映射满足<spanclass="math inline">\(f=f_{*}\circ \phi\)</span>,其中<spanclass="math inline">\(\phi\)</span>为自然同态 <spanclass="math display">\[f_{*}:R/Kerf\rightarrow R&#39;\\x+Kerf\mapsto f(x)\]</span> 当<span class="math inline">\(f\)</span>为满射的时候，<spanclass="math inline">\(R/Kerf\cong R&#39;\)</span></p></blockquote><p>5.2 环同构第一定理</p><p><img src="https://s2.loli.net/2024/01/02/bTqU5fkWtgvLBVd.png" alt="image-20240102113208729" style="zoom:67%;" /></p><p><img src="https://s2.loli.net/2024/01/02/7IEY35OuHbscBPG.png" alt="image-20240102113238355" style="zoom:67%;" /></p><p>5.3 环同构第二定理</p><figure><img src="https://s2.loli.net/2024/01/02/B6JTHwafjluQCLg.png"alt="image-20240102110428653" /><figcaption aria-hidden="true">image-20240102110428653</figcaption></figure><p>设<span class="math inline">\(R[x]\)</span>是实数域<spanclass="math inline">\(\mathbb{R}\)</span>上的多项式环，<spanclass="math inline">\(I=(x^2+1)\)</span>，则 <spanclass="math display">\[R[x]/I\cong \Complex\]</span> <font color='orange'><strong>Proof:</strong></font></p><p>构造 <span class="math display">\[\phi:R[x]\rightarrow \Complex\\f(x)\mapsto f(i)\]</span> 容易证明<spanclass="math inline">\(\phi\)</span>是一个满同态映射从而 <spanclass="math display">\[R[x]/Ker\phi \rightarrow \Complex\]</span> 考虑证明<span class="math inline">\(Ker\phi=(1+x^2)\)</span><span class="math display">\[Ker\phi=\{f(x)|f(i)=0\}\]</span> 从而<span class="math inline">\(i\)</span>是<spanclass="math inline">\(f(x)=0\)</span>的一个根，由于实系数多项式方程的复根是成对出现的，所以<spanclass="math inline">\(-i\)</span>也是该方程的一个根</p><p>从而 <span class="math display">\[(1+x^2)|f(x),\forall f(x)\in Ker\phi\]</span> 即 <span class="math display">\[f(x)=(1+x^2)g(x),g(x)\in R[x]\]</span> 从而 <span class="math display">\[Ker\phi\subseteq (1+x^2)\]</span> 至于另一个方向，只要把<spanclass="math inline">\(i\)</span>代入即可。从而 <spanclass="math display">\[Ker\phi=(1+x^2)\]</span> <span class="math inline">\(\square\)</span></p><p>这个东西其实还是有点套路的，比如说，考虑有理数域<spanclass="math inline">\(\mathbb{Q}\)</span>上的多项式环<spanclass="math inline">\(Q[x]\)</span>,我们构造 <spanclass="math display">\[\phi:Q[x]\rightarrow R\\f(x)\mapsto f(\sqrt(2))\]</span> 容易验证<spanclass="math inline">\(\phi\)</span>是一个环同态（当然它不是满同态，因为<spanclass="math inline">\(\sqrt(3)\in \mathbb{Q}\)</span>，但它不属于<spanclass="math inline">\(Img\phi\)</span>）,而 <spanclass="math display">\[Ker\phi=\{ f(x)|f(\sqrt(2))=0 \}\]</span> 这与上一道题的思路是极其类似的，由于<spanclass="math inline">\(\sqrt(2)\)</span>是方程的一个根，那么<spanclass="math inline">\(-\sqrt(2)\)</span>也是方程的一个根，从而不难证明<span class="math display">\[Ker\phi=(x-(\sqrt(2))^2)=(x-2)\]</span></p><h1 id="素理想与极大理想">素理想与极大理想</h1><h2 id="素理想">素理想</h2><p>如果<span class="math inline">\(P\)</span>是环<spanclass="math inline">\(R\)</span>的一个<strong>理想</strong>，并且满足<span class="math display">\[\forall a,b\in R,若ab\in P,则a\in P,或b\in P\]</span> 则<span class="math inline">\(P\)</span>是环<spanclass="math inline">\(R\)</span>的一个素理想</p><p>对于素理想的判定：</p><p>对于一个<font color='red'>有单位元的交换环</font><spanclass="math inline">\(R\)</span>,若<spanclass="math inline">\(P\)</span>是环<spanclass="math inline">\(R\)</span>的一个理想，且<spanclass="math inline">\(P\neq R\)</span>，则 <span class="math display">\[P是环R的素理想\Leftrightarrow R/P是一个整环\]</span> 证明略</p><p>6.1</p><p>从而，我们考虑整数环下的素理想</p><p>我们知道，若<span class="math inline">\(P\)</span>是整数环<spanclass="math inline">\(R\)</span>的一个素理想，首先有<spanclass="math inline">\(P\)</span>是循环群，从而<spanclass="math inline">\(P=(m)\)</span>,于是根据上一判定定理， <spanclass="math display">\[Z/P=Z/(m)=Z_m是一个整环\Leftrightarrow m是一个素数\]</span> 从而，整数环除自身外的所有素理想为<spanclass="math inline">\(\{(m)|m是素数\}\)</span></p><p>我猜这可能也是素理想这个名字的由来？因为整数环中对应的理想都是素数生成的主理想hhh</p><p>我们继续考虑如下问题。令<spanclass="math inline">\(F\)</span>是一个域，<spanclass="math inline">\(F[x]\)</span>是<spanclass="math inline">\(F\)</span>上的多项式环，考虑 <spanclass="math display">\[\phi:F[x]\rightarrow F\\f(x)\mapsto a_0\]</span> 根据环同态的知识，我们不难验证<spanclass="math inline">\(\phi\)</span>是一个环同态满射，从而有 <spanclass="math display">\[F[x]/Ker\phi\cong F\]</span></p><p>不难验证 <span class="math display">\[Ker\phi=(x)\]</span> 从而 <span class="math display">\[F[x]/(x)\cong F\]</span> 这是一个普适结论。更深入的，<spanclass="math inline">\(F\)</span>是一个域，那么它当然是一个整环，于是我们得到</p><p>6.2</p><blockquote><p>若<spanclass="math inline">\(F\)</span>是一个域，F[x]是F上的多项式环，则<spanclass="math inline">\((x)\)</span>是<spanclass="math inline">\(F[x]\)</span>的素理想</p></blockquote><h2 id="极大理想">极大理想</h2><p>设<span class="math inline">\(M\)</span>是环<spanclass="math inline">\(R\)</span>的一个理想，并且<spanclass="math inline">\(M\neq R\)</span>,若 <spanclass="math inline">\(\forall R\)</span>的理想N满足 <spanclass="math display">\[M\subseteq N\subseteq R\]</span> 都有<span class="math inline">\(N=M\)</span>或<spanclass="math inline">\(N=R\)</span>，则称<spanclass="math inline">\(M\)</span>是环<spanclass="math inline">\(R\)</span>的一个极大理想</p><p>简单来说，就是<spanclass="math inline">\(R\)</span>中不存在能完全包含<spanclass="math inline">\(M\)</span>的真理想</p><p><strong>根据定义我们很快就能知道，一个环<spanclass="math inline">\(R\)</span>可以有多个极大理想，但是事实上<font color='red'>并不是每一个环都有极大理想 </font></strong></p><p>看看极大理想的判定定理，它与素理想的判定定理是极为类似的</p><p>6.3 极大理想的判定定理</p><blockquote><p>对于一个<font color='red'>有单位元的交换环</font><spanclass="math inline">\(R\)</span>,若<spanclass="math inline">\(P\)</span>是环<spanclass="math inline">\(R\)</span>的一个理想，且<spanclass="math inline">\(P\neq R\)</span>，则 <span class="math display">\[P是环R的极大理想\Leftrightarrow R/P是一个域\]</span></p></blockquote><p>证明略</p><p><font color='red'>该定理启示我们可以通过极大理想来构造一个域</font></p><p>还是来看看整数环的极大理想长什么样子</p><p>若<span class="math inline">\(P\)</span>是整数环<spanclass="math inline">\(R\)</span>的一个极大理想，首先有<spanclass="math inline">\(P\)</span>是循环群，从而<spanclass="math inline">\(P=(m)\)</span>,于是根据判定定理， <spanclass="math display">\[Z/P=Z/(m)=Z_m是一个域\Leftrightarrow m是一个素数\]</span> 跟整数环的素理想是同一个集合<spanclass="math inline">\(\{(m)|m是素数\}\)</span>,当然这也说明了一个环确实可以有多个极大理想</p><p>此外，根据素理想与极大理想的判定定理，两者唯一的区别就是一个的除环是整环，而另一个的除环是域，而显然域一定是一个除环，所以：</p><p>6.4</p><blockquote><p>一个有单位元的交换环<spanclass="math inline">\(R\)</span>的极大理想一定是它的素理想</p></blockquote><p>注意这里的前提是有单位元的交换环</p><p>6.5</p><p>设<span class="math inline">\(R=2\mathbb{Z}\)</span>是偶数环，<spanclass="math inline">\(p\)</span>是素数，问<spanclass="math inline">\((2p)\)</span>是否为<spanclass="math inline">\(R\)</span>的极大理想，是否为<spanclass="math inline">\(R\)</span>的素理想</p><p><spanclass="math inline">\(R\)</span>是一个无单位元的交换环，所以<spanclass="math inline">\((2p)=\{2p*2k+2p*s|k,s\in Z\}=\{2kp|k\inZ\}\)</span></p><p>下面证明<span class="math inline">\(\forall p\)</span>为素数，<spanclass="math inline">\((2p)\)</span>是<spanclass="math inline">\(2\mathbb{Z}\)</span>的极大理想</p><p>首先显然<span class="math inline">\((2p)\neq2\mathbb{Z}\)</span>,若有<spanclass="math inline">\(R\)</span>的理想<spanclass="math inline">\(M\)</span>，使得<spanclass="math inline">\((2p)\subseteq M\subseteq R\)</span></p><p>当<span class="math inline">\((2p)\subset M\)</span>时，<spanclass="math inline">\(\exist x\in M,x=2k,x\notin (2p)\)</span>,从而<spanclass="math inline">\(p\)</span>不整除<spanclass="math inline">\(k\)</span>,从而<spanclass="math inline">\((x,p)=1\)</span>,从而 <spanclass="math display">\[\exist s,t\in Z,xs+pt=1\]</span> 则 <span class="math display">\[(2x)s+(2p)t=2\]</span> 由于<span class="math inline">\(2x,2p\in M\)</span>，从而<spanclass="math inline">\(2\in M\)</span>.又<spanclass="math inline">\(M\)</span>是循环群<spanclass="math inline">\(2\mathbb{Z}\)</span>的理想，所以<spanclass="math inline">\(M\)</span>也是一个循环群，又<spanclass="math inline">\(2\in M\)</span>，所以<spanclass="math inline">\(M=(2)=R\)</span></p><p><strong>从而<span class="math inline">\((2p)\)</span>是环<spanclass="math inline">\(R\)</span>的极大理想</strong> （感觉有点难想）</p><p>接下来考虑素理想</p><p>当<span class="math inline">\(p=2\)</span>时,<spanclass="math inline">\((2p)=(4)\)</span>，由<spanclass="math inline">\(2*2=4,2\notin (2p)\)</span>可知，<spanclass="math inline">\((4)\)</span>不是<spanclass="math inline">\(R\)</span>的素理想</p><p>当<span class="math inline">\(p&gt;2\)</span>时，若<spanclass="math inline">\(2k*2l\in (2p),则2p|4kl\)</span>，从而<spanclass="math inline">\(p|k\)</span>或<spanclass="math inline">\(p|l\)</span>,从而<span class="math inline">\(2k\in(2p)\)</span>或<span class="math inline">\((2l)\in(2p)\)</span>，从而<span class="math inline">\((2p)\)</span>是素理想</p>]]></content>
    
    
    <categories>
      
      <category>抽象代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>抽象代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理实验七-sql简易编译器</title>
    <link href="/posts/4b8fdc0c/"/>
    <url>/posts/4b8fdc0c/</url>
    
    <content type="html"><![CDATA[<h2 id="实验内容">实验内容</h2><p>利用yacc编写一个简易的sql编译器，使其能够使用sql查询语句</p><h2 id="实验思路">实验思路</h2><h3 id="词法分析">词法分析</h3><p>需要解析的单词其实并不是很多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tokens=(<span class="hljs-string">&#x27;SELECT&#x27;</span>,<span class="hljs-string">&#x27;FROM&#x27;</span>,<span class="hljs-string">&#x27;WHERE&#x27;</span>,<span class="hljs-string">&quot;DOT&quot;</span>,<span class="hljs-string">&quot;MAX&quot;</span>,<span class="hljs-string">&quot;MIN&quot;</span>,<span class="hljs-string">&quot;LP&quot;</span>,<span class="hljs-string">&quot;RP&quot;</span>,<span class="hljs-string">&quot;EQUAL&quot;</span>,<span class="hljs-string">&quot;AVERAGE&quot;</span>,<span class="hljs-string">&#x27;AND&#x27;</span>,<span class="hljs-string">&#x27;ORDER&#x27;</span>,<span class="hljs-string">&#x27;OR&#x27;</span>,<span class="hljs-string">&#x27;BIGGER&#x27;</span>,<span class="hljs-string">&#x27;SMALLER&#x27;</span>,<span class="hljs-string">&#x27;BY&#x27;</span>,<span class="hljs-string">&#x27;DESC&#x27;</span>,<span class="hljs-string">&#x27;NAME&#x27;</span>)<br></code></pre></td></tr></table></figure><p>但是对一些细节还是需要注意。比如相同前缀的单词，要注意先后顺序，就如<spanclass="math inline">\(ORDER\)</span>和<spanclass="math inline">\(OR\)</span></p><h3 id="语法分析">语法分析</h3><p>首先，对于每一个节点，我们用一个结构体<spanclass="math inline">\(node\)</span>来记录其相关信息，包括其本身字段的内容，以及其子字段的信息等等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">node</span>:<br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data</span>):<br>        self._data = data<br>        self._children = []<br>        self._queryType = <span class="hljs-string">&quot;NONE&quot;</span><br>        self._order = <span class="hljs-number">0</span><br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getdata</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self._data<br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getchildren</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self._children<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getqueryType</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span>  self._queryType<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">changeType</span>(<span class="hljs-params">self,<span class="hljs-built_in">str</span></span>):<br>        self._queryType = <span class="hljs-built_in">str</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getorder</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self._order<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rorder</span>(<span class="hljs-params">self</span>):<br>        self._order = <span class="hljs-number">1</span><br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, node</span>):<br>        self._children.append(node)<br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_node</span>(<span class="hljs-params">self, prefix</span>):<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;  &#x27;</span>*prefix,<span class="hljs-string">&#x27;+&#x27;</span>,self._data)<br>        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> self._children:<br>            child.print_node(prefix+<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="无条件查询">无条件查询</h4><p>首先来实现最简单的无条件查询，并且只是查询最简单的字段信息</p><p>总结其基本的语法结构，得到如下格式</p><p>SELECT list FROM table</p><p>这里SELECT 和 FROM都是我们在词法分析中会直接分析出来的单词，list表示的是需要查询的字段的列表，table就是我们需要查询的数据源</p><p>那么不难得到如下的基本语法 <span class="math display">\[\begin{flalign}&amp;query\rightarrow select\\&amp;select \rightarrow SELECT \ list\  FROM \ table\\&amp;table \rightarrow NAME\\&amp; list \rightarrow NAME|*\\&amp; list \rightarrow list \ DOT NAME\end{flalign}\]</span>这里DOT在词法分析中表示逗号，NAME就不是其余关键字的一个名称，一般就是字段名或者是某一个常数之类的</p><p>那么这样的话一个查询语句最后会归结成一个query节点，我们就能够对其进行操作了</p><p>以下是对应的文法实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_query</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;query :  select&#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=t[<span class="hljs-number">1</span>]<br>        <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_select</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;select : SELECT list FROM table &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=node(<span class="hljs-string">&#x27;QUERY&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(node(<span class="hljs-string">&#x27;[SELECT]&#x27;</span>))<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">2</span>])<br>    t[<span class="hljs-number">0</span>].add(node(<span class="hljs-string">&#x27;[FROM]&#x27;</span>))<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">4</span>])<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_table</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;table : NAME&#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=node(<span class="hljs-string">&#x27;[TABLE]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">1</span>]))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_list</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; list : &#x27;*&#x27;</span><br><span class="hljs-string">             | NAME&#x27;&#x27;&#x27;</span><br><br>    t[<span class="hljs-number">0</span>]=node(<span class="hljs-string">&#x27;[FIELD]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">1</span>]))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_list_list_NAME</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; list : list DOT NAME&#x27;&#x27;&#x27;</span><br><br>    t[<span class="hljs-number">0</span>]=t[<span class="hljs-number">1</span>]<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">3</span>]))<br></code></pre></td></tr></table></figure><p>举例，对于查询语句</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> Chinese <span class="hljs-keyword">FROM</span> st<br></code></pre></td></tr></table></figure><p>来说，其查询的结构就如下所示</p><figure><img src="https://s2.loli.net/2024/01/01/oJciFNd2GgVKfzR.png" alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><h4 id="无条件查询数字特征">无条件查询数字特征</h4><p>还是无条件查询，但是加入max，min或者average等操作</p><p>这种查询与上一种的区别在于，上一种查询返回的结果是一个集合，但是这一种返回的是一个数字。事实上在后面越发复杂的查询语句中，我们是很有必要对查询语句返回的结果进行判断的，所以这一点需要特别注意</p><p>并且不难发现，这种查询与上一种查询的语句结构是互斥的，其结构如下</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(<span class="hljs-keyword">NAME</span>) <span class="hljs-keyword">FORM</span> table<br></code></pre></td></tr></table></figure><p>所以我们重新引入一个单词number用来表示需要对某一个字段进行取max或者取min或者取平均等一系列操作</p><p>这一点并不是十分困难，我们很快就能得到新增的文法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查询集合与查询满足条件的数字，这两种查询应该是互斥的</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_select_num</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;select : SELECT number FROM table &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>] = node(<span class="hljs-string">&#x27;QUERY&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].changeType(<span class="hljs-string">&quot;NUMBER&quot;</span>)<br>    t[<span class="hljs-number">0</span>].add(node(<span class="hljs-string">&#x27;[SELECT]&#x27;</span>))<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">2</span>])<br>    t[<span class="hljs-number">0</span>].add(node(<span class="hljs-string">&#x27;[FROM]&#x27;</span>))<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">4</span>])<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_MAX_query</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; max_num : MAX LP NAME RP &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>] = node(<span class="hljs-string">&#x27;[MAX]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">3</span>]))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_MIN_query</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; min_num : MIN LP NAME RP &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>] = node(<span class="hljs-string">&#x27;[MIN]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">3</span>]))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_AVERAGE_query</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; average_num : AVERAGE LP NAME RP &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>] = node(<span class="hljs-string">&#x27;[AVERAGE]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">3</span>]))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_NUMBER</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; number : max_num</span><br><span class="hljs-string">               | min_num</span><br><span class="hljs-string">               | average_num&#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>] = node(<span class="hljs-string">&#x27;[NUMBER]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>从而完成了该功能的分析</p><h4 id="条件查询">条件查询</h4><p>条件查询的基本格式如下</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">SELECT</span></span> ... FROM <span class="hljs-keyword">table</span> WHERE <span class="hljs-comment">...</span><br></code></pre></td></tr></table></figure><p>WHERE后面的格式还是比较复杂的，因为其能够嵌套许多AND以及OR关键字，这就让条件之间的交并关系难以处理。这里给出了简化，保证查询条件是一个<strong>主析取范式</strong>，也就是</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-built_in">A1</span> <span class="hljs-keyword">AND </span><span class="hljs-built_in">A2</span> <span class="hljs-keyword">AND </span><span class="hljs-built_in">A3</span><br></code></pre></td></tr></table></figure><p>这样的形式，并且</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Ai = <span class="hljs-built_in">a1</span> <span class="hljs-keyword">OR </span><span class="hljs-built_in">a2</span> <span class="hljs-keyword">OR </span><span class="hljs-built_in">a3</span><br></code></pre></td></tr></table></figure><p>每一个ai就是一个基本的比较式子</p><p>如此我们就能得到WHERE后面的条件的格式了。</p><p>首先描述基本比较式子，可以是字段与常数之间的比较，也可以是字段与一个查询之间的比较</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_compare_expresion</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; compare : NAME BIGGER NAME</span><br><span class="hljs-string">                | NAME SMALLER NAME</span><br><span class="hljs-string">                | NAME EQUAL NAME&#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=node(<span class="hljs-string">&#x27;[COMPARE]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">2</span>]))<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">1</span>]))<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">3</span>]))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_compare_expresion_query</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; compare : NAME BIGGER query</span><br><span class="hljs-string">                | NAME SMALLER query</span><br><span class="hljs-string">                | NAME EQUAL query&#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=node(<span class="hljs-string">&#x27;[COMPARE]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">2</span>]))<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">1</span>]))<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><p>然后描述析取范式，也就是一个个基本比较式之间进行合并</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_compare_compare</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; or : compare OR compare&#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=node(<span class="hljs-string">&#x27;[or]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">1</span>])<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">3</span>])<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_or_compare</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; or : or OR compare&#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=t[<span class="hljs-number">1</span>]<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">3</span>])<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_xiqu_or</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; xiqu : or &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=node(<span class="hljs-string">&#x27;[OR]&#x27;</span>)<br>    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> t[<span class="hljs-number">1</span>].getchildren():<br>        t[<span class="hljs-number">0</span>].add(x)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_xiqu_compare</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; xiqu : compare &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=node(<span class="hljs-string">&#x27;[OR]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>最后描述主合取范式，也就是析取范式之间进行合并</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_heuq</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; hequ : xiqu &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=node(<span class="hljs-string">&#x27;[AND]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">1</span>])<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_hequ_xiqu</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; hequ : hequ AND xiqu&#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=t[<span class="hljs-number">1</span>]<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">3</span>])<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_WHERE_condition</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; condition : WHERE hequ &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>] = node(<span class="hljs-string">&#x27;[WHERE]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>举例，对于查询语句</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM st WHERE Chinese &lt; <span class="hljs-number">100</span> OR Math&lt;<span class="hljs-number">100</span> AND English&gt;<span class="hljs-number">100</span> AND Total&gt;<span class="hljs-number">100</span> OR Math &gt;<span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><p>其结构如下</p><p><img src="https://s2.loli.net/2024/01/01/rdjJvbHo3tQPTgi.png" alt="2" style="zoom:67%;" /></p><p>如此就完成了条件查询</p><h4 id="嵌套查询">嵌套查询</h4><p>这一点其实比较好处理，因为对于每一个查询来说，它最终都会归结为一个节点。所以我们只要递归调用处理查询的函数，就能实现嵌套查询了</p><p>比如对于查询表达式</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> st <span class="hljs-keyword">WHERE</span> Math=(<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(Math) <span class="hljs-keyword">FROM</span> st)<br></code></pre></td></tr></table></figure><p>其结构如下所示</p><figure><img src="https://s2.loli.net/2024/01/01/CJIztExB7ZDdAHS.png" alt="3" /><figcaption aria-hidden="true">3</figcaption></figure><p>还是比较简单的</p><h4 id="关键字排序">关键字排序</h4><p>如果前面的都已经做完了的话，这一步相对来说还是比较简单的，我们只要加上对ORDER，By关键字的识别即可</p><p>对应的文法也很好写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_selsect_ordet</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; select : select order&#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=t[<span class="hljs-number">1</span>]<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">2</span>])<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_order</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; order : ORDER BY NAME&#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=node(<span class="hljs-string">&#x27;[ORDER]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">3</span>]))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_order_x</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; order : ORDER BY paixu&#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=node(<span class="hljs-string">&#x27;[ORDER]&#x27;</span>)<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">3</span>])<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_paixu</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; paixu : NAME DESC &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>] = node(t[<span class="hljs-number">1</span>])<br>    t[<span class="hljs-number">0</span>].rorder()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_order_NAME</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; order : order DOT NAME &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=t[<span class="hljs-number">1</span>]<br>    t[<span class="hljs-number">0</span>].add(node(t[<span class="hljs-number">3</span>]))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_order_paixu</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27; order : order DOT paixu &#x27;&#x27;&#x27;</span><br>    t[<span class="hljs-number">0</span>]=t[<span class="hljs-number">1</span>]<br>    t[<span class="hljs-number">0</span>].add(t[<span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><p>这里还涉及DESC带来的逆序排序的问题，我们只要在node结构体中添加一个描述是否为逆序排序的flag即可</p><h3 id="具体实现">具体实现</h3><h4 id="对查询节点的分析">对查询节点的分析：</h4><p>找出语句中对应的查询字段，数字特征，查询的表，查询的条件，查询的排序与否以及对应关键字即可</p><p>这里查询的条件我也做了简化处理，因为都是对字段值的限制，所以每一个条件都用一个三元组来表示，分别表示字段名称，字段值的左界以及右界</p><p>得到这些信息之后直接去表里面找对应的信息即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Query_sql_set</span>(<span class="hljs-params">node</span>):<br>    st, dataset, condition = [], [], []<br>    Flag = <span class="hljs-number">0</span> <span class="hljs-comment"># 是查询集合还是查询满足条件的数字</span><br>    ordered = [<span class="hljs-number">0</span>,<span class="hljs-string">&quot;NONE&quot;</span>]<br>    <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> node.getchildren():<br>        <span class="hljs-keyword">if</span> ch.getdata() == <span class="hljs-string">&quot;[FIELD]&quot;</span>:<br>            st=ch.getchildren()<br>        <span class="hljs-keyword">if</span> ch.getdata() == <span class="hljs-string">&quot;[NUMBER]&quot;</span>:<br>            st = ch.getchildren()[<span class="hljs-number">0</span>].getchildren()[<span class="hljs-number">0</span>].getdata()<br>            Flag, <span class="hljs-built_in">type</span> = <span class="hljs-number">1</span>, ch.getchildren()[<span class="hljs-number">0</span>].getdata()[<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> ch.getdata() == <span class="hljs-string">&quot;[TABLE]&quot;</span>:<br>            dataset = ch.getchildren()[<span class="hljs-number">0</span>].getdata()<br>        <span class="hljs-keyword">if</span> ch.getdata() == <span class="hljs-string">&quot;[ORDER]&quot;</span>:<br>            ordered = [<span class="hljs-number">1</span>,ch.getchildren()]<br>        <span class="hljs-keyword">if</span> ch.getdata() == <span class="hljs-string">&quot;[WHERE]&quot;</span>:<br>            now=ch.getchildren()[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">for</span> Or <span class="hljs-keyword">in</span> now.getchildren(): <span class="hljs-comment"># 合取范式的每一个极小项</span><br>                Insert=[] <span class="hljs-comment"># 每一个元素是一个三元组，表示一个运算表达式，元素之间是或的关系</span><br>                <span class="hljs-keyword">for</span> compare <span class="hljs-keyword">in</span> Or.getchildren():<br>                    ins, val = [], compare.getchildren()<br>                    name, val_to_compare = val[<span class="hljs-number">1</span>].getdata(),get_val(val[<span class="hljs-number">2</span>])<br>                    <span class="hljs-keyword">if</span> val[<span class="hljs-number">0</span>].getdata() == <span class="hljs-string">&quot;=&quot;</span>:<br>                        ins = [name,val_to_compare,val_to_compare]<br>                    <span class="hljs-keyword">elif</span> val[<span class="hljs-number">0</span>].getdata() == <span class="hljs-string">&quot;&gt;&quot;</span>:<br>                        ins = [name,val_to_compare+EPS,INF]<br>                    <span class="hljs-keyword">else</span> :<br>                        ins = [name,-INF,val_to_compare-EPS]<br>                    Insert.append(ins)<br>                condition.append(Insert)<br>    name = dataset + <span class="hljs-string">&#x27;.csv&#x27;</span><br>    <span class="hljs-comment">#</span><br>    dtSet = pd.DataFrame(csv.reader(<span class="hljs-built_in">open</span>(name, <span class="hljs-string">&#x27;r&#x27;</span>)))<br>    <span class="hljs-comment">#</span><br>    <span class="hljs-keyword">if</span> Flag == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> naive_find(st,dtSet,condition,ordered)<br>    <span class="hljs-keyword">else</span> :<br>        <span class="hljs-keyword">return</span> naive_find_num(st,dtSet,condition,<span class="hljs-built_in">type</span>)<br></code></pre></td></tr></table></figure><h4 id="在表中对信息的查找与筛选">在表中对信息的查找与筛选</h4><p>只要注意主析取范式中对条件的交并之间的细节处理，这一块并不是很难写的内容，这里不再过多展示</p><h4 id="关键字排序-1">关键字排序</h4><p>按需模拟即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Order</span>(<span class="hljs-params">data,Key</span>):<br>    val = []<br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> Key:<br>        <span class="hljs-comment"># print(key.getdata(),key.getorder())</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(data[<span class="hljs-number">0</span>])):<br>            <span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>][i] == key.getdata():<br>                <span class="hljs-keyword">if</span> key.getorder() == <span class="hljs-number">0</span>:<br>                    <span class="hljs-comment"># 这里直接取负的话，0是保持不变的，所以需要整体平移一下</span><br>                    val.append(i+<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    val.append(-(i+<span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sort_key</span>(<span class="hljs-params">item</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">int</span>(item[k-<span class="hljs-number">1</span>]) <span class="hljs-keyword">if</span> k&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> -<span class="hljs-built_in">int</span>(item[k+<span class="hljs-number">1</span>]) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> val)<br>    data[<span class="hljs-number">1</span>:] = <span class="hljs-built_in">sorted</span>(data[<span class="hljs-number">1</span>:], key=sort_key)<br>    <span class="hljs-keyword">return</span> data<br></code></pre></td></tr></table></figure><p>如此我们就实现了一个简易的sql编译器</p><h2 id="结果展示">结果展示</h2><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">AVERAGE</span>(Math) FROM st<br></code></pre></td></tr></table></figure><figure><img src="https://s2.loli.net/2024/01/01/91LCBqOakdAxsDu.png" alt="7" /><figcaption aria-hidden="true">7</figcaption></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">No</span> <span class="hljs-keyword">FROM</span> st <span class="hljs-keyword">WHERE</span> Chinese=(<span class="hljs-keyword">SELECT</span> MAX(Chinese) <span class="hljs-keyword">FROM</span> st)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/01/01/9hYxBwUbGuk61rW.png" alt="4" style="zoom:67%;" /></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> st <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Chinese , <span class="hljs-keyword">No</span> <span class="hljs-keyword">DESC</span><br></code></pre></td></tr></table></figure><figure><img src="https://s2.loli.net/2024/01/01/z1mKVeAcI2p8uWn.png" alt="5" /><figcaption aria-hidden="true">5</figcaption></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM st WHERE Chinese &lt; <span class="hljs-number">100</span> OR Math&lt;<span class="hljs-number">100</span> AND English&gt;<span class="hljs-number">100</span> AND Total&gt;<span class="hljs-number">100</span> OR Math &gt;<span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/01/01/rNUnfjvbXY7MhBw.png" alt="6" style="zoom:67%;" /></p><h2 id="回顾">回顾</h2><p>整体还是很有意思的，但是遗憾的是只实现了很少一部分的查询语句，并且写的还是太臭了...此外在已实现的功能中也有诸多限制，比如多条件查询时将条件格式限定在了主合取范式，无法处理更复杂的情况，诸如此类</p><p>不过总体来说，还是有点收获的，我也算真正会用yacc了(吧)</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
      <tag>实验报告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理实验六-对表达式的解析</title>
    <link href="/posts/2a5bbb14/"/>
    <url>/posts/2a5bbb14/</url>
    
    <content type="html"><![CDATA[<h2 id="前言">前言：</h2><p>对这玩意只能说是能用，只是会套别人的轮子，不过还是感觉很有意思，突然就想记录一下</p><h2 id="实验目的">实验目的：</h2><p>熟悉ply的基本使用，能够通过编写无二义性的语法以及利用yacc来实现对化学分子式的基本解析</p><h2 id="实验内容">实验内容：</h2><p>编写程序并且对化学分子式进行解析，得到其内部元素个数</p><p>以下是例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">atom_count(<span class="hljs-string">&quot;He&quot;</span>) == <span class="hljs-number">1</span><br>atom_count(<span class="hljs-string">&quot;H2&quot;</span>) == <span class="hljs-number">2</span><br>atom_count(<span class="hljs-string">&quot;H2SO4&quot;</span>) == <span class="hljs-number">7</span><br>atom_count(<span class="hljs-string">&quot;CH3COOH&quot;</span>) == <span class="hljs-number">8</span><br>atom_count(<span class="hljs-string">&quot;NaCl&quot;</span>) == <span class="hljs-number">2</span><br>atom_count(<span class="hljs-string">&quot;C60H60&quot;</span>) == <span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><h2 id="思路">思路：</h2><p>首先需要进行词法分析的构造</p><h3 id="词法分析">词法分析</h3><p>在本次实验中我们显然只需要对化学元素以及数字进行解析。事实上在一个化学分子式中确实不会出现除这两者之外的其它事物</p><ul><li>对化学元素的解析：在给定的化学元素周期表中，只要给出一个恰好包括所有元素的正则表达式即可</li><li>对数字的解析：不难得到</li></ul><p>由此我们给出词法分析的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># List of token names.   This is always required</span><br>tokens = (<br>    <span class="hljs-comment"># 本次实验我们只需要解析以下两个类型的词语</span><br>   <span class="hljs-string">&#x27;NUMBER&#x27;</span>,<span class="hljs-comment"># 数字</span><br>   <span class="hljs-string">&#x27;SYMBOL&#x27;</span> <span class="hljs-comment"># 化学元素</span><br>)<br><br><br><span class="hljs-comment"># A regular expression rule with some action code</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">t_NUMBER</span>(<span class="hljs-params">t</span>):<span class="hljs-comment">#对数字的识别</span><br>    <span class="hljs-comment"># 显然</span><br>    <span class="hljs-string">r&#x27;\d+&#x27;</span><br>    t.value = <span class="hljs-built_in">int</span>(t.value)<br>    <span class="hljs-keyword">return</span> t<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">t_SYMBOL</span>(<span class="hljs-params">t</span>):<span class="hljs-comment"># 对元素的识别</span><br>    <span class="hljs-comment"># 由元素周期表可得</span><br>    <span class="hljs-string">r&quot;&quot;&quot;</span><br><span class="hljs-string">    C[laroudsemf]?|Os?|N[eaibdpos]?|S[icernbmg]?|P[drmtboau]?|</span><br><span class="hljs-string">    H[eofgas]?|A[lrsgutcm]|B[eraik]?|Dy|E[urs]|F[erm]?|G[aed]|</span><br><span class="hljs-string">    I[nr]?|Kr?|L[iaur]|M[gnodt]|R[buhenaf]|T[icebmalh]|</span><br><span class="hljs-string">    U|V|W|Xe|Yb?|Z[nr]</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">return</span> t;<br><br><span class="hljs-comment"># A string containing ignored characters (spaces and tabs)</span><br>t_ignore  = <span class="hljs-string">&#x27; \t&#x27;</span><br><br><span class="hljs-comment"># Error handling rule</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">t_error</span>(<span class="hljs-params">t</span>):<br>    <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;Illegal character &#x27;%s&#x27;&quot;</span> % t.value[<span class="hljs-number">0</span>])<br>    t.lexer.skip(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">## Build the lexer</span><br>lexer = lex.lex()<br></code></pre></td></tr></table></figure><h3 id="语法">语法</h3><p>考虑的基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">species_list -&gt; species_list species<br>species_list -&gt; species<br>species -&gt; SYMBOL<br>species -&gt; SYMBOL COUNT<br></code></pre></td></tr></table></figure><p>其中<spanclass="math inline">\(species\_lsit\)</span>表示一个化学分子式，<spanclass="math inline">\(species\)</span>表示一个基本的化学元素的表达式，<spanclass="math inline">\(SYMBOL\)</span>表示能够识别出来的化学元素，<spanclass="math inline">\(COUNT\)</span>就表示对应的次数，一个表达式由上述两者组成</p><p>此外，为了让最后的结果能够对不同元素的次数加以区分，我们建立了一个结构体来方便计数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Atom</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, symbol, count</span>):<br>        self.symbol = symbol<br>        self.count = count<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Atom(%r, %r)&quot;</span> % (self.symbol, self.count)<br><br></code></pre></td></tr></table></figure><p>从而不难得到语法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 给出的语法如下，用&#x27;&#x27;包装</span><br><span class="hljs-comment"># 第一条默认为初始语法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_splist_sp</span>(<span class="hljs-params">p</span>):<br>    <span class="hljs-string">&#x27;splist : splist sp&#x27;</span><br>    p[<span class="hljs-number">1</span>].append(p[<span class="hljs-number">2</span>])<br>    p[<span class="hljs-number">0</span>]=p[<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_splist_to_sp</span>(<span class="hljs-params">p</span>):<br>    <span class="hljs-string">&#x27;splist : sp&#x27;</span><br>    p[<span class="hljs-number">0</span>] = [p[<span class="hljs-number">1</span>]]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_sp_symbol</span>(<span class="hljs-params">p</span>):<br>    <span class="hljs-string">&#x27;sp : SYMBOL&#x27;</span><br>    p[<span class="hljs-number">0</span>] = Atom(p[<span class="hljs-number">1</span>],<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_sp_symbol_count</span>(<span class="hljs-params">p</span>):<br>    <span class="hljs-string">&#x27;sp : SYMBOL NUMBER&#x27;</span><br>    p[<span class="hljs-number">0</span>] = Atom(p[<span class="hljs-number">1</span>],p[<span class="hljs-number">2</span>])<br><br><span class="hljs-comment"># Error rule for syntax errors</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_error</span>(<span class="hljs-params">p</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Syntax error in input!&quot;</span>)<br></code></pre></td></tr></table></figure><p>当单独一个<span class="math inline">\(SYMBOL\)</span>或者<spanclass="math inline">\(SYMBOL\)</span>与<spanclass="math inline">\(COUNT\)</span>规约为一个<spanclass="math inline">\(species\)</span>时，我们直接将其包装为一个基本结构体。否则用一个以Atom为基本元素的数组来记录其内包含的元素及其个数</p><p>yacc采用LALR分析法，当我们编译这个程序的时候，就会在同一个目录下得到LALR生成的分析表parser.out，并且之后会根据其中的DFA来决定分析时的移进/归约操作</p><h2 id="实验结果改进">实验结果&amp;改进</h2><figure><img src="https://s2.loli.net/2023/12/23/rJRGCEhzL7WfvnQ.png"alt="image-20231223133245938" /><figcaption aria-hidden="true">image-20231223133245938</figcaption></figure><p>不过注意到这个记录方法还是存在一定不足，在<spanclass="math inline">\(CH3COOH\)</span>中<spanclass="math inline">\(C\)</span>出现了两次，但是两次分开记录了，最好可以合并在一起</p><p>由此我们可以采用字典来记录</p><p>以下是<spanclass="math inline">\(chemistry\_caculate.py\)</span>的改进后的语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#! /usr/bin/env python</span><br><span class="hljs-comment"># coding=utf-8</span><br><span class="hljs-keyword">import</span> ply.yacc <span class="hljs-keyword">as</span> yacc<br><span class="hljs-keyword">from</span> calclex <span class="hljs-keyword">import</span> tokens<br><br><span class="hljs-comment"># rules for species</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_splist_sp</span>(<span class="hljs-params">p</span>):<br>    <span class="hljs-string">&#x27;splist : splist sp&#x27;</span><br>    <span class="hljs-keyword">for</span> sym,cnt <span class="hljs-keyword">in</span> p[<span class="hljs-number">2</span>].items():<br>        <span class="hljs-keyword">if</span> sym <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> p[<span class="hljs-number">1</span>]:<br>            p[<span class="hljs-number">1</span>][sym]=cnt<br>        <span class="hljs-keyword">else</span>:<br>            p[<span class="hljs-number">1</span>][sym]+=cnt<br>    p[<span class="hljs-number">0</span>]=p[<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_splist_to_sp</span>(<span class="hljs-params">p</span>):<br>    <span class="hljs-string">&#x27;splist : sp&#x27;</span><br>    p[<span class="hljs-number">0</span>] = p[<span class="hljs-number">1</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_sp_symbol</span>(<span class="hljs-params">p</span>):<br>    <span class="hljs-string">&#x27;sp : SYMBOL&#x27;</span><br>    p[<span class="hljs-number">0</span>] = &#123;&#125;<br>    p[<span class="hljs-number">0</span>][p[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_sp_symbol_count</span>(<span class="hljs-params">p</span>):<br>    <span class="hljs-string">&#x27;sp : SYMBOL NUMBER&#x27;</span><br>    p[<span class="hljs-number">0</span>] = &#123;&#125;<br>    p[<span class="hljs-number">0</span>][p[<span class="hljs-number">1</span>]] = p[<span class="hljs-number">2</span>]<br><br><span class="hljs-comment"># Error rule for syntax errors</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">p_error</span>(<span class="hljs-params">p</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Syntax error in input!&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>此时结果如下：</p><figure><img src="https://s2.loli.net/2023/12/23/wUP5zx4IpWlam3r.png"alt="image-20231223140716841" /><figcaption aria-hidden="true">image-20231223140716841</figcaption></figure><p>可以看到确实已经合并在一起了</p><p>更多细节参见文件中的PLY使用手册</p>]]></content>
    
    
    <categories>
      
      <category>编译原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
      <tag>实验报告</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高维前缀和学习笔记</title>
    <link href="/posts/beb6cf6/"/>
    <url>/posts/beb6cf6/</url>
    
    <content type="html"><![CDATA[<h2 id="正文">正文</h2><p>我们考虑一个关于求和的问题</p><p><span class="math inline">\(\forall i\)</span>,求<spanclass="math inline">\(∑_{j⊂i}a_j\)</span>,这里<spanclass="math inline">\(j\subset i\)</span>的定义可以很宽泛，我们可以将其定义为<spanclass="math inline">\(j|i\)</span>，也可以是j的二进制表示是i的二进制表示的子集等等</p><p>显然一种暴力的方法就是枚举i的所有子集，考虑优化的话，我们可以尝试前缀和，因为显然如果有<spanclass="math inline">\(j⊂z,z⊂i\)</span>,我们可以将j的贡献都先算在z上面再传给i，而不必一个个来</p><p>但是这样的话，就涉及到了高维的前缀和处理</p><hr /><p>先来看看一维前缀和是怎么写的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>a[i]+=a[i<span class="hljs-number">-1</span>];<br>&#125; <br></code></pre></td></tr></table></figure><p>然后是二维前缀和，这里我们一般用容斥来处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>&#123;<br>sum[i][j]+=sum[i<span class="hljs-number">-1</span>][j]+sum[i][j<span class="hljs-number">-1</span>]-sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>如果到了三维的话，也是可以容斥的，写起来就有点烦</p><p>实际上除了容斥，我们还有另外一种写前缀和的方法</p><p>二维</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>&#123;<br>sum[i][j]+=sum[i][j<span class="hljs-number">-1</span>];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>&#123;<br>sum[i][j]+=sum[i<span class="hljs-number">-1</span>][j];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个其实很好理解</p><p><imgsrc="https://img-blog.csdnimg.cn/a7735513952f4e6c97549c0cdcaf6120.png" /></p><p>我们先按绿色方向把每一层的前缀和都给做出来，然后再沿黄色方向做一遍前缀和，按顺序从小往大走的话，显然我们会把第一维（行）的前缀和算进去。</p><p>所以不难得到三维的前缀和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=q;++k)<br>&#123;<br>sum[i][j][k]+=sum[i<span class="hljs-number">-1</span>][j][k];<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=q;++k)<br>&#123;<br>sum[i][j][k]+=sum[i][j<span class="hljs-number">-1</span>][k];<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=q;++k)<br>&#123;<br>sum[i][j][k]+=sum[i][j][k<span class="hljs-number">-1</span>];<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么如果扩展到了n维会怎么样？</p><p>思路跟上面是一样的，就是一维一维的做前缀和</p><h3 id="二进制子集前缀和">二进制子集前缀和</h3><p>考虑一开始的问题： <span class="math inline">\(\forall i,0\leq i\leq2^n-1\)</span>，,求<span class="math inline">\(∑_{j⊂i}a_j\)</span>，其中 j属于i 定义为j的二进制表示是i的二进制表示的子集</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))<br>        &#123;<br>            dp[i]+=dp[i^(<span class="hljs-number">1</span>&lt;&lt;j)]<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为是正序枚举的，所以<spanclass="math inline">\(i^(1&lt;&lt;j)\)</span>是是当前这一维度，而此时i还在上一维，所以这样就实现了高维的前缀和。这样的时间复杂度是<spanclass="math inline">\(O(n2^n)\)</span>,而如果去枚举子集来做前缀和的话，时间复杂度是<spanclass="math inline">\(n^3\)</span>的。</p><p>我们来看一些具体的应用</p><p><a href="https://atcoder.jp/contests/arc100/tasks/arc100_c"title="ARC 100 E - Or Plus Max">ARC 100 E - Or Plus Max</a></p><p>大意： 给定一个长度为<spanclass="math inline">\(2^n\)</span>的数组，对于每一个<spanclass="math inline">\(k，1&lt;=k&lt;=2^n-1\)</span>，求出最大的<spanclass="math inline">\(ai+aj\)</span>，其中<spanclass="math inline">\(iOR j&lt;=k\)</span></p><p>思路： 关键就是如何处理<span class="math inline">\(i orj&lt;=k\)</span>,不难发现这蕴含的意思其实就是<spanclass="math inline">\(iorj\)</span>的结果是<spanclass="math inline">\(k\)</span>的二进制表示下的子集</p><p>所以我们直接跑高维前缀和，维护一下每一个<spanclass="math inline">\(k\)</span>对应的能够用的<ahref="https://so.csdn.net/so/search?q=%E6%9C%80%E5%A4%A7%E5%80%BC&amp;spm=1001.2101.3001.7020">最大值</a>以及次大值即可</p><p>code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br>ll n;<br>ll mas[N],sec[N],dp[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upt</span><span class="hljs-params">(ll id,ll val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(val&gt;=mas[id])<br>&#123;<br>sec[id]=mas[id];<br>mas[id]=val;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(val&gt;=sec[id])<br>&#123;<br>sec[id]=val;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);++i) cin&gt;&gt;mas[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);++i)<br>&#123;<br><span class="hljs-keyword">if</span>(i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))<br>&#123;<br><span class="hljs-built_in">upt</span>(i,mas[i^(<span class="hljs-number">1</span>&lt;&lt;j)]);<br><span class="hljs-built_in">upt</span>(i,sec[i^(<span class="hljs-number">1</span>&lt;&lt;j)]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);++i)<br>&#123;<br>dp[i]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>],mas[i]+sec[i]);<br>cout&lt;&lt;dp[i]&lt;&lt;endl;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);</span><br><span class="hljs-built_in">solve</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>再看一道</p><p>给定一个数组，问里面有多少个数字满足<span class="math inline">\(a_i\:and\: a_j=0\)</span></p><p>思路：</p><p>显然对于一个数<spanclass="math inline">\(a_i\)</span>，我们找到它的二进制表示的补集<spanclass="math inline">\(Q\)</span>，那么<spanclass="math inline">\(Q\)</span>的所有子集出现过的次数就是<spanclass="math inline">\(a_i\)</span>的贡献，所以我们还是可以通过高维前缀和来处理</p><p>代码不写了，题源也找不到，自己意会一下</p><p>那么上面都是二进制枚举子集的前缀和，如果是枚举超集的话，那其实叫后缀和会更加合理一些吧</p><h3 id="二进制超集后缀和">二进制超集后缀和</h3><p>代码也很好写，无非就是把原本为0的地方改成1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)<br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>((i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))==<span class="hljs-number">0</span>)<br>        &#123;<br>            dp[i]+=dp[i^(<span class="hljs-number">1</span>&lt;&lt;j)]<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://codeforces.com/problemset/problem/449/D"title="Jzzhu and Numbers">Jzzhu and Numbers</a></p><p>大意：</p><p><imgsrc="https://img-blog.csdnimg.cn/62ae6f7ae8f44b8cb1eacf30194104ec.png" /></p><p><span class="math inline">\(n,a_i&lt;=1e6\)</span></p><p>思路：<br />不考虑复杂度的话我们有一个非常套路的容斥做法。考虑性质Ai表示子集与之后第i位为1，那么我们的答案其实就是<span class="math display">\[|\Omega -A_1\bigcup A_2...\bigcup A_{20}|=\\\sum_{i=0}^{20}(-1)^i\sum_{1\leq j_1 &lt; j_2...&lt;j_i \leq 20}|A_{j_1}\bigcup A_{j_2}...A_{j_i}|\]</span> 显然就可以状压枚举，这样的时间复杂度是<spanclass="math inline">\(O(n*1e6)\)</span>，考虑优化。</p><p>注意到对于<span class="math inline">\(|A_{j_1}\bigcupA_{j_2}...A_{j_i}|\)</span>，我们记满足对应所有性质的元素的个数为<spanclass="math inline">\(k\)</span>，则该集合的大小就是<spanclass="math inline">\(2^k-1\)</span>,那么什么元素会满足这些性质呢？就是二进制为其超集的元素呗，其价值就是1.</p><p>所以我们只要做一遍超集后缀和即可，时间复杂度来到<spanclass="math inline">\(O(20*1e6)\)</span></p><p>code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>ll n,cnt=<span class="hljs-number">0</span>,a;<br>ll mas[N];<br>ll up=<span class="hljs-number">20</span>;<br>ll vis[<span class="hljs-number">30</span>];<br>ll dp[(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>)+<span class="hljs-number">10</span>];<br><span class="hljs-function">ll <span class="hljs-title">ksm</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll ans=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(y)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) ans=ans*x%mod;<br>        x=x*x%mod;<br>        y&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ll tot=<span class="hljs-number">0</span>;<br>    ll fl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        fl=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;up;++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!vis[j]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>((mas[i]&amp;(<span class="hljs-number">1</span>&lt;&lt;j))==<span class="hljs-number">0</span>)<br>            &#123;<br>                fl=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fl) tot++;<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> ((<span class="hljs-built_in">ksm</span>(<span class="hljs-number">2</span>,tot)<span class="hljs-number">-1</span>)%mod+mod)%mod;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;a,dp[a]++;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;up;++j)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;up);++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span>((i&amp;(<span class="hljs-number">1</span>&lt;&lt;j))==<span class="hljs-number">0</span>) dp[i]+=dp[i^(<span class="hljs-number">1</span>&lt;&lt;j)];<br>        &#125;<br>    &#125;<br>    ll ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s=<span class="hljs-number">0</span>;s&lt;(<span class="hljs-number">1</span>&lt;&lt;up);++s)<br>    &#123;<br>        cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;up;++i) <span class="hljs-keyword">if</span>(s&amp;(<span class="hljs-number">1</span>&lt;&lt;i)) cnt++;<br>        <span class="hljs-keyword">if</span>(cnt%<span class="hljs-number">2</span>) ans=((ans-<span class="hljs-built_in">ksm</span>(<span class="hljs-number">2</span>,dp[s])+<span class="hljs-number">1</span>)%mod+mod)%mod;<br>        <span class="hljs-keyword">else</span> ans=((ans+<span class="hljs-built_in">ksm</span>(<span class="hljs-number">2</span>,dp[s])<span class="hljs-number">-1</span>)%mod+mod)%mod;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p>然后我们看看一开始提出的第二种定义</p><p><span class="math inline">\(\forall i,0\leq i\leq2^n-1\)</span>，,求<span class="math inline">\(∑_{j⊂i}a_j\)</span>，其中$ ji$ 定义为<span class="math inline">\(j | i\)</span></p><p>显然<spanclass="math inline">\(j|i\)</span>蕴含的意思是，对于每一个质因子p，j蕴含的p的幂次不大于i蕴含的p的幂次，所以这里还是一个子集的关系，只不过集合的定义由二进制表示变成了素数分解</p><p>我们换一种写法</p><p><span class="math inline">\(\forall 1\leq i\leq n\)</span>,求<spanclass="math inline">\(∑_{j|i}a_j\)</span></p><p>我们只要按照埃氏筛的样子做一遍更新就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>    <span class="hljs-keyword">if</span>(!vis[i])<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j*i&lt;=n;++j) sum[i*j]+=sum[j],vis[i*j]=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要预处理的话也可以，唯一需要注意的，跟上文一样，这里我们的维度是由不同的素因子来确定的，所以我们要先枚举素因子来保证每一维的前缀和都更新全了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=totprime;++i)<br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;p[i]*j&lt;=n;++j)<br>    &#123;<br>        sum[p[i]*j]+=sum[j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么这种东西其实有一种更加正式的名字：</p><h3 id="狄利克雷前缀和">狄利克雷前缀和</h3><p><a href="https://www.luogu.com.cn/problem/P5495"title="Dirichlet 前缀和">Dirichlet 前缀和</a></p><p>大意：如上</p><p>思路：如上</p><p>code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll unsigned int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">2e7</span>+<span class="hljs-number">10</span>;<br>ll n,a;<br>ll seed;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">getnext</span><span class="hljs-params">()</span></span>&#123;<br>seed^=seed&lt;&lt;<span class="hljs-number">13</span>;<br>seed^=seed&gt;&gt;<span class="hljs-number">17</span>;<br>seed^=seed&lt;&lt;<span class="hljs-number">5</span>;<br><span class="hljs-keyword">return</span> seed;<br>&#125;<br> <br>ll b[N];<br><span class="hljs-type">bool</span> vis[N];<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;seed;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) b[i]=<span class="hljs-built_in">getnext</span>();<br>vis[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br><span class="hljs-keyword">if</span>(!vis[i])<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j*i&lt;=n;++j) b[i*j]+=b[j],vis[i*j]=<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans^=b[i];<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-built_in">solve</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>事实上还有一种东西叫做</p><h3 id="狄利克雷后缀和">狄利克雷后缀和</h3><p><span class="math inline">\(∀1≤i≤n，求∑_{i|j}a_j\)</span></p><p>其实也不难理解，就是素因子分解下的枚举超集的后缀和，跟上面讲的二进制超集后缀和一个意思</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=totprime;++i)<br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n/p[i];j;--j)<br>    &#123;<br>        sum[j]+=sum[j*p[j]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是因为这里我们需要用到比自己大的值，所以内层需要倒序更新</p><p><a href="https://codeforces.com/contest/1614/problem/D2"title="cf 757 D2. Divan and Kostomuksha (hard version)">cf 757 D2. Divanand Kostomuksha (hard version)</a></p><p>大意： 给定一个数组<spanclass="math inline">\(a\)</span>，要求重排数组，使得数组的前缀<spanclass="math inline">\(gcd\)</span>之和最大</p><p>思路： 一个显然的小贪心：如果一开始的<spanclass="math inline">\(gcd\)</span>是<spanclass="math inline">\(x\)</span>的话，我们一定要尽可能多的保留<spanclass="math inline">\(gcd\)</span>为<spanclass="math inline">\(x\)</span>，因为后面的<spanclass="math inline">\(gcd\)</span>不会大于<spanclass="math inline">\(x\)</span>。要做到这一点，我们需要统计有多少个数字是<spanclass="math inline">\(x\)</span>的倍数</p><p>换句话说，我们需要统计<spanclass="math inline">\(cnt_i\)</span>，表示有多少个数字是<spanclass="math inline">\(i\)</span>的倍数，这其实就是一个狄利克雷后缀和</p><p>这里还有一个性质：<spanclass="math inline">\(cnt_j\)</span>一定不大于<spanclass="math inline">\(cnt_i\)</span>，这一点显然</p><p>那么我们如果以<span class="math inline">\(i\)</span>作为一开始的<spanclass="math inline">\(gcd\)</span>的话，会保留<spanclass="math inline">\(cnt_i\)</span>个前缀<spanclass="math inline">\(gcd\)</span>为<spanclass="math inline">\(i\)</span>的长度，如果以<spanclass="math inline">\(j\)</span>作为一开始的<spanclass="math inline">\(gcd\)</span>的话，会保留<spanclass="math inline">\(cnt_j\)</span>个前缀<spanclass="math inline">\(gcd\)</span>为<spanclass="math inline">\(j\)</span>的长度，这个长度肯定是不大于上一个的，所以我们可以从<spanclass="math inline">\(i\)</span>转移到<spanclass="math inline">\(j\)</span>，</p><p>设<span class="math inline">\(dp_i\)</span>表示一开始的<spanclass="math inline">\(gcd\)</span>为<spanclass="math inline">\(i\)</span>的情况下数组的最大价值</p><p><spanclass="math inline">\(dp_j=max(dp_j,1ll*cnt_j*(j-i)+dp_i);\)</span></p><p>一开始的初始条件是<span class="math inline">\(dp_1=1\)</span></p><p>另外这题数据范围有点大，需要预处理一下素数，然后按素数转移即可</p><p>code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">2e7</span>;<br>ll n,a;<br>ll cn=<span class="hljs-number">0</span>;<br>ll cnt[N+<span class="hljs-number">10</span>];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[N+<span class="hljs-number">10</span>];<br>ll p[N+<span class="hljs-number">10</span>];<br><span class="hljs-type">bool</span> vis[N+<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=N;++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!vis[i])<br>        &#123;<br>            p[++cn]=i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=cn&amp;&amp;i*p[j]&lt;=N;++j)<br>        &#123;<br>            vis[i*p[j]]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(i%p[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    cin&gt;&gt;n;<br>    <span class="hljs-comment">//cout&lt;&lt;cn&lt;&lt;endl; </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;a;<br>        cnt[a]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cn;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=N/p[i];j;--j)<br>        &#123;<br>            cnt[j]+=cnt[j*p[i]];    <br>        &#125; <br>    &#125;<br>    dp[<span class="hljs-number">1</span>]=n;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;i*p[j]&lt;=N;++j)<br>        &#123;<br>            ll sd=i*p[j];<br>            dp[sd]=<span class="hljs-built_in">max</span>(dp[sd],<span class="hljs-number">1ll</span>*cnt[sd]*(sd-i)+dp[i]);<br>        &#125;<br>        ans=<span class="hljs-built_in">max</span>(ans,dp[i]);<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>动态规划</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多项式EXP运算的组合意义</title>
    <link href="/posts/fcb4041a/"/>
    <url>/posts/fcb4041a/</url>
    
    <content type="html"><![CDATA[<p>EGF一般用来处理多重集的排列问题，在其上可以定义多项式的exp运算，在处理一类问题的时候有独特的作用</p><p>我们考虑将n个有标号的元素分为k个<strong>非空</strong>无序集合的方案数，记其EGF为<spanclass="math inline">\(F_{k}\)</span>,再考虑<spanclass="math inline">\(f_i\)</span>表示在这个我们定义的集合中对集合元素的计数方式（也就是考虑元素在集合内的<strong>排列方式</strong>的个数，这是一个只跟集合大小有关的值），那么根据生成函数的定义，我们不难得到下式</p><p><spanclass="math inline">\(F_{k}(n)=\frac{n!}{k!}\sum_{\sum_{i=1}^{k}a_i=n}\prod_{j=1}^{k}\frac{f_{a_j}}{a_j!}\)</span>，最后除以<spanclass="math inline">\(k!\)</span>是因为这k个集合是无序的，而原本的多个多项式卷积显然是有序的</p><p>现在我们记<spanclass="math inline">\(\hat{F(x)}=\sum_{i=0}^{inf}f_i\frac{x^i}{i!}\)</span>,也就是原本的<spanclass="math inline">\(f_i\)</span>的EGF</p><p>再记<span class="math inline">\(G_k(x)\)</span>为<spanclass="math inline">\(F_k(n)\)</span>的EGF，则有</p><p><spanclass="math inline">\(G_k(x)=\sum_{n=0}^{inf}F_k(n)\frac{x^n}{n!}\)</span></p><p><spanclass="math inline">\(=\sum_{n=0}^{inf}\frac{n!}{k!}(\sum_{\sum_{i=1}^{k}a_i=n}\prod_{j=1}^{k}\frac{f_{a_j}}{a_j!})\frac{x^n}{n!}\)</span></p><p><spanclass="math inline">\(=\frac{1}{k!}\sum_{n=0}^{inf}(\sum_{\sum_{i=1}^{k}a_i=n}\prod_{j=1}^{k}\frac{f_{a_j}x^{a_j}}{a_j!})\)</span></p><p><span class="math inline">\(=\frac{1}{k!}(\hat{F(x)})^k\)</span></p><p>如果我们考虑所有<span class="math inline">\(k\geq 0\)</span>,就有</p><p><span class="math inline">\(\sum_{k\geq 0}G_k(x)=\sum_{k\geq0}\frac{(\hat{F(x)})^k}{k!}=exp\hat{F(x)}\)</span></p><p>我们惊奇地发现，<spanclass="math inline">\(G(x)\)</span>的指数生成函数居然就是<spanclass="math inline">\(f_x\)</span>的生成函数的exp！</p><p><strong>总结一下，多项式exp的组合意义就是：有标号元素构成的集合划分为任意个非空子集的总方案数。</strong></p><p>来几个具体的例子</p><hr /><p>考虑大小为n的排列的个数是<spanclass="math inline">\(n!\)</span>,其指数生成函数是<spanclass="math inline">\(P(x)=\sum_{n\geq 0}\frac{n!x^n}{n!}=\sum_{n\geq0}x^n=\frac{1}{1-x}\)</span></p><p>一个大小为n的圆排列个数是<spanclass="math inline">\((n-1)!\)</span>,其指数生成函数是<spanclass="math inline">\(G(x)=\sum_{n\geq1}\frac{(n-1)!x^n}{n!}=\sum_{n\geq1}\frac{x^n}{n}=-\ln(1-x)=ln(\frac{1}{1-x})\)</span></p><p>不难发现<span class="math inline">\(P(x)=expG(x)\)</span></p><p>仔细理解一下，众所周知，一个大小为n的排列一定可以拆成若干个环，每一个环内部的排列数就是一个圆排列的方案数，所以大小为n的排列的方案数就是把<spanclass="math inline">\(1,2...n\)</span>分成若干个非空集合，每一个集合的圆排列方案数之积，这与我们上面讲到的exp的组合意义相符合</p><hr /><p>第二类斯特林数<spanclass="math inline">\(\{n,k\}\)</span>的组合意义就是把n个数分成k个集合的方案数，这里一个集合的计数就是1，也就是说在上面推导过程中<spanclass="math inline">\(\hat{F(x)}=\{1,1,1....\}\)</span></p><p>其指数生成函数是<span class="math inline">\(G_{k}(x)=\sum_{n\geq0}S(n,k)\frac{x^n}{n!}=\frac{1}{k!}(exp(x)-1)^k\)</span></p><p>贝尔数的组合意义是把n个数分成若干个非空集合的方案数，其生成函数是<spanclass="math inline">\(\hat{B}(x)=exp(e^x-1)\)</span></p><p>不难理解，贝尔数与第二类斯特林数的区别就在于对分成的非空集合的个数的限制，那么<spanclass="math inline">\(\hat{B(x)}=\sum_{k\geq0}G_k(x)\)</span>也就是时分自然的，这也与上面的理论相符合</p><hr /><p>举一反三，我们考虑n个点带标号的生成树个数的EGF为<spanclass="math inline">\(\hat{F(x)}\)</span>,那么n个点带标号的森林的个数就是<spanclass="math inline">\(exp\hat{F(x)}\)</span>,意义就是将n个点分成若干个树的方案数</p><hr /><p><a href="https://www.luogu.com.cn/problem/P4841">[集训队作业2013]城市规划</a></p><p>求n个点的有标号简单无向<strong>连通</strong>图的数量</p><p>这个可能并不是那么好直接想出来，但是按照我们刚刚的理论，可以考虑先求出n个点的有标号简单无向图的数量（不要要求连通），然后直接对其EGF直接取<spanclass="math inline">\(\ln\)</span>就可以了</p><p>这个是非常好求的，就是一张完全图里面每一个点都有删或不删两种选择，其EGF就是<spanclass="math inline">\(\sum_{n\geq0}2^{\binom{n}{2}}\frac{x^n}{n!}\)</span></p><p>所以答案就是<span class="math inline">\([x^n]\ln(\sum_{n\geq0}2^{\binom{n}{2}}\frac{x^n}{n!})\)</span></p><h2 id="对上文的拓展环计数">对上文的拓展(环计数)</h2><p>上文考虑的情况是将n个元素分成若干个无序集合的情况，如果集合之间是有序的，那么就要把对应的方案数乘回去</p><p>比如如果我们是要将所有集合排成一个环，那么n个集合之间的关系方案数就是<spanclass="math inline">\((n-1)!\)</span></p><p>所以老样子，还是考虑<spanclass="math inline">\(G_k(x)\)</span>为将n个元素分成k个集合，集合之间组成一个k元环的方案数，集合内部计数方案的EGF为<spanclass="math inline">\(\hat{F(x)}\)</span>,则<spanclass="math inline">\(G_k(x)=\frac{(k-1)!}{k!}(\hat{F(x)})^k=\frac{1}{k}(\hat{F(x)})^k\)</span></p><p><span class="math inline">\(\sum_{k\geq 1}G_k(x)=\sum_{k\geq1}\frac{1}{k}(\hat{F(x)})^k=-\ln(1-\hat{F(x)})\)</span></p><hr /><blockquote><p>求包含n个顶点，n条边的连通无向图的个数。顶点有标号，要求不存在重边和自环</p></blockquote><p>首先不难发现图是一个基环树，图中存在一个大小<spanclass="math inline">\(\geq3\)</span>的环，并且环的每一个顶点都是一个有标号有根树的根。</p><p>那么此时思路就比较明显了，我们的目的就是把n个点分成<spanclass="math inline">\(\geq3\)</span>个集合，然后每一个大小为x的集合内部的计数就是大小为x的有标号有根树的计数，也就是<spanclass="math inline">\(x^{x-1}\)</span>。其EGF就是<spanclass="math inline">\(T(x)=\sum_{n\geq1}\frac{n^{n-1}x^n}{n!}\)</span></p><p>所以<span class="math inline">\(G_k(x)=\frac{1}{k}T(x)^k\)</span></p><p>那么答案就是<span class="math inline">\(\frac{1}{2}\sum_{k\geq3}G_k(x)=-\frac{1}{2}\ln(1-T(x))-\frac{T(x)}{2}-\frac{T(x)^2}{4}\)</span></p><p>最后乘上<spanclass="math inline">\(\frac{1}{2}\)</span>是因为这里的环是没有方向的，可以翻转</p>]]></content>
    
    
    <categories>
      
      <category>组合数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>学习笔记</tag>
      
      <tag>组合数学</tag>
      
      <tag>多项式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树与图上计数问题：Prufer序列与LGV引理</title>
    <link href="/posts/316a29dd/"/>
    <url>/posts/316a29dd/</url>
    
    <content type="html"><![CDATA[<h2 id="树与图上的计数问题">树与图上的计数问题</h2><h3 id="prufer序列">Prufer序列</h3><p>起源于对<spanclass="math inline">\(Cayley\)</span>定理的证明，但是其功能远不止于此</p><ul><li><p><span class="math inline">\(Tree-&gt;Prufer:\)</span></p><p>①从树上选择编号最小的叶子节点，序列的下一位为其父节点的编号。</p><p>②删去该叶子节点。</p><p>③重复①和②，直到树只剩下两个节点，此时序列的长度刚好为 n−2 。</p></li><li><p><span class="math inline">\(Prufer—&gt;Tree:\)</span></p><p>①选择编号最小的叶子节点（即未出现在序列中的节点），其父节点就是序列的第i （ i 初始为1）个元素。</p><p>②由性质可得，其父节点的度数为其出现次数+1。将该叶子节点删去，其父节点度数-1。若度数变成1，则父节点也成为叶子节点。</p><p>③将 i 加一，然后重复①和②，直到序列的每一个元素都使用完毕。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++">ll p[N];<br>ll d[N];<span class="hljs-comment">//度数</span><br>ll f[N];<span class="hljs-comment">//连边</span><br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Prufer_To_Tree</span><span class="hljs-params">(ll n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//f记录1-n-1的连边情况</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-2</span>;++i) cin&gt;&gt;p[i],d[p[i]]++;<br>    p[n<span class="hljs-number">-1</span>]=n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>;i&lt;n;++i,++j)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(d[j]) j++;<br>        f[j]=p[i];<span class="hljs-comment">//把最小的叶往prufer序列第一个点上接 对应减掉度数</span><br><br>        <span class="hljs-keyword">while</span>(i&lt;n&amp;&amp;!--d[p[i]]&amp;&amp;p[i]&lt;j) f[p[i]]=p[i+<span class="hljs-number">1</span>],i++;<br>        <span class="hljs-comment">//如果序列第一个点减掉度数后产生了新的更小的叶 就往序列下一个点上接</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) ans^=<span class="hljs-number">1ll</span>*i*f[i];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Tree_To_Prufer</span><span class="hljs-params">(ll n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i) cin&gt;&gt;f[i],d[f[i]]++;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-2</span>;++i,++j)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(d[j]) j++;<br>        p[i]=f[j];<br>        <span class="hljs-keyword">while</span>(i&lt;=n<span class="hljs-number">-2</span>&amp;&amp;!--d[p[i]]&amp;&amp;p[i]&lt;j) p[i+<span class="hljs-number">1</span>]=f[p[i]],i++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-2</span>;++i) ans^=<span class="hljs-number">1ll</span>*i*p[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>由此我们发现两者是一一对应的，也就是双射，所以大小为n的有标号无根树的个数等于长度为<spanclass="math inline">\(n-2\)</span>的prufer序列的个数，自然为<spanclass="math inline">\(n^{n-2}\)</span>，<spanclass="math inline">\(Cayley\)</span>定理得证</p><h4 id="prufer序列的性质">Prufer序列的性质</h4><p>由Prufer序列构造的过程，我们可以发现其具有两个显而易见的性质。</p><ul><li><p>构造完后剩下的两个节点里，一定有一个是编号最大的节点。</p></li><li><p><strong>对于一个 n 度的节点，其必定在序列中出现 n−1次</strong>。因为每次删去其子节点它都会出现一次，最后一次则是删除其本身。一次都未出现的是原树的叶子节点。</p></li></ul><h4 id="应用">应用</h4><p><strong>1、无向完全图的不同生成树数：</strong></p><p><span class="math inline">\(n^{n−2}\)</span> 。</p><p><strong>2、</strong> n <strong>个点的无根树计数：</strong></p><p>同上问题。</p><p><strong>3、</strong> n <strong>个点的有根树计数：</strong></p><p>对每棵无根树来说，每个点都可能是根，故总数为 <spanclass="math inline">\(n^{n−2}×n=n^{n−1}\)</span> 。</p><p><strong>4、</strong> n <strong>个点，每点度分别为</strong> <spanclass="math inline">\(d_i\)</span> <strong>的无根树计数：</strong></p><p>显然就是一个多重集，答案为<spanclass="math inline">\(\frac{(n-2)!}{\prod_{i=1}^{n}d_i-1}\)</span></p><p><strong>5、</strong> <strong>有标号的完全二分图<spanclass="math inline">\(K_{n,m}\)</span>的生成树个数为<spanclass="math inline">\(n^{m-1}m^{n-1}\)</span>:</strong></p><p>考虑将其生成树的prufer序列按照原本顺序分成<spanclass="math inline">\(f_i\leq n,f_i&gt;n\)</span>两部分。</p><p>对于<span class="math inline">\(f_i\leqn\)</span>的部分，一定是删去某个标号<spanclass="math inline">\(&gt;n\)</span>的点之后留下<spanclass="math inline">\(f_i\)</span>的，因为这是一张二分图。所以该部分的点一定恰好有<spanclass="math inline">\(m-1\)</span>个（右部有m个点，整张图删完之后一定在左右部各留下一个点，所以右部一共要删去<spanclass="math inline">\(m-1\)</span>个点）</p><p><span class="math inline">\(f_i&gt;n\)</span>部分同理。</p><p>所以一个此时还是可以用一个prufer序列与合法生成树对应，故方案数为<spanclass="math inline">\(n^{m-1}m^{n-1}\)</span></p><h4 id="tips">Tips:</h4><p>一般要特判n=1的情况</p><p><a href="https://ac.nowcoder.com/acm/contest/28665/E">ValuableForests</a></p><p>大意：</p><p>定义一个树的权值为其所有节点的度数的平方和，森林的权值为所有树的权值和。求大小为n的所有有标号森林的权值和</p><p>思路：</p><p><spanclass="math inline">\(f_i\)</span>表示大小为i的所有有标号森林的权值和，也就是答案</p><p>考虑对于最后一个点所在的树的大小为k的情况</p><p>则<spanclass="math inline">\(f_n=\sum_{k=1}^{n}\binom{n-1}{k-1}f_{n-k}m_k+\binom{n-1}{k-1}g_kh_{n-k}\)</span></p><p>其中<span class="math inline">\(m_i\)</span>表示大小为<spanclass="math inline">\(i\)</span>的有标号无根树的个数，<spanclass="math inline">\(g_i\)</span>表示大小为<spanclass="math inline">\(i\)</span>的所有有标号无根树的权值和，<spanclass="math inline">\(h_{n-k}\)</span>表示大小为<spanclass="math inline">\(n-k\)</span>的森林的数量。<spanclass="math inline">\(\binom{n-1}{k-1}\)</span>是因为枚举的k的含义是n所在树的大小，我要从剩下<spanclass="math inline">\(n-1\)</span>个点里面选<spanclass="math inline">\(k-1\)</span>个点。如果不这样枚举的树的组合就会算重。</p><p><span class="math inline">\(m_n\)</span>很简单：<spanclass="math inline">\(n=1\)</span>时<spanclass="math inline">\(m_1=1\)</span>，否则<spanclass="math inline">\(m_n=n^{n-2}\)</span></p><p>对于<spanclass="math inline">\(g_n\)</span>,我们枚举所有度数为i的贡献</p><p>转化到prufer序列中看这个问题，度数为i，表示出现了<spanclass="math inline">\(i-1\)</span>次，所以强制选定对应的数字以及位置，剩下的<spanclass="math inline">\(n-1\)</span>个数随便放</p><p><spanclass="math inline">\(g_n=\sum_{i=1}^{n-1}i^2n\binom{n-2}{i-1}{n-1}^{n-1-i}\)</span></p><p><span class="math inline">\(h_n\)</span>的更新思路和<spanclass="math inline">\(f\)</span>差不多，枚举最后一个点所在的树的大小即可</p><p><spanclass="math inline">\(h_n=\sum_{i=1}^{n}\binom{n-1}{i-1}h_{n-i}m_i\)</span></p><p><a href="https://codeforces.com/problemset/problem/156/D">cf156D</a></p><p>大意：</p><p>给定n个点以及m条连边，记最少添加T条边使得整张图连通，问有多少种恰好添加T条边的方案使得图连通</p><p>思路:</p><p>记当前连通块个数为k，则T=k-1</p><p>对于每一个连通块，其大小为<spanclass="math inline">\(a_i\)</span>，如果其度数为<spanclass="math inline">\(d_i\)</span>的话，我们可以在以连通块为单位的情况下得到生成树个数为<spanclass="math inline">\(\binom{k-2}{d1-1,d2-1...d_k-1}\)</span></p><p>对于每一个连通块，固定连边的标号顺序（比如第1条边来自标号最小的连通块，依次类推），那么此时总方案数为<spanclass="math inline">\(\binom{k-2}{d1-1,d2-1...d_k-1}*\prod_{i=1}^{k}a_i^{d_i}\)</span>,因为每一条边都可以有<spanclass="math inline">\(a_i\)</span>种选择</p><p>所以答案为<span class="math inline">\(\sum_{\sumd_i=k-2}\binom{k-2}{d1,d2...d_k}*\prod_{i=1}^{k}a_i^{d_i+1}=\sum_{\sumd_i=k-2}\frac{(k-2)!}{\prod_{i=1}^{k}d_i!}*\prod_{i=1}^{k}a_i^{d_i+1}=(k-2)!\prod_{i=1}^{k}a_i(\sum_{\sum_{i=1}^{k}d_i=k-2}\prod_{i=1}^{k}\frac{a_i^{d_i}}{d_i!})\)</span></p><p>注意到<span class="math inline">\((k-2)!\prod_{i=1}^{k}a_i\)</span>是一个常数，我们只用看后面</p><p>记生成函数<spanclass="math inline">\(f_x=\sum_{i=0}^{\inf}\frac{x_i}{i!}=e^x\)</span></p><p>不难发现后面其实是k个函数<spanclass="math inline">\(f_{a_i}\)</span>的卷积的某一项,故最终答案为<spanclass="math inline">\([x^{k-2}]\prod_{i=1}^{k}e^{a_ix}=[x^{k-2}]e^{nx}=\frac{n^{k-2}}{(k-2)!}\)</span></p><p>所以最终答案为<spanclass="math inline">\(n^{k-2}\prod_{i=1}^{k}a_i\)</span></p><h3 id="lgv引理">LGV引理</h3><p>在一个有向无环图G中，出发点<spanclass="math inline">\(A=\{a_1,a_2,...a_n\}\)</span>，目标点<spanclass="math inline">\(B=\{b_1,b_2,..b_n\}\)</span>。有向边<spanclass="math inline">\(e\)</span>的权值为<spanclass="math inline">\(w_e\)</span>，<spanclass="math inline">\(e(u,v)\)</span>为路径边权乘积之和，即<spanclass="math inline">\(e(u,v)=\sum_{P:a-&gt;b}\prod_{e\inP}w_e\)</span></p><p>则<span class="math inline">\(\begin{vmatrix}  e(a_1,b_1)&amp;e(a_1,b_2) &amp; ... &amp; e(a_1,b_n)\\  e(a_2,b_1)&amp; e(a_2,b_1)&amp; ... &amp; e(a_2,b_n)\\  ...&amp; ... &amp; &amp;...\\  e(a_n,b_1)&amp; e(a_n,b_2) &amp; ... &amp; e(a_n,b_n)\end{vmatrix}=\sum_{S:A-&gt;B}(-1)^{N(\sigma)}\prod_{i=1}^n\prod_{e\inS_i}w_e\)</span></p><p>其中<span class="math inline">\(\sigma\)</span>是一个n元置换，<spanclass="math inline">\(N(\sigma)\)</span>表示逆序对个数,<spanclass="math inline">\(S_i:a_i-&gt;b_i\)</span>是一组A到B的不相交路径。</p><p><strong>此处的不相交是指处处不存在相同的点在两条路径中同时存在，起终点也不行，所以A里的元素互不相同。如果初始条件并非如此，可能要转化一下</strong></p><p>在算法竞赛中，该引理在普通的DAg下没有过多的用处，因为其右式还是过于复杂。但是如果图满足所有边权为1（这样<spanclass="math inline">\(e(u,v)\equiv1\)</span>,就可以表示路径数量了），并且只存在唯一的一个$<spanclass="math inline">\(满足所有\)</span>a_i-&gt;b_i$不相交的话，此时右式只有一个因子，含义就是整张图的不相交路径组数，就可以用左式的行列式表示了</p><p><a href="https://ac.nowcoder.com/acm/contest/28665/F">MonotonicMatrix</a></p><p>大意：</p><p><spanclass="math inline">\(A_1(1,0),A_2(0,1),B_1(n,m+1),B_2(n+1,m)\)</span>,求<spanclass="math inline">\(A_1-&gt;B_1,A_2-&gt;B_2\)</span>的不相交路径数。其中每一步只能向上/向右</p><p>套板子即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> il inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2010</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>ll n,m;<br>ll c[N][N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ll n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<span class="hljs-built_in">j</span>&lt;=i;++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>) c[i][j]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> c[i][j]=(c[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+c[i<span class="hljs-number">-1</span>][j])%mod;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">f</span><span class="hljs-params">(ll x1,ll y1,ll x2,ll y2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//(x1,y1)-&gt;(x2,y2)</span><br>    ll len1=x2-x1;<br>    ll len2=y2-y1;<br>    <span class="hljs-keyword">return</span> c[len1+len2][len2];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// cin&gt;&gt;n&gt;&gt;m;</span><br>    ll a=<span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,n,m+<span class="hljs-number">1</span>)*<span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,n+<span class="hljs-number">1</span>,m)%mod;<br>    ll b=<span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>,m)*<span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,n,m+<span class="hljs-number">1</span>)%mod;<br>    cout&lt;&lt;((a-b)%mod+mod)%mod&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//     freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">init</span>(<span class="hljs-number">2005</span>);<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)<br>    <span class="hljs-comment">// ll t;cin&gt;&gt;t;while(t--)</span><br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>组合数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>势函数与鞅的停时定理</title>
    <link href="/posts/7c056f9f/"/>
    <url>/posts/7c056f9f/</url>
    
    <content type="html"><![CDATA[<h2 id="势函数和鞅的停时定理">势函数和鞅的停时定理</h2><h3 id="前置芝士">前置芝士</h3><p>鞅：</p><p>鞅是一类特殊的随机过程，假设我们从一开始就在观察一场赌博游戏，现在已经得到了前t秒的观测值，那么当第t+1秒观测值的期望等于第t秒的观测值时，我们称这是一个公平赌博游戏。</p><p>具体来说，对于一个随机过程<spanclass="math inline">\({A_1,A_2,...}\)</span>,如果<spanclass="math inline">\(E(A_{n+1}|A_0,A_2,..A_n)=A_n\)</span>,我们称该随机过程为鞅。</p><p>鞅的停时定理：</p><p>设时停时间（在<strong>不知道随机过程的中间状态下</strong>停止的时刻）为t，则<spanclass="math inline">\(E(t)=E(0)\)</span></p><p>这个E到底是什么，由具体的情境而定，但是只要一个随机过程是一个鞅，它就有该结论</p><h3 id="势函数">势函数</h3><p>接下来我们考虑一个很常见的问题：</p><p>对于一个随机过程<spanclass="math inline">\({A_1,A_2,...}\)</span>,如果<strong>其终止状态<spanclass="math inline">\(A_t\)</span>是确定的</strong>，求<spanclass="math inline">\(E[t]\)</span>,即时停时刻的期望（<strong>注意这里我们不要求该随机过程是一个鞅</strong>）</p><p>为此，我们引入一个势函数<spanclass="math inline">\(\phi(X)\)</span></p><p>并且<span class="math inline">\(\phi(x)\)</span>满足如下性质：</p><ul><li><span class="math inline">\(\forall n&lt;t,E(\phi(A_{n+1})-\phi(A_n)|A_0,A_1,...A_n)=-1\)</span>,即势能不断降低</li><li><span class="math inline">\(E(\phi(A_t))=C\)</span>,是一个常值</li></ul><p>那么如果我们令<spanclass="math inline">\(X_t=\phi(A_t)+t\)</span>,则<spanclass="math inline">\(E(X_{n+1}-X_n|x_0,x_1...x_n)=E(\phi(A_{n+1})-\phi(A_n)+1|x_0,x_1...x_n)=E(\phi(A_{n+1})-\phi(A_n)|x_0,x_1...x_n)+1=0\)</span></p><p>我们发现随机过程<spanclass="math inline">\(X_t\)</span>就是一个鞅了</p><p>那么由鞅的停时原理，<spanclass="math inline">\(E(X_t)=E(X_0)\)</span>,即<spanclass="math inline">\(E(\phi(A_t)+t)=E(\phi(A_0)+0)\)</span>,也即<spanclass="math inline">\(E(\phi(A_t))+E(t)=E(\phi(A_0))\)</span></p><p>所以我们得到<strong><spanclass="math inline">\(E(t)=E(\phi(A_0))-E(\phi(A_t))\)</span></strong>,根据我们之前定义的性质，<spanclass="math inline">\(E(\phi)A_t\)</span>为一个常值，而<spanclass="math inline">\(E(\phi(A_0))\)</span>显然也是一个常值，所以只要能找到这个满足条件的势函数，就能很方便的求出<spanclass="math inline">\(E(t)\)</span></p><p>这里我们只是在随机过程<spanclass="math inline">\(X_t\)</span>中应用了停时定理，对原本的随机过程<spanclass="math inline">\(A_t\)</span>并没有做什么限制</p><p>接下来结合具体的题目来讨论一下如何构造这样的一个势函数</p><p><ahref="https://codeforces.com/contest/1349/problem/D">CF1349D</a></p><p>大意：</p><p>有n个人在玩传球游戏，一开始第<spanclass="math inline">\(i\)</span>个人有<spanclass="math inline">\(a_i\)</span>个球。每一次传球，等概率随机<strong>选中一个球</strong>，设其当前拥有者为<spanclass="math inline">\(i\)</span>，<spanclass="math inline">\(i\)</span>将这个球等概率随机传给另一个人<spanclass="math inline">\(j(j\neqi)\)</span>。当某一个人拥有所有球时，停止游戏。问游戏停止时的期望传球次数。</p><p>记球的总数为m</p><p>不妨记状态<spanclass="math inline">\(A_t=(a_{t,1},a_{t,2}...a_{t,n})\)</span>,一个n维向量，分别表示在时刻t，第i个人手中球的数量，显然它唯一地表示了某一个时刻的全局状态</p><p>也就是说，我们现在就把这个游戏过程抽象成了一个随机过程<spanclass="math inline">\(A_0,A_1....\)</span>,并且其停时为t。那么按照之前所说，我们需要去定义一个势函数<spanclass="math inline">\(\phi(A_t)\)</span>,为了计算方便，我们可以将<spanclass="math inline">\(\phi\)</span>具体到A的每一维向量，不妨记为<spanclass="math inline">\(\phi(A_t)=\sum_{i=1}^{n}f(a_{t,i})\)</span>,这里f是什么我们并不知道，但是如果我们知道了f，其实也就是相当于构造出了这个势能函数</p><p>这里再把我们定义的<spanclass="math inline">\(\phi\)</span>的性质再放一下</p><hr /><p><span class="math inline">\(\phi(x)\)</span>满足如下性质：</p><ul><li><span class="math inline">\(\forall n&lt;t,E(\phi(A_{n+1})-\phi(A_n)|A_0,A_1,...A_n)=-1\)</span>,即势能不断降低</li><li><span class="math inline">\(E(\phi(A_t))=C\)</span>,是一个常值</li></ul><hr /><p>那么我们首先来考虑第一个性质，为了方便，不妨先考虑<spanclass="math inline">\(E(\phi(A_{n+1})|A_0,A_1,...A_n)\)</span></p><p>发现传球过程就是一个<spanclass="math inline">\(Markov\)</span>过程，并且该时刻的状态只与上一个时刻的状态有关,所以<spanclass="math inline">\(E(\phi(A_{n+1})|A_0,A_1,...A_n)=E(\phi(A_{n+1})|A_n)\)</span></p><p>考虑一次转移的所有可能</p><p>i传球给j的概率是<span class="math inline">\(\Large\frac{a_{t,i}}{m}\frac{1}{n-1}\)</span></p><p><span class="math inline">\(\largeE(\phi(A_{n+1})|A_n)=\sum_{i=1}^{n}\sum_{j\neqi}\frac{a_{t,i}}{m}\frac{1}{n-1}[f(a_{t,i}-1)+f(a_{t,j}+1)+\sum_{k\notin(i,j)}f(a_{t,k})]\)</span></p><p><span class="math inline">\(\large=\sum_{i=1}^{n}\frac{a_{t,i}}{m}f(a_{t,i}-1)+\frac{m-a_{t,i}}{m(n-1)}f(a_{t,i}+1)+\frac{(m-a_{t,i})(n-2)}{m(n-1)}f(a_{t,i})\)</span></p><p>根据我们定义的性质<spanclass="math inline">\(E(\phi(A_{n+1})-\phi(A_n)|A_0,A_1,...A_n)=-1\)</span></p><p><spanclass="math inline">\(E(\phi(A_{n+1})-\phi(A_n)|A_0,A_1,...A_n)=E(\phi(A_{n+1})-\phi(A_n)|A_n)\)</span></p><p><span class="math inline">\(\large=(\sum_{i=1}^{n}\frac{a_{t,i}}{m}f(a_{t,i}-1)+\frac{m-a_{t,i}}{m(n-1)}f(a_{t,i}+1)+\frac{(m-a_{t,i})(n-2)}{m(n-1)}f(a_{t,i}))-\sumf(a_{t,i})=-1\)</span></p><p>所以<span class="math inline">\(\large \sumf(a_{t,i})=(\sum_{i=1}^{n}\frac{a_{t,i}}{m}f(a_{t,i}-1)+\frac{m-a_{t,i}}{m(n-1)}f(a_{t,i}+1)+\frac{(m-a_{t,i})(n-2)}{m(n-1)}f(a_{t,i}))+1\)</span></p><p>那么我们可以把末尾的1分配到每一个和式里面去，这样左右的形式就统一了</p><p>所以<span class="math inline">\(\large \sumf(a_{t,i})=\sum_{i=1}^{n}[\frac{a_{t,i}}{m}f(a_{t,i}-1)+\frac{m-a_{t,i}}{m(n-1)}f(a_{t,i}+1)+\frac{(m-a_{t,i})(n-2)}{m(n-1)}f(a_{t,i})+\frac{a_{t,i}}{m}]\)</span></p><p>那么不妨记<span class="math inline">\(\largef(a)=\frac{a}{m}f(a-1)+\frac{m-a}{m(n-1)}f(a+1)+\frac{(m-a)(n-2)}{m(n-1)}f(a)+\frac{a}{m}\)</span></p><p>这样和式还是成立的，我们也成功抽象出了f函数</p><p>再转化一下，<span class="math inline">\(\largef(a+1)=\frac{m+an-2a}{m-a}f(a)-\frac{a(n-1)}{m-a}(f(a-1)+1)\)</span></p><p>代入边界条件<span class="math inline">\(a=0\)</span>时，有<spanclass="math inline">\(f(1)=f(0)\)</span>,所以我们可以设<spanclass="math inline">\(f(1)=f(0)=0\)</span>,毕竟势函数的初值并不重要</p><p>这样就得到了f，也就是相当于得到了势函数<spanclass="math inline">\(\phi(x_t)=\sum_{i}f(x_{t,i})\)</span></p><p>然后考虑势函数的第二个性质：<spanclass="math inline">\(E(\phi(A_t))=C\)</span>是一个常值</p><p>显然<spanclass="math inline">\(E(\phi(A_t))=\sum_{i}f(a_{t,i})=f(m)+(n-1)f(0)\)</span>是一个常值</p><p>所以根据我们的结论，<spanclass="math inline">\(E(t)=E(\phi(A_0))-E(\phi(A_t))=\sum_{i}f(a_{0,i})-f(m)-(n-1)f(0)=\sum_{i}f(a_{0,i})-f(m)\)</span></p><p>这样我们就非常方便的得到了停时的期望</p><p>不妨来看一个近一点的例子</p><p><ahref="http://acm.hdu.edu.cn/contest/problem?cid=1102&amp;pid=1008">杭电多校09Coins</a></p><p>大意：</p><p>n个人，每个人手中初始有<spanclass="math inline">\(a_i\)</span>个硬币，每次随机选择两个人，第一个人给第二个人一个硬币，如果某个人手中没有硬币了，则立即退出游戏，不再回来。当某一个人拥有全部硬币时，游戏结束</p><p>问停时的期望</p><p>题意与上一题十分相像，但是该题存在人数不固定的情况，所以我们描述游戏局面的时候要稍微改变一下</p><p>还是令<span class="math inline">\(m=\sum a_i\)</span></p><p>令<spanclass="math inline">\(A_t=(a_{t,1},a_{t,2}...a_{t,h_t})\)</span>来描述第t个时刻的局面，其中<spanclass="math inline">\(h_t\)</span>表示当前的剩余人数，显然它不是一个固定的值。但是我们能保证<spanclass="math inline">\(\forall i\leq h_t,a_{t,i}&gt;0\)</span></p><p>仿照上一题的思路，我们令<spanclass="math inline">\(\phi(A_t)=\sum_{i=1}^{n}f(a_{t,i})\)</span>作为势函数，尝试确定f</p><p><span class="math inline">\(\largeE(\phi(A_{n+1})|A_n)=\sum_{i=1}^{h_t}\sum_{j\neqi}\frac{1}{h_t(h_t-1)}[f(a_{t,i}-1)+f(a_{t,j}+1)+\sum_{k\notin(i,j)}f(a_{t,k})]\)</span></p><p><span class="math inline">\(\large=\sum_{i=1}^{h_t}\frac{1}{h_t}f(a_{t,i}-1)+\frac{1}{h_t}f(a_{t,i}+1)+\frac{h_t}{h_t-2}f(a_{t,i})\)</span></p><p>代入<span class="math inline">\(\largeE(\phi(A_{n+1})-\phi(A_n)|A_0,A_1,...A_n)=-1\)</span>,也就是<spanclass="math inline">\(\largeE(\phi(A_{n+1})-\phi(A_n)|A_n)=-1\)</span>(显然这里当前局面也只与上一个局面有关)，有</p><p><span class="math inline">\(\large \sum_{i=1}^{h_t}f(a_{t,i})=[\sum_{i=1}^{h_t}\frac{1}{h_t}f(a_{t,i}-1)+\frac{1}{h_t}f(a_{t,i}+1)+\frac{h_t}{h_t-2}f(a_{t,i})]+1\)</span></p><p><span class="math inline">\(\large=\sum_{i=1}^{h_t}(\frac{1}{h_t}f(a_{t,i}-1)+\frac{1}{h_t}f(a_{t,i}+1)+\frac{h_t}{h_t-2}f(a_{t,i})+\frac{1}{h_t})\)</span></p><p>抽象出<span class="math inline">\(\largef(a)=\frac{1}{h}f(a-1)+\frac{1}{h}f(a+1)+\frac{h}{h-2}f(a)+\frac{1}{h}\)</span></p><p><span class="math inline">\(f(a+1)-f(a)=f(a)-f(a-1)-1\)</span></p><p>令<spanclass="math inline">\(g(a)=f(a)-f(a-1),有g(a)=g(0)-a\)</span>，则<spanclass="math inline">\(f(a)=f(0)+ag(0)-\frac{a(a+1)}{2}\)</span></p><p>取<span class="math inline">\(f(0)=g(0)=0\)</span>,则<spanclass="math inline">\(f(a)=-\frac{a(a+1)}{2}\)</span></p><p>所以<spanclass="math inline">\(E(t)=E(\phi(A_0))-E(\phi(A_t))=\sum_{i=1}^{n}f(a_{0,i})-f(m)\)</span></p><p>未完待续</p>]]></content>
    
    
    <categories>
      
      <category>鞅论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>学习笔记</tag>
      
      <tag>鞅论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分图博弈学习笔记</title>
    <link href="/posts/58faeac3/"/>
    <url>/posts/58faeac3/</url>
    
    <content type="html"><![CDATA[<h1 id="二分图博弈">二分图博弈</h1><p>二分图博弈是少有的直接跟图论挂钩的一种博弈模型</p><p>一个博弈是二分图博弈应当满足一下条件：</p><blockquote><ul><li>博弈人数为两人，轮流操作</li><li>博弈状态转移可以表示成一张二分图</li><li>不可访问已经访问过的状态</li><li>无法转移者负</li></ul></blockquote><p>拥有二分图这么良好的性质，该博弈模型自然而然的有一个很简单的结论：如果先手状态，我们记为P，<strong>一定</strong>在二分图的最大匹配中，那么先手必胜。否则先手必败。</p><p>那么我们来看看证明：</p><p>假设当前P不在最大匹配中，那么先手移动之后P一定会到达一个匹配点，否则我们就有了一个新的匹配，与最大匹配这一点矛盾。所以此时我们的局面是当前处于匹配点上，后手先行动。后手走的下一个点也一定是匹配点，否则就跟之前的路径形成了一条增广路，同样矛盾。所以接下来双方都是在匹配点上转移。显然最终移动步数为偶数，故此时后手必胜。</p><p>若P在最大匹配中，则只要仿照上述策略，就是一个必胜的局面。</p><p>如果P没有可以转移的局面，同样也是不在最大匹配中，当然也是必败。</p><hr /><blockquote><p>由此，对于一个二分图博弈，只要我们能够判断先手所在局面是否处在二分图的最大匹配上，即可判断必胜状态。</p></blockquote><p>如何判断一个点是否一定在最大匹配上？比较经典的套路就是先将其从图中移除，然后再加进来，看看是否还能对匹配有贡献。如果有的话，说明其一定处在最大匹配上。</p><p>具体实现，我们可以采用网络流。在建图的时候先不将P与源点或者汇点连接，这样跑网络流的时候就不会将其考虑进去。然后把P与源点/汇点连接，利用残量网络，再做一遍网络流。如果值非0，就是有贡献的。</p><p>但是该方法仅适用于单起点博弈。如果需要判断的局面过多，显然时间复杂度无法接受。</p><p>如果想要找出所有局面中的必胜局面，我们有更好的办法。</p><p>找出所有必胜局面，也就是找出所有<strong>一定</strong>处在最大匹配的点，相当于找出所有<strong>不一定</strong>在最大匹配上的点。</p><figure><img src="https://s2.loli.net/2023/12/19/XSdNGtm3z2luUCq.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><imgsrc="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="alt="点击并拖拽以移动" />编辑</p><p>非匹配边1-&gt;5和2-&gt;5匹配边<strong>可以互换最大匹配数不变</strong>，所以点1,2都<strong>不一定</strong>在最大匹配中。在该图的残量网络中，1-&gt;5的流量为1，匹配边5-&gt;2的反向流量为1，因此我们判断两条边可以互换。将与源点相连的边颜色col设为1，汇点设为0，dfs即可。这是判断与左部点的，判断右部点同理。</p><p><strong>但是，但是，并不是所有满足二分图博弈模型的题目都一定得通过网络流来求解，因为不同博弈模型本身有其独特的性质，可能可以通过其他途径求解，比如*<em><ahref="https://ac.nowcoder.com/acm/contest/57356/I">23牛客多校2 I Linkwith Gomoku</a>*</em></strong></p><p>然后就到了喜闻乐见的例题时间</p><p>[<a href="https://www.luogu.com.cn/problem/P4617">COCI2017-2018#5]Planinarenje</a></p><p>大意： <img src="https://s2.loli.net/2023/12/19/Ep9SIFb1a7Dk4UJ.png"alt="img" /><imgsrc="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="alt="点击并拖拽以移动" />​</p><p>模板题</p><p>不难发现，判负的条件与一方无法行动是等价的，所以该问题完美符合二分图博弈模型。然后又因为要对所有先手局面判断是否必胜，那么我们应该采用第二种方法。</p><p>code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll maxn=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>,maxm=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MaximumFlow</span><br>&#123;<br>    <span class="hljs-comment">//maxn 最多点数 maxm 最多边数</span><br>    <span class="hljs-type">int</span> h[maxn],e[maxm],ne[maxm],f[maxm],idx;<br>    <span class="hljs-type">int</span> d[maxn],cur[maxn];<br>    <span class="hljs-type">int</span> n,m,S,T,mxn;<br>    ll col[maxn],ans[maxn];<br>    ll flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> _s,<span class="hljs-type">int</span> <span class="hljs-type">_t</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        mxn=n,idx=<span class="hljs-number">0</span>,S=_s,T=<span class="hljs-type">_t</span>;<span class="hljs-comment">//mxn表示最大点的大小（包括S，T），用于初始化处理，_s表示源点，_T表示汇点</span><br>        <span class="hljs-comment">// memset(h,-1,sizeof h);</span><br>        <span class="hljs-keyword">while</span>(n&gt;=<span class="hljs-number">0</span>)<br>            h[n--]=<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ne[idx]=h[a],e[idx]=b,f[idx]=c,h[a]=idx++;<br>        ne[idx]=h[b],e[idx]=a,f[idx]=<span class="hljs-number">0</span>,h[b]=idx++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// memset(d,-1,sizeof d);</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=mxn;++i) d[i]=<span class="hljs-number">-1</span>;<br>        d[S]=<span class="hljs-number">0</span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt;q;<br>        q.<span class="hljs-built_in">push</span>(S);<br>        cur[S]=h[S];<br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> t=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])<br>            &#123;<br>                <span class="hljs-type">int</span> j=e[i];<br>                <span class="hljs-keyword">if</span>(d[j]==<span class="hljs-number">-1</span>&amp;&amp;f[i])<br>                &#123;<br>                    d[j]=d[t]+<span class="hljs-number">1</span>;<br>                    cur[j]=h[j];<br>                    <span class="hljs-keyword">if</span>(j==T)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> limit)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(u==T)<span class="hljs-keyword">return</span> limit;<br>        <span class="hljs-type">int</span> flow=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=cur[u];i!=<span class="hljs-number">-1</span>&amp;&amp;flow&lt;limit;i=ne[i])<br>        &#123;<br>            cur[u]=i;<br>            <span class="hljs-type">int</span> j=e[i];<br>            <span class="hljs-keyword">if</span>(d[j]==d[u]+<span class="hljs-number">1</span>&amp;&amp;f[i])<br>            &#123;<br>                <span class="hljs-type">int</span> t=<span class="hljs-built_in">find</span>(j,<span class="hljs-built_in">min</span>(f[i],limit-flow));<br>                <span class="hljs-keyword">if</span>(!t)d[j]=<span class="hljs-number">-1</span>;<br>                f[i]-=t,f[i^<span class="hljs-number">1</span>]+=t,flow+=t;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> flow;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> r=<span class="hljs-number">0</span>,flow;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>())<span class="hljs-keyword">while</span>(flow=<span class="hljs-built_in">find</span>(S,inf))r+=flow;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// vis[u]=1;</span><br>        <span class="hljs-keyword">if</span>(col[u]==t)<br>        &#123;<br>            flag=<span class="hljs-number">1</span>;<br>            ans[u]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];i!=<span class="hljs-number">-1</span>;i=ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j=e[i];<br>            <span class="hljs-keyword">if</span>(f[i]==t&amp;&amp;!ans[j])<br>            &#123;<br>                <span class="hljs-built_in">dfs</span>(j,t);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">judge</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">dinic</span>();<br>        <span class="hljs-built_in">dfs</span>(S,<span class="hljs-number">1</span>);<span class="hljs-built_in">dfs</span>(T,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br><br>&#125;f;<br>ll n,m;<br>ll S,T;<br>ll a,b;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    S=n*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;T=n*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>;<br>    f.<span class="hljs-built_in">init</span>(T+<span class="hljs-number">1</span>,S,T);<br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        f.<span class="hljs-built_in">addedge</span>(a,b+n,<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        f.<span class="hljs-built_in">addedge</span>(S,i,<span class="hljs-number">1</span>);<br>        f.col[i]=<span class="hljs-number">1</span>;<br>        f.<span class="hljs-built_in">addedge</span>(i+n,T,<span class="hljs-number">1</span>);<br>    &#125;<br>    f.<span class="hljs-built_in">judge</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(f.ans[i]==<span class="hljs-number">0</span>) cout&lt;&lt;<span class="hljs-string">&quot;Slavko&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;Mirko&quot;</span>&lt;&lt;endl;<br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="alt="点击并拖拽以移动" /><figcaption aria-hidden="true">点击并拖拽以移动</figcaption></figure><p><ahref="https://codeforces.com/gym/102832/problem/H">20ccpc长春H</a></p><p>大意：有m个数位的数字锁，存在若干状态不允许访问，也不允许访问之前访问过的节点，每次操作改变某一位，无法操作者负。给定锁的初始状态，问必胜状态。</p><p>思路：显然锁的状态是一张二分图，因为数位和奇偶性相同的状态显然无法一次到达。那么我们只要把非法的状态不加入图中，然后采用第一种判断方法就可以了。</p><p>code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll int</span><br><span class="hljs-type">const</span> ll INF=<span class="hljs-number">1e8</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e8</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>,maxm=<span class="hljs-number">9e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MaximumFlow</span><br>&#123;<br><br>    <span class="hljs-type">int</span> h[maxn],e[maxm],ne[maxm],f[maxm],idx;<br>    <span class="hljs-type">int</span> d[N],cur[N];<br>    <span class="hljs-type">int</span> n,m,S,T,mxn;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> _s,<span class="hljs-type">int</span> <span class="hljs-type">_t</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        mxn=n,idx=<span class="hljs-number">0</span>,S=_s,T=<span class="hljs-type">_t</span>;<br>        <span class="hljs-comment">// memset(h,-1,sizeof h);</span><br>        <span class="hljs-keyword">while</span>(n&gt;=<span class="hljs-number">0</span>)h[n--]=<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ne[idx]=h[a],e[idx]=b,f[idx]=c,h[a]=idx++;<br>        ne[idx]=h[b],e[idx]=a,f[idx]=<span class="hljs-number">0</span>,h[b]=idx++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> d);<br>        d[S]=<span class="hljs-number">0</span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt;q;<br>        q.<span class="hljs-built_in">push</span>(S);<br>        cur[S]=h[S];<br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> t=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])<br>            &#123;<br>                <span class="hljs-type">int</span> j=e[i];<br>                <span class="hljs-keyword">if</span>(d[j]==<span class="hljs-number">-1</span>&amp;&amp;f[i])<br>                &#123;<br>                    d[j]=d[t]+<span class="hljs-number">1</span>;<br>                    cur[j]=h[j];<br>                    <span class="hljs-keyword">if</span>(j==T)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> limit)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(u==T)<span class="hljs-keyword">return</span> limit;<br>        <span class="hljs-type">int</span> flow=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=cur[u];i!=<span class="hljs-number">-1</span>&amp;&amp;flow&lt;limit;i=ne[i])<br>        &#123;<br>            cur[u]=i;<br>            <span class="hljs-type">int</span> j=e[i];<br>            <span class="hljs-keyword">if</span>(d[j]==d[u]+<span class="hljs-number">1</span>&amp;&amp;f[i])<br>            &#123;<br>                <span class="hljs-type">int</span> t=<span class="hljs-built_in">find</span>(j,<span class="hljs-built_in">min</span>(f[i],limit-flow));<br>                <span class="hljs-keyword">if</span>(!t)d[j]=<span class="hljs-number">-1</span>;<br>                f[i]-=t,f[i^<span class="hljs-number">1</span>]+=t,flow+=t;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> flow;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> r=<span class="hljs-number">0</span>,flow;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>())<span class="hljs-keyword">while</span>(flow=<span class="hljs-built_in">find</span>(S,inf))r+=flow;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;f;<br>ll n,m,pwd;<br>ll vis[N];<br>ll c[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">100</span>,<span class="hljs-number">1000</span>,<span class="hljs-number">10000</span>,<span class="hljs-number">100000</span>&#125;;<br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x)<br>    &#123;<br>        sum+=x%<span class="hljs-number">10</span>;<br>        x/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum%<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;m&gt;&gt;n&gt;&gt;pwd;<br>    <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> vis);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        ll a;cin&gt;&gt;a;vis[a]=<span class="hljs-number">1</span>;<br>    &#125;<br>    ll up=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) up*=<span class="hljs-number">10</span>;<br>    ll S=up,T=up+<span class="hljs-number">1</span>;<br>    f.<span class="hljs-built_in">init</span>(up+<span class="hljs-number">5</span>,S,T);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;up;++i)<br>    &#123;<br>        <span class="hljs-comment">//判断pwd是否一定在二分图的最大匹配中，一开始不将其与S或T连边</span><br>        <span class="hljs-comment">//但是与网络其他节点相连。跑完网络流之后将pwd与对应起点/终点相连。</span><br>        <span class="hljs-comment">//利用残量网络再跑一遍网络流。如果值大于0，代表其一定在二分图的最大匹配中</span><br>        <span class="hljs-keyword">if</span>(vis[i]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(i))<br>        &#123;<br>            <span class="hljs-keyword">if</span>(i!=pwd) f.<span class="hljs-built_in">addedge</span>(i,T,<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i!=pwd) f.<span class="hljs-built_in">addedge</span>(S,i,<span class="hljs-number">1</span>);<br><br>        ll x;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;++j)<br>        &#123;<br>            x=i;<br>            <span class="hljs-type">int</span> num=i;<br>            x/=c[j];<br>            x%=<span class="hljs-number">10</span>;<br>            num=num-x*c[j];<br>            ll t1=num+((x+<span class="hljs-number">1</span>)%<span class="hljs-number">10</span>)*c[j];<br>            f.<span class="hljs-built_in">addedge</span>(i,t1,<span class="hljs-number">1</span>);<br>            t1=num+((x<span class="hljs-number">-1</span>+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>)*c[j];<br>            f.<span class="hljs-built_in">addedge</span>(i,t1,<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    f.<span class="hljs-built_in">dinic</span>();<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(pwd)) f.<span class="hljs-built_in">addedge</span>(pwd,T,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">else</span> f.<span class="hljs-built_in">addedge</span>(S,pwd,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(f.<span class="hljs-built_in">dinic</span>()) cout&lt;&lt;<span class="hljs-string">&quot;Alice&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;Bob&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    ll t;cin&gt;&gt;t;<span class="hljs-keyword">while</span>(t--)<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="alt="点击并拖拽以移动" /><figcaption aria-hidden="true">点击并拖拽以移动</figcaption></figure><p>[<a href="https://www.luogu.com.cn/problem/P1971">NOI2011]兔兔与蛋蛋游戏</a></p><p>大意：</p><p>n行m列的棋盘，每一格有一个黑/白棋，还有一个位置是空的</p><p>每一局游戏总是兔兔先操作，之后双方轮流操作，具体操作为：</p><ul><li>兔兔每次操作时，选择一枚与空格相邻的白色棋子，将它移进空格。</li><li>蛋蛋每次操作时，选择一枚与空格相邻的黑色棋子，将它移进空格。</li></ul><p>第一个不能按照规则操作的人输掉游戏。</p><p>思路： 有幸做出人生第二道黑题（敲下来有阻塞，但没想象中那么费劲）</p><p>我们稍微转化一下，将黑白棋的移动看成空格的移动。先手操作的时候，空格只能与白棋交换，此空格相当于黑棋。后手操作的时候，空格只能与黑棋交换，此时空格相当于白棋。所以相当于轮流在黑白棋之间切换，每次只能与不同颜色的点交换位置，显然是一张二分图。此外有一个性质比较隐蔽，那就是我们无法访问之前访问过的局面。因为黑白棋是轮流操作的，黑棋走过的点白棋是无法走的，反之同理。由此，我们成功转化成了二分图博弈，</p><p>这题要求我们输出所有操作失误的步骤。其实就是操作前后的都处于必胜状态的点。（仔细想想，不难理解）。每次操作之后整张图都不一样了，我们要判断的起始点也不一样了，所以我们每次要重新建图，因为图比较小，所以该方法是可行的。</p><p>code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">110</span>;<br><span class="hljs-type">const</span> ll INF=<span class="hljs-number">0x3f3f3f3f</span>,inf=INF;<br><span class="hljs-type">const</span> ll maxn=<span class="hljs-number">4000</span>,maxm=maxn*<span class="hljs-number">20</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MaximumFlow</span><br>&#123;<br>    <span class="hljs-comment">//maxn 最多点数 maxm 最多边数</span><br>    <span class="hljs-type">int</span> h[maxn],e[maxm],ne[maxm],f[maxm],idx;<br>    <span class="hljs-type">int</span> d[maxn],cur[maxn];<br>    <span class="hljs-type">int</span> n,m,S,T,mxn;<br>    ll mp_vis[maxn];<br>    ll col[maxn],ans[maxn];<br>    ll flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> _s,<span class="hljs-type">int</span> <span class="hljs-type">_t</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        mxn=n,idx=<span class="hljs-number">0</span>,S=_s,T=<span class="hljs-type">_t</span>;<span class="hljs-comment">//mxn表示最大点的大小（包括S，T），用于初始化处理，_s表示源点，_T表示汇点</span><br>        <span class="hljs-comment">// memset(h,-1,sizeof h);</span><br>        <span class="hljs-keyword">while</span>(n&gt;=<span class="hljs-number">0</span>)<br>            h[n--]=<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ne[idx]=h[a],e[idx]=b,f[idx]=c,h[a]=idx++;<br>        ne[idx]=h[b],e[idx]=a,f[idx]=<span class="hljs-number">0</span>,h[b]=idx++;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// memset(d,-1,sizeof d);</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=mxn;++i) d[i]=<span class="hljs-number">-1</span>;<br>        d[S]=<span class="hljs-number">0</span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt;q;<br>        q.<span class="hljs-built_in">push</span>(S);<br>        cur[S]=h[S];<br>        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> t=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];i!=<span class="hljs-number">-1</span>;i=ne[i])<br>            &#123;<br>                <span class="hljs-type">int</span> j=e[i];<br>                <span class="hljs-keyword">if</span>(d[j]==<span class="hljs-number">-1</span>&amp;&amp;f[i])<br>                &#123;<br>                    d[j]=d[t]+<span class="hljs-number">1</span>;<br>                    cur[j]=h[j];<br>                    <span class="hljs-keyword">if</span>(j==T)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> limit)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(u==T)<span class="hljs-keyword">return</span> limit;<br>        <span class="hljs-type">int</span> flow=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=cur[u];i!=<span class="hljs-number">-1</span>&amp;&amp;flow&lt;limit;i=ne[i])<br>        &#123;<br>            cur[u]=i;<br>            <span class="hljs-type">int</span> j=e[i];<br>            <span class="hljs-keyword">if</span>(d[j]==d[u]+<span class="hljs-number">1</span>&amp;&amp;f[i])<br>            &#123;<br>                <span class="hljs-type">int</span> t=<span class="hljs-built_in">find</span>(j,<span class="hljs-built_in">min</span>(f[i],limit-flow));<br>                <span class="hljs-keyword">if</span>(!t)d[j]=<span class="hljs-number">-1</span>;<br>                f[i]-=t,f[i^<span class="hljs-number">1</span>]+=t,flow+=t;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> flow;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dinic</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> r=<span class="hljs-number">0</span>,flow;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">bfs</span>())<span class="hljs-keyword">while</span>(flow=<span class="hljs-built_in">find</span>(S,inf))r+=flow;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[x];i!=<span class="hljs-number">-1</span>;i=ne[i])<br>        &#123;<br>            ll Y=e[i];<br>            <span class="hljs-keyword">if</span>(Y==y) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;f;<br>ll n,m;<br><span class="hljs-type">char</span> mp[N][N];<br>ll px,py;<br>ll S,T;<br>vector&lt;ll&gt; ans;<br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> y+(x<span class="hljs-number">-1</span>)*m;<br>&#125;<br>ll dir[][<span class="hljs-number">4</span>]=&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">inmap</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x&gt;=<span class="hljs-number">1</span>&amp;&amp;y&gt;=<span class="hljs-number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&lt;=m;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">jd</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x==px&amp;&amp;y==py) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//是当前操作点</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">gt</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//奇数点与汇点相连</span><br>    <span class="hljs-comment">//偶数点与源点相连</span><br>    f.<span class="hljs-built_in">init</span>(n*m+<span class="hljs-number">5</span>,S,T);<span class="hljs-comment">//每次要将起始点与源点/汇点断开连接，重新建图，反正图也不大</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">jd</span>(i,j)) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//去掉操作起始点</span><br>            <span class="hljs-keyword">if</span>((i+j)%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            f.<span class="hljs-built_in">addedge</span>(<span class="hljs-built_in">gt</span>(i,j),T,<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>((i+j)%<span class="hljs-number">2</span>) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//去掉操作起始点</span><br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">jd</span>(i,j)) f.<span class="hljs-built_in">addedge</span>(S,<span class="hljs-built_in">gt</span>(i,j),<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;++k)<br>            &#123;<br>                ll xx=i+dir[k][<span class="hljs-number">0</span>];<br>                ll yy=j+dir[k][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">inmap</span>(xx,yy)) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span>(mp[xx][yy]==mp[i][j]) <span class="hljs-keyword">continue</span>;<br>                f.<span class="hljs-built_in">addedge</span>(<span class="hljs-built_in">gt</span>(i,j),<span class="hljs-built_in">gt</span>(xx,yy),<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    f.<span class="hljs-built_in">dinic</span>();<br>    <span class="hljs-keyword">if</span>((px+py)%<span class="hljs-number">2</span>) f.<span class="hljs-built_in">addedge</span>(<span class="hljs-built_in">gt</span>(px,py),T,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">else</span> f.<span class="hljs-built_in">addedge</span>(S,<span class="hljs-built_in">gt</span>(px,py),<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> f.<span class="hljs-built_in">dinic</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>        &#123;<br>            cin&gt;&gt;mp[i][j];<br>            <span class="hljs-keyword">if</span>(mp[i][j]==<span class="hljs-string">&#x27;.&#x27;</span>)<br>            &#123;<br>                px=i;py=j;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">////////////////////////</span><br><br><br>    S=n*m+<span class="hljs-number">1</span>,T=n*m+<span class="hljs-number">2</span>;<br>    ll op;cin&gt;&gt;op;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> dx=<span class="hljs-number">1</span>;dx&lt;=op;++dx)<br>    &#123;<br>        ll a,b;cin&gt;&gt;a&gt;&gt;b;<br>        mp[px][py]=<span class="hljs-string">&#x27;X&#x27;</span>;<span class="hljs-comment">//因为先手操作之后不能返回当前局面，所以要将这个位置置为X</span><br>        ll pre_1=<span class="hljs-built_in">gt</span>();<br>        mp[px][py]=<span class="hljs-string">&#x27;.&#x27;</span>;<span class="hljs-comment">//</span><br>        <span class="hljs-built_in">swap</span>(mp[px][py],mp[a][b]);<br>        px=a;py=b;<br><br>        mp[px][py]=<span class="hljs-string">&#x27;O&#x27;</span>;<span class="hljs-comment">//与上面改成X是同理的</span><br>        ll pre_2=<span class="hljs-built_in">gt</span>();<br>        mp[px][py]=<span class="hljs-string">&#x27;.&#x27;</span>;<span class="hljs-comment">//</span><br>        <span class="hljs-comment">// cout&lt;&lt;dx&lt;&lt;&#x27; &#x27;&lt;&lt;px&lt;&lt;&#x27; &#x27;&lt;&lt;py&lt;&lt;&#x27; &#x27;&lt;&lt;pre_1&lt;&lt;&#x27; &#x27;&lt;&lt;pre_2&lt;&lt;endl;</span><br>        <span class="hljs-keyword">if</span>(pre_1&amp;&amp;pre_2)<br>        &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(dx);<br>            <span class="hljs-comment">//如果前后都是必胜态，那么该操作失误</span><br>        &#125;<br>        <span class="hljs-comment">///</span><br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-built_in">swap</span>(mp[px][py],mp[a][b]);<br>        px=a;py=b;<br>    &#125;<br><br>    cout&lt;&lt;ans.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:ans) cout&lt;&lt;i&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博弈论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>学习笔记</tag>
      
      <tag>博弈论</tag>
      
      <tag>图论</tag>
      
      <tag>网络流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>各类基于决策单调性的dp优化</title>
    <link href="/posts/f5300cf/"/>
    <url>/posts/f5300cf/</url>
    
    <content type="html"><![CDATA[<h2 id="基于决策单调性的dp优化">基于决策单调性的dp优化</h2><h3 id="对于决策单调性的一般解释">对于决策单调性的一般解释</h3><p>对于一个常见的一维<spanclass="math inline">\(dp:dp_i=min/max\{dp_j+w(j,i)\}\)</span>,显然每一个点的dp值只能从<spanclass="math inline">\(\{j|j&lt;i\}\)</span>的<spanclass="math inline">\(dp_j\)</span>转移而来，我们记每一个点<spanclass="math inline">\(i\)</span>的最优决策转移点为<spanclass="math inline">\(p_i\)</span>.如果我们从1-n遍历i，<spanclass="math inline">\(p_i\)</span>也随之单调变化，那么这个dp就具有决策单调性了.大部分决策单调性体现在决策点单调递增，但是也有决策点单调递减的情况(都是建立在枚举的点是从小到大的情况下)</p><h3 id="关于决策单调性的证明">关于决策单调性的证明</h3><p>该部分讲解如无特殊声明，都是建立在求<strong>最小化</strong>问题的基础上，如果要求最大化的话，将对应不等号取反即可</p><h4 id="四边形不等式">四边形不等式</h4><h5 id="一维dp">一维dp</h5><p>对应方程形式<span class="math inline">\(F\)</span> :<spanclass="math inline">\(\largedp_i=min_{j&lt;i}\{dp_j+w(j,i)\}\)</span></p><p>我们考虑<span class="math inline">\(p_1\leq p_2\leq p_3\leqp_4\)</span></p><p>则<strong>最小化情况</strong>下的<strong>四边形不等式</strong>表示为：<spanclass="math inline">\(w(p_1,p_3)+w(p_2,p_4)\leqw(p_1,p_4)+w(p_2,p_3)\)</span></p><p>特别的，如果等号永远成立，称为<strong>四边形恒等式</strong></p><p>一般记为：<strong>交叉<spanclass="math inline">\(\leq\)</span>包含</strong></p><blockquote><p>定理1：如果对于dp式F,其w满足四边形不等式，则F满足决策单调性</p></blockquote><ul><li><p><span class="math inline">\(Proof:\)</span></p><p>反证法。记<spanclass="math inline">\(dp_i\)</span>的最优决策点为<spanclass="math inline">\(p_i\)</span>,假设<spanclass="math inline">\(y&lt;x\)</span>且<spanclass="math inline">\(p_x&lt;p_y\)</span>.根据<spanclass="math inline">\(F\)</span>的定义有：<spanclass="math inline">\(dp_x=dp_{p_x}+w(p_x,x)\leqdp_{p_y}+w(p_y,x)(1)\)</span></p><p>不难发现<spanclass="math inline">\(p_x&lt;p_y&lt;y&lt;x\)</span>,故由四边形不等式：<spanclass="math inline">\(w(p_x,y)+w(p_y,x)\leqw(p_x,x)+w(p_y,y)(2)\)</span></p><p><span class="math inline">\(1,2\)</span>两式相加得到:<spanclass="math inline">\(dp_{p_x}+w(p_x,y)\leqdp_{p_y}+w(p_y,y)\)</span></p><p>则对于<span class="math inline">\(y\)</span>来说，<spanclass="math inline">\(p_x\)</span>是一个比<spanclass="math inline">\(p_y\)</span>更优的决策点，与条件矛盾。</p><p>故<span class="math inline">\(y&lt;x\)</span>意味着<spanclass="math inline">\(p_y\leq p_x\)</span>，单调性得证</p></li></ul><h5 id="区间dp">区间dp</h5><p>一般来说高维dp的决策单调性体现在某一个维度，相对一维dp来说也会更加难发现，但是一种区间dp具有较好的性质</p><p>对应方程形式<span class="math inline">\(F\)</span> <spanclass="math inline">\(\large:dp_{i,j}=min_{k=i}^{j-1}\{dp_{i,k}+dp_{k+1,j}+w(i,j)\}\)</span></p><p>这里先介绍一个跟四边形不等式非常像的<strong>区间包含不等式</strong>：考虑<spanclass="math inline">\(p_1\leq p_2\leq p_3\leq p_4\)</span>,则<spanclass="math inline">\(w(p_1,p_4)\geq w(p_2,p_3)\)</span></p><blockquote><p>引理1：如果对于dp式F，其w同时满足四边形不等式以及区间包含不等式，则F也满足四边形不等式</p></blockquote><ul><li><p><span class="math inline">\(Proof:\)</span></p><p><a href="https://oi-wiki.org/dp/opt/quadrangle/">OIWIKI</a></p></li></ul><blockquote><p>定理2：如果对于dp式F，其满足四边形不等式，记<spanclass="math inline">\(p_{i,j}为dp_{i,j}\)</span>的最优决策点，则<spanclass="math inline">\(\forall i&lt;j,p_{i,j-1}\leq p_{i,j}\leqp_{i+1,j}\)</span></p></blockquote><ul><li><p><span class="math inline">\(Proof:\)</span></p><p><a href="https://oi-wiki.org/dp/opt/quadrangle/">OIWIKI</a></p></li></ul><p>基于此，我们对于<spanclass="math inline">\(F\)</span>就能给出一个复杂度为<spanclass="math inline">\(O(n^2)\)</span>的优化。</p><p>如果在计算<span class="math inline">\(f_{i,j}\)</span>的同时记录<spanclass="math inline">\(p_{i,j}\)</span>，则对决策点<spanclass="math inline">\(K\)</span>的枚举量为<spanclass="math inline">\(\sum_{1\leq i&lt;j\leq n}p_{i+1,j}-p_{i,j-1}=\sum_{i=1}^{n}p_{i,n}-p_{1,i}\leq n^2\)</span></p><p>例题：</p><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=3506">HDU MonkeyParty</a></p><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=3516">HDU TreeConstruction</a></p><p>这里给出Monkey Party的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">2020</span>;<br>ll n;<br>ll mas[N];<br>ll dp[N][N];<br>ll s[N][N];<br>ll sum[N];<br><span class="hljs-function">ll <span class="hljs-title">w</span><span class="hljs-params">(ll l,ll r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> sum[r]-sum[l<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">while</span>(cin&gt;&gt;n)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;mas[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>+n;i&lt;=n+n;++i) mas[i]=mas[i-n];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+n;++i) sum[i]=sum[i<span class="hljs-number">-1</span>]+mas[i];<br><span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dp);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+n;++i) dp[i][i]=<span class="hljs-number">0</span>,s[i][i]=i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">2</span>;len&lt;=n;len++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n-len+<span class="hljs-number">1</span>;i++)&#123;<br>                <span class="hljs-type">int</span> j=i+len<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=s[i][j<span class="hljs-number">-1</span>];k&lt;=s[i+<span class="hljs-number">1</span>][j];k++)&#123;<br>                    <span class="hljs-keyword">if</span>(dp[i][j]&gt;dp[i][k]+dp[k+<span class="hljs-number">1</span>][j]+sum[j]-sum[i<span class="hljs-number">-1</span>])&#123;<br>                        dp[i][j]=dp[i][k]+dp[k+<span class="hljs-number">1</span>][j]+sum[j]-sum[i<span class="hljs-number">-1</span>];<br>                        s[i][j]=k;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>ll ans=<span class="hljs-number">1e17</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>;l&lt;=n;++l)<br>&#123;<br>ans=<span class="hljs-built_in">min</span>(ans,dp[l][l+n<span class="hljs-number">-1</span>]);<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h5 id="一种二维dp">一种二维dp</h5><p>这一块存疑</p><p>也是一种非常常见的dp式<span class="math inline">\(f\)</span> <spanclass="math inline">\(:dp_{i,j}=min_{k&lt;i}\{dp_{k,j-1}+w(k,i)\}\)</span></p><p>理论上它与上一块的区间dp是不同类型的，但是仿佛只要<spanclass="math inline">\(w\)</span>满足引理1，<spanclass="math inline">\(F\)</span>也有同样的结论。我没看到过严格证明，OIWIKI上也没找到对应介绍，但是大家好像都默认这是正确的，而且本人目前没找到反例</p><p>反正用定理2来优化该dp的话，时间复杂度是<spanclass="math inline">\(O(n^2)\)</span>的</p><p>例题：</p><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=3480">HDUDivision</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll int</span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">10005</span>;<br>ll t,n,m;<br>ll dp[N][<span class="hljs-number">5010</span>];<br>ll mas[N];<br><span class="hljs-function">ll <span class="hljs-title">f</span><span class="hljs-params">(ll l,ll r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (mas[r]-mas[l])*(mas[r]-mas[l]);<br>&#125; <br>ll d[N][<span class="hljs-number">5010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;t;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s=<span class="hljs-number">1</span>;s&lt;=t;++s)<br>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;mas[i];<br><span class="hljs-built_in">sort</span>(mas+<span class="hljs-number">1</span>,mas+<span class="hljs-number">1</span>+n);<br><span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dp);<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>&#123;<br>d[n+<span class="hljs-number">1</span>][j]=n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i;--i)<br>&#123;<br>ll tmp=<span class="hljs-number">0x3f3f3f3f</span>;<br>ll p;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=d[i][j<span class="hljs-number">-1</span>];k&lt;=d[i+<span class="hljs-number">1</span>][j];++k)<br>&#123;<br><span class="hljs-keyword">if</span>(tmp&gt;dp[k][j<span class="hljs-number">-1</span>]+<span class="hljs-built_in">f</span>(k+<span class="hljs-number">1</span>,i))<br>&#123;<br>tmp=dp[k][j<span class="hljs-number">-1</span>]+<span class="hljs-built_in">f</span>(k+<span class="hljs-number">1</span>,i);<br>p=k;<br>&#125;<br>&#125;<br>dp[i][j]=tmp;<br>d[i][j]=p;<br>&#125;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;Case &quot;</span>&lt;&lt;s&lt;&lt;<span class="hljs-string">&quot;: &quot;</span>&lt;&lt;dp[n][m]&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h5 id="一些满足四边形不等式的函数类">一些满足四边形不等式的函数类</h5><ul><li>若<spanclass="math inline">\(w_{1(i,j)},w_{2(i,j)}\)</span>均满足四边形不等式（或区间包含不等式），则<spanclass="math inline">\(\forall c_1,c_2\geq 0\)</span>,<spanclass="math inline">\(c_1w_{1(i,j)}+c_2w_{2(i,j)}\)</span>也对应地满足四边形不等式（或区间包含不等式）</li><li>若存在函数<span class="math inline">\(f,g\)</span>，使得<spanclass="math inline">\(w_{l,r}=f_r-g_l\)</span>,则<spanclass="math inline">\(w\)</span>满足<strong>四边形恒等式</strong>（等号永远成立）。当<spanclass="math inline">\(f,g\)</span>单调增的时候，<spanclass="math inline">\(w\)</span>还满足区间包含不等式</li><li>设<spanclass="math inline">\(h_x\)</span>是一个单调增的下凸函数，若<spanclass="math inline">\(w\)</span>满足四边形不等式以及区间包含不等式，则<spanclass="math inline">\(h(w(x))\)</span>也满足四边形不等式以及区间包含不等式</li><li>设<span class="math inline">\(h_x\)</span>是一个下凸函数,若<spanclass="math inline">\(w\)</span>满足<strong>四边形恒等式</strong>以及区间包含不等式，则<spanclass="math inline">\(h(w(x))\)</span>满足四边形不等式</li></ul><p>具体证明详见<ahref="https://oi-wiki.org/dp/opt/quadrangle/">OIWIKI</a></p><p>这里以<a href="https://www.luogu.com.cn/problem/P1912">NOI 2009诗人小G</a>的dp递推式来试着用这些结论证一下决策单调性</p><p><span class="math inline">\(dp_i=min_{0\leqj&lt;i}\{dp_j+|s_i-s_j-1-L|^P\}\)</span>,其中<spanclass="math inline">\(s_i=i+\sum_{k=1}^{i}a_k\)</span>,<spanclass="math inline">\(a_k&gt;0\)</span>为常值</p><p>这里<spanclass="math inline">\(w_{j,i}=|s_i-s_j-1-L|^P\)</span>,我们不妨记<spanclass="math inline">\(m_{j,i}=s_i-s_j-1-L\)</span>,则<spanclass="math inline">\(w_{j,i}=|m_{j,i}|^P\)</span></p><p>我们考虑利用第2条结论：记<spanclass="math inline">\(f_i=s_i-1-L,g_i=s_i\)</span>,显然<spanclass="math inline">\(m_{j,i}=f_i-g_j\)</span>,故<spanclass="math inline">\(m_{j,i}\)</span>满足四边形不等式,又<spanclass="math inline">\(f_i,g_i\)</span>显然单增，故<spanclass="math inline">\(m_{j,i}\)</span>满足区间包含不等式</p><p>又函数<spanclass="math inline">\(|x|^P\)</span>显然是一个下凸函数，故由第4条结论可知，<spanclass="math inline">\(w_{j,i}=m_{j,i}\)</span>也满足四边形不等式。再由定理1，该dp式满足决策单调性。证毕。</p><p>可以看到如果式子能记住的话，在面对一些比较复杂的递推式的时候能够较从容地推出决策单调性，如果直接用四边形不等式的定义硬证这题的话，还是需要不少分类讨论和强大的推柿子能力的（啊...只会套公式的屑）</p><h4 id="与图形相结合">与图形相结合</h4><p>来自一位大佬的<ahref="https://www.luogu.com.cn/problem/solution/P1912">奇妙讨论</a>,从另一个视角帮助我们理解了决策单调性</p><p>这里讨论一维最优化dp，也就是<span class="math inline">\(F\)</span><span class="math inline">\(:dp_i=min_{j\leqi}\{dp_j+w(j,i)\}\)</span></p><p>决策单调性意味着决策点是单调的，换句话说，每一个点能够作为最优决策点的范围是一段连续区间</p><p><img src="https://s2.loli.net/2023/12/19/Ju8HYI5Z7Ge3hcb.png" alt="image-20230904215014871" style="zoom:100%;" /></p><p>在绿色区间内的点都是被<spanclass="math inline">\(dp_{j_1}\)</span>更新，在黄色区间内的点都是被<spanclass="math inline">\(dp_{j_2}\)</span>更新，不会出现黄色区间内有某个点是被<spanclass="math inline">\(dp_{j_1}\)</span>更新的情况，否则就违背了决策单调性的定义</p><p>从几何视角来看这一事实。我们考虑<spanclass="math inline">\(g_j(i)\)</span>，表示<spanclass="math inline">\(dp_j+w(j,i)\)</span>,则<spanclass="math inline">\(dp_i\)</span>可以重新表示为<spanclass="math inline">\(dp_i=min_{j\leqi}\{g_j(i)\}\)</span>。我们可以将<spanclass="math inline">\(g_j(i)\)</span>看成<spanclass="math inline">\(j\)</span>为常值，<spanclass="math inline">\(i\)</span>为自变量的一个函数，那么<spanclass="math inline">\(dp_i\)</span>本质上就是在所有函数<spanclass="math inline">\(g_j(i)\)</span>里取最小值来转移</p><p>还是以上图为例，绿色区间内的点对应函数<spanclass="math inline">\(g_{j_1}(i)\)</span>,黄色区间内对应函数<spanclass="math inline">\(g_{j_2}(i)\)</span>,我们可以得到一个结论：两个函数只能有一个交点，否则就会出现前一段是<spanclass="math inline">\(g_{j_1}(i)\)</span>更小,中间是<spanclass="math inline">\(g_{j_2}(i)\)</span>,后面又变成<spanclass="math inline">\(g_{j_1}(i)\)</span>更小的局面，那就违背了决策单调性的定义。反过来，如果只有一个交点的话，这两段区间就满足决策单调性</p><p>整体来看，我们可以得到：<strong>如果所有<spanclass="math inline">\(g_j(i)\)</span>两两之间都至多只有一个交点的话，<spanclass="math inline">\(F\)</span>是满足决策单调性的</strong>。个人感觉该命题的逆命题并不成立，毕竟实际在转移的时候只用考虑最小值的变化，值较大的函数之间是如何纠缠的我们并不关系。所以该结论应该只适用于证明决策单调性，而不能证否决策单调性</p><p>接下来我们考虑，如果<spanclass="math inline">\(g_j(i)\)</span>之间至多只有一个交点，需要满足什么性质</p><p>该大佬给出的两个条件是：</p><ul><li><spanclass="math inline">\(g_j(i)\)</span>之间可以通过平移相互变换</li><li><spanclass="math inline">\(g_j(i)\)</span>的导函数在定义域内单调增/减（凸性唯一）</li></ul><p>以下分别是不满足对应条件的反例</p><p><img src="https://s2.loli.net/2023/12/19/xuIRkf4nhUZlaJr.png" alt="image-20230904215014871" style="zoom:100%;" /></p><p><img src="https://s2.loli.net/2023/12/19/uT5wJd3liy2AYzs.png" alt="image-20230904215014871" style="zoom:100%;" /></p><p>这两个条件不一定充分，只是感觉上可能也够了</p><p>然后大佬给出的一些总结：</p><ul><li><p>如果导函数递增，求最大值，或导函数递减，求最小值用单调栈</p></li><li><p>如果导函数递增，求最小值，或导函数递减，求最大值用单调队列</p></li></ul><p>具体怎么用单调栈，单调队列，我会在后面有所涉及</p><h3 id="决策单调性的常见优化手段">决策单调性的常见优化手段</h3><h4 id="二分队列">二分队列</h4><p>这应该算是最常见的一种利用决策单调性来优化dp的手段了。它只能用于决策点单调增的情况。</p><p>考虑之前的一个结论：每一个决策点的更新范围是一段连续区间。这意味着相邻两个决策点的更新范围之间存在着一个分界线<spanclass="math inline">\(K\)</span>,当<spanclass="math inline">\(i&lt;=k\)</span>的时候，由前一个点<spanclass="math inline">\(j_1\)</span>更新，之后就由后一个点<spanclass="math inline">\(j_2\)</span>更新,并且<spanclass="math inline">\(j_1\)</span>就再也没有机会了。那么我们就可以维护一个单调队列来实现每次<spanclass="math inline">\(O(logn)\)</span>的更新</p><p>具体来说，我们的单调队列中的每一个元素是一个三元组<spanclass="math inline">\(\{P,l_p,r_p\}\)</span>,分别表示当前的决策点<spanclass="math inline">\(P\)</span>,它能更新区间的左界<spanclass="math inline">\(l_p\)</span>,它能更新区间的右界<spanclass="math inline">\(r_p\)</span>。那么当我们尝试更新<spanclass="math inline">\(dp_i\)</span>的时候，</p><ul><li><p>弹出队头。因为队列里的点的对应决策区间是单调的，所以我们可以直接将<spanclass="math inline">\(r_p&lt;i\)</span>的队头三元组不断弹出。</p></li><li><p>用队头的<span class="math inline">\(P\)</span>更新<spanclass="math inline">\(dp_i\)</span></p></li><li><p>将三元组<spanclass="math inline">\(\{i,l_i,r_i\}\)</span>放入队列尾部。那么怎么求<spanclass="math inline">\(l_i,r_i\)</span>?在求<spanclass="math inline">\(l_i\)</span>之前，我们要意识到一个事实：我们所求的<spanclass="math inline">\(l_p,r_p\)</span>都是建立在已经遍历到的点的信息上而建立的，换句话说，随着后面新的点<spanclass="math inline">\(i\)</span>加入，它的决策区间有可能会完全包含某一个点<spanclass="math inline">\(P\)</span>的决策区间。这一点很好理解：原本<spanclass="math inline">\(l_i,r_i\)</span>就是由<spanclass="math inline">\(i\)</span>更新的，但是因为我们还没有遍历到<spanclass="math inline">\(i\)</span>,所以这段区间就会先被其它点占据。所以我们在求<spanclass="math inline">\(l_i\)</span>之前，要先将队尾那些完全不会比<spanclass="math inline">\(i\)</span>优的点踢出。具体如何判断？我们只要看一下在<spanclass="math inline">\(l_p\)</span>处<spanclass="math inline">\(i\)</span>是否比<spanclass="math inline">\(P\)</span>更优即可。如果是，显然<spanclass="math inline">\(P\)</span>就再也没有机会比<spanclass="math inline">\(i\)</span>更优了，因为<spanclass="math inline">\(p&lt;i\)</span>。</p><p>该操作之后<span class="math inline">\(i\)</span>就不能将队尾的<spanclass="math inline">\(P\)</span>的区间完全覆盖了，我们就可以利用单调性二分一下两者的决策区间的边界，作为<spanclass="math inline">\(l_i\)</span>.至于<spanclass="math inline">\(r_i\)</span>,我们直接设成<spanclass="math inline">\(n\)</span>即可。毕竟此时后面的点还没加入，我们只能用<spanclass="math inline">\(i\)</span>来更新它们。</p></li></ul><p>贴个模板</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs stata">void Optimize()<br>&#123;<br>    <span class="hljs-comment">//该模板适用于最小化问题，若求最大化，自行将对应不等号取反即可</span><br>    <span class="hljs-comment">//cal()</span><br>    hd=1,tl=0;<br>    <span class="hljs-keyword">que</span>[++tl]=0;<span class="hljs-keyword">ls</span>[0]=1,rs[0]=<span class="hljs-keyword">n</span>;<br>    <span class="hljs-keyword">for</span>(int i=1;i&lt;=<span class="hljs-keyword">n</span>;++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;rs[<span class="hljs-keyword">que</span>[hd]]&lt;i) hd++;<span class="hljs-comment">//弹出无用点</span><br>        dp[i]=cal(<span class="hljs-keyword">que</span>[hd],i);<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;cal(i,<span class="hljs-keyword">ls</span>[<span class="hljs-keyword">que</span>[tl]])&lt;=cal(<span class="hljs-keyword">que</span>[tl],<span class="hljs-keyword">ls</span>[<span class="hljs-keyword">que</span>[tl]])) tl--;<span class="hljs-comment">//弹出无用点，若要求最大这里要改方向</span><br>        ll <span class="hljs-keyword">l</span>=<span class="hljs-keyword">ls</span>[<span class="hljs-keyword">que</span>[tl]],r=<span class="hljs-keyword">n</span>+1;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">l</span>&lt;=r)<br>        &#123;<br>            ll mid=(<span class="hljs-keyword">l</span>+r)&gt;&gt;1;<br>            <span class="hljs-keyword">if</span>(cal(i,mid)&lt;=cal(<span class="hljs-keyword">que</span>[tl],mid)) r=mid-1;<span class="hljs-comment">//若要求最大这里要改方向</span><br>            <span class="hljs-comment">//二分查找i与que[tl]的转移分界点，也就是最小的满足i优于que[tl]的点</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">l</span>=mid+1;<br>        &#125;<br>        p_ans=r+1;<br>        <span class="hljs-keyword">if</span>(p_ans&gt;<span class="hljs-keyword">n</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//i并没有用</span><br>        rs[<span class="hljs-keyword">que</span>[tl]]=p_ans-1;<br>        <span class="hljs-keyword">que</span>[++tl]=i;<span class="hljs-comment">//插入队列</span><br>        <span class="hljs-keyword">ls</span>[i]=p_ans,rs[i]=<span class="hljs-keyword">n</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Tips:二分决策区间边界的时候，右界设置为n+1,因为i有可能完全不如P优，要防一手</p></blockquote><p>如果<span class="math inline">\(w(j,i)\)</span>我们能够以<spanclass="math inline">\(O(1)\)</span>的复杂度求出的话，该方法的时间复杂度式<spanclass="math inline">\(O(nlog)\)</span>的</p><p>例题：</p><p><a href="https://www.luogu.com.cn/problem/P1912">NOI 2009诗人小G</a></p><p>dp式并不难列出，关于其决策单调性我们已经在上一块里证明过了，所以这里直接用二分队列即可</p><p>数据范围有点大，记得开long double</p><p>code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ld long double</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IL inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">100010</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">998244353</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> X=<span class="hljs-number">0</span>; <span class="hljs-type">bool</span> flag=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">0</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="hljs-number">1</span>)+(X&lt;&lt;<span class="hljs-number">3</span>)+ch-<span class="hljs-string">&#x27;0&#x27;</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> X;<br>    <span class="hljs-keyword">return</span> ~(X<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-type">int</span> n,L,P;<br><span class="hljs-type">char</span> s[N][<span class="hljs-number">50</span>];<br>ld mas[N];<br><span class="hljs-type">int</span> ls[N],rs[N],pre[N];<span class="hljs-comment">//记录最优决策点</span><br><span class="hljs-type">int</span> que[N];<br><span class="hljs-type">int</span> hd,tl,p_ans;<br>ld dp[N];<br><span class="hljs-function">ld <span class="hljs-title">ksm</span><span class="hljs-params">(ld x,ll y)</span></span><br><span class="hljs-function"></span>&#123;<br>    ld ans=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(y)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) ans=ans*x;<br>        x=x*x;<br>        y&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function">ld <span class="hljs-title">cal</span><span class="hljs-params">(ll k,ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> dp[k]+<span class="hljs-built_in">ksm</span>(<span class="hljs-built_in">abs</span>(mas[x]-mas[k]<span class="hljs-number">-1</span>-L),P);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    n=<span class="hljs-built_in">read</span>();L=<span class="hljs-built_in">read</span>();P=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s[i]);<br>    <span class="hljs-comment">// for(int i=1;i&lt;=n;++i) cin&gt;&gt;s[i];</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        mas[i]=mas[i<span class="hljs-number">-1</span>]+<span class="hljs-built_in">strlen</span>(s[i])+<span class="hljs-number">1</span>;<br>    &#125;<br>    hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>    que[++tl]=<span class="hljs-number">0</span>;ls[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>,rs[<span class="hljs-number">0</span>]=n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;rs[que[hd]]&lt;i) hd++;<br>        dp[i]=<span class="hljs-built_in">cal</span>(que[hd],i);<br>        pre[i]=que[hd];<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">cal</span>(i,ls[que[tl]])&lt;=<span class="hljs-built_in">cal</span>(que[tl],ls[que[tl]])) tl--;<br>        ll l=ls[que[tl]],r=n+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;=r)<br>        &#123;<br>            ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cal</span>(i,mid)&lt;=<span class="hljs-built_in">cal</span>(que[tl],mid)) r=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-comment">//二分查找i与que[tl]的转移分界点，也就是最小的满足i优于que[tl]的点</span><br>            <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        p_ans=r+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(p_ans&gt;n) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//i并没有用</span><br>        rs[que[tl]]=p_ans<span class="hljs-number">-1</span>;<br>        que[++tl]=i;<span class="hljs-comment">//插入队列</span><br>        ls[i]=p_ans,rs[i]=n;<br>    &#125;<br>    <span class="hljs-comment">///////</span><br><br>    <span class="hljs-keyword">if</span>(dp[n]&gt;inf)<br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Too hard to arrange&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(ll)dp[n]);<br>        vector&lt;string&gt; ans;<br>        ll pos=n;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>        &#123;<br>            ll x=pre[pos]+<span class="hljs-number">1</span>;<br>            string ss=<span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;pos;++i) ss+=s[i],ss+=<span class="hljs-string">&quot; &quot;</span>;<br>            ss+=s[pos];<br>            ans.<span class="hljs-built_in">push_back</span>(ss);<br>            pos=pre[pos];<br>            <span class="hljs-keyword">if</span>(pos==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:ans) cout&lt;&lt;i&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;--------------------&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);</span><br>    ll t;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--)<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二分栈">二分栈</h4><p>一般用于最优决策点是不增的情况。在原本的二分队列的做法中，我们从队列的首部取出最优决策点，从队列的尾部放入决策点。那么如果决策点是不增的，意味着我们需要从队列的尾部取最优决策点。这样取和放的操作都是在队列的尾部，我们只要用一个栈来实现就好了。同样的，相邻的两个决策点更新的区间会有一个边界，我们不妨记为<spanclass="math inline">\(k_{l,r}\)</span>,当尝试加入<spanclass="math inline">\(i\)</span>的时候，记队列倒数第一个元素为<spanclass="math inline">\(p_1\)</span>,倒数第二个元素为<spanclass="math inline">\(p_2\)</span>,那么如果<spanclass="math inline">\(k_{p_1,p_2}\leq k_{p_2,i}\)</span>,那么<spanclass="math inline">\(p_2\)</span>就可以踢掉了，因为它不管在什么时候都不会是<spanclass="math inline">\(i,p_1,p_2\)</span>中的最优解。然后将<spanclass="math inline">\(i\)</span>加入队列之后再按照<spanclass="math inline">\(k_{p_1,p_2}\)</span>是否<spanclass="math inline">\(\leq i\)</span>来踢即可</p><p><a href="https://www.luogu.com.cn/problem/P5504">JSOI2001柠檬</a></p><p>思路：</p><p>首先不难发现最优选择下每一段的首尾的颜色就是这段的<spanclass="math inline">\(s_0\)</span>，否则我们就可以将首尾的没用的点分出去自称一段，贡献一定更优</p><p>所以我们可以按照不同的颜色来分开处理</p><p><span class="math inline">\(dp_i=max_{col_j=col_i,j\leqi}\{dp_{j-1}+w(j,i)\}\)</span>,其中<spanclass="math inline">\(w(j,i)=(sum_i-sum_j+1)^2\)</span></p><p>这里我们画图就能发现决策点是单调不增的（按照上文与图形结合的方法），所以可以使用二分栈。但是这题的决策单调性是在相同颜色的点之间才存在的，所以我们要分开来做二分栈</p><p>然后每一个点不会从0转移，所以一开始也不用把0放进去</p><p>code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> il inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bc(idx) vt[idx].size()-1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bd(idx) vt[idx].size()-2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> g(a,b) vt[a][b]</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">200000</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br>ll n;<br>ll mas[N];<br>vector&lt;ll&gt; vt[N];<br>ll dp[N];<br>ll ls[N],rs[N];<br>map&lt;ll,ll&gt; mp;<br>ll sum[N];<br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll k,ll num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> dp[k<span class="hljs-number">-1</span>]+mas[k]*num*num;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">gtf</span><span class="hljs-params">(ll a,ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll l=<span class="hljs-number">1</span>,r=n;<br>    <span class="hljs-keyword">while</span>(l&lt;=r)<br>    &#123;<br>        ll mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(a,mid-sum[a]+<span class="hljs-number">1</span>)&gt;=<span class="hljs-built_in">gt</span>(b,mid-sum[b]+<span class="hljs-number">1</span>)) r=mid<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;mas[i];<br>        mp[mas[i]]++;<br>        sum[i]=mp[mas[i]];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        ll idx=mas[i];<br>        <span class="hljs-keyword">while</span>(vt[idx].<span class="hljs-built_in">size</span>()&gt;=<span class="hljs-number">2</span>&amp;&amp; <span class="hljs-built_in">gtf</span>(<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bd</span>(idx)),<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bc</span>(idx)))&lt;=<span class="hljs-built_in">gtf</span>(<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bc</span>(idx)),i)) vt[idx].<span class="hljs-built_in">pop_back</span>();<br>        vt[idx].<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">while</span>(vt[idx].<span class="hljs-built_in">size</span>()&gt;=<span class="hljs-number">2</span>&amp;&amp; <span class="hljs-built_in">gtf</span>(<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bd</span>(idx)),<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bc</span>(idx)))&lt;=sum[i]) vt[idx].<span class="hljs-built_in">pop_back</span>();<br>        dp[i]=<span class="hljs-built_in">gt</span>(<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bc</span>(idx)),sum[i]-sum[<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bc</span>(idx))]+<span class="hljs-number">1</span>);<br>    &#125;<br>    cout&lt;&lt;dp[n]&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="分治">分治</h4><p>分治的方法主要用于同一层之间的点相互之间线性无关的情况。</p><p>比如<span class="math inline">\(F_1\)</span> <spanclass="math inline">\(:dp_{i,j}=min\{dp_{i-1,k}+w(k,i)\}\)</span>.<spanclass="math inline">\(F_2\)</span> <spanclass="math inline">\(:dp_i=min\{a_k+w(k,i)\}\)</span></p><p>可以看到同一层之间的点不会相互转移</p><p>那么如果同一层的点满足决策单调性的话，也就是意味着决策点是单调的，我们就可以采用分治的策略来优化转移的过程</p><p>假设当前需要转移的区间是<spanclass="math inline">\([L,R]\)</span>,决策点的选择区间是<spanclass="math inline">\([p_l,p_r]\)</span>(显然一开始转移区间和决策点的选择区间都为<spanclass="math inline">\([1,n]\)</span>)，设<spanclass="math inline">\(mid=\frac{L+R}{2}\)</span>,我们可以先暴力求出<spanclass="math inline">\(mid\)</span>的最优决策点<spanclass="math inline">\(pos\)</span>,那么<spanclass="math inline">\([L,mid-1]\)</span>的决策点选择区间就是<spanclass="math inline">\([p_l,pos]\)</span>,<spanclass="math inline">\([mid+1,R]\)</span>的决策点选择区间就是<spanclass="math inline">\([pos,p_r]\)</span>，那么这样分治下去就好了。</p><p>如果我们可以<spanclass="math inline">\(O(1)\)</span>求代价的话，对<spanclass="math inline">\(mid\)</span>求<spanclass="math inline">\(pos\)</span>的时间复杂度就只有<spanclass="math inline">\(O(n)\)</span>,再加上每次要处理的区间长度会变成原本的一半，所以处理区间为n的复杂度是<spanclass="math inline">\(f(n)=O(n)+O(f(n/2))\)</span>,总复杂度是<spanclass="math inline">\(O(nlogn)\)</span></p><p>一个板子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solve</span><span class="hljs-params">(ll l,ll r,ll pl,ll pr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//当前分治处理区间是[l,r],最佳决策区间是[pl,pr]</span><br>ll mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>ll pos;<span class="hljs-comment">//mid的最佳决策点</span><br>dp[mid]=<span class="hljs-built_in">gt</span>(pos=pl,mid);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pl+<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">min</span>(mid<span class="hljs-number">-1</span>,pr);++i)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(i,mid)&lt;dp[mid]) dp[mid]=<span class="hljs-built_in">gt</span>(pos=i,mid);<br>&#125;<br><span class="hljs-keyword">if</span>(l&lt;mid) <span class="hljs-built_in">Solve</span>(l,mid<span class="hljs-number">-1</span>,pl,pos);<br><span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">Solve</span>(mid+<span class="hljs-number">1</span>,r,pos,pr);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P5503">JSOI2016灯塔</a></p><p>大意：</p><p>给定<span class="math inline">\(h_i\)</span>，对于每一个<spanclass="math inline">\(i\)</span>,要求<span class="math inline">\(\forallj,p_i\geq h_j-h_i+\sqrt{|i-j|}\)</span>,求最小的<spanclass="math inline">\(p_i\)</span></p><p>思路：</p><p>不妨先将绝对值去掉，那么<spanclass="math inline">\(p_i=\left\{\begin{matrix}min\{h_j+\sqrt{i-j}-h_i\} &amp; j&lt;i\\ min\{h_j+\sqrt{j-i}-h_i\} &amp;j&gt;i \end{matrix}\right.\)</span></p><p>那么我们只要处理第一个式子就好了，第二个式子只要把整个数组反一下即可</p><p>可以发现<spanclass="math inline">\(p_i=min\{h_j+\sqrt{i-j}-h_i\}\)</span>满足决策单调性，并且<spanclass="math inline">\(p_i\)</span>之间相互无关，所以直接分治就解决了</p><p>code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IL inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">5e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> ep=<span class="hljs-number">1e-9</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">998244353</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br>ll n;<br>ll mas[N];<br><span class="hljs-type">double</span> dp1[N],dp2[N];<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">gt</span><span class="hljs-params">(ll p,ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> mas[p]+<span class="hljs-built_in">sqrt</span>(x-p)-mas[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solve</span><span class="hljs-params">(ll l,ll r,ll pl,ll pr,<span class="hljs-type">double</span> *dp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// if(l&gt;r||pl&gt;pr) return;</span><br>    ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    ll pos=pl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pl;i&lt;=<span class="hljs-built_in">min</span>(mid,pr);++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(i,mid)-dp[mid]&gt;=-ep) dp[mid]=<span class="hljs-built_in">gt</span>(pos=i,mid);<span class="hljs-comment">//要取&gt;=0</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(l&lt;mid) <span class="hljs-built_in">Solve</span>(l,mid<span class="hljs-number">-1</span>,pl,pos,dp);<br>    <span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">Solve</span>(mid+<span class="hljs-number">1</span>,r,pos,pr,dp);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;mas[i];<br>    <span class="hljs-built_in">Solve</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,n,dp1);<br>    <span class="hljs-built_in">reverse</span>(mas+<span class="hljs-number">1</span>,mas+<span class="hljs-number">1</span>+n);<br>    <span class="hljs-built_in">Solve</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,n,dp2);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-type">double</span> x=<span class="hljs-built_in">fmax</span>(dp1[i],dp2[n-i+<span class="hljs-number">1</span>]);<br>        cout&lt;&lt;(ll)<span class="hljs-built_in">ceil</span>(x)&lt;&lt;endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// ll t;t=read();while(t--)</span><br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P4072">SDOI2016征途</a></p><p><a href="https://www.luogu.com.cn/problem/CF321E">CF321 E</a></p><h5 id="类莫队做法">类莫队做法</h5><p>注意到分治要保证时间复杂度的前提是每次求<spanclass="math inline">\(w\)</span>代价的复杂度是<spanclass="math inline">\(O(1)\)</span>的</p><p>但是有一类<spanclass="math inline">\(w\)</span>比较特殊：关于区间的信息的记录，比如区间数字种类数等。这种问题我们一般可以离线下来用莫队处理，那么仿照莫队用左右端点的连续移动就可以做到<spanclass="math inline">\(O(1)\)</span>转移了，因为我们的决策点的选择范围也刚好是一个连续的区间，所以这样的话复杂度是正确的</p><p><a href="https://www.luogu.com.cn/problem/CF868F">CF868 F</a></p><p><a href="https://www.luogu.com.cn/problem/P5574">CmdOI2019任务分配问题</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IL inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">3e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> ep=<span class="hljs-number">1e-9</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">998244353</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tree</span><br>&#123;<br>    ll tr[N];<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> low(x) x&amp;(-x)</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(x&lt;N)<br>        &#123;<br>            tr[x]+=y;<br>            x+=<span class="hljs-built_in">low</span>(x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">sum</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ll ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x)<br>        &#123;<br>            ans+=tr[x];<br>            x-=<span class="hljs-built_in">low</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;T;<br>ll n,k;<br>ll mas[N];<br>ll dp[N],pp[N];<br><span class="hljs-keyword">namespace</span> Mo<br>&#123;<br>    <span class="hljs-type">int</span> L=<span class="hljs-number">1</span>,R=<span class="hljs-number">0</span>;<br>    ll ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> col[N];<br>    ll cnt[N];<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add1</span><span class="hljs-params">(ll pos,ll op)</span><span class="hljs-comment">//区间左边</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)<br>        &#123;<br>            ans+=T.<span class="hljs-built_in">sum</span>(n+<span class="hljs-number">1</span>)-T.<span class="hljs-built_in">sum</span>(col[pos]);<br>            T.<span class="hljs-built_in">add</span>(col[pos],<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ans-=T.<span class="hljs-built_in">sum</span>(n+<span class="hljs-number">1</span>)-T.<span class="hljs-built_in">sum</span>(col[pos]);<br>            T.<span class="hljs-built_in">add</span>(col[pos],<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add2</span><span class="hljs-params">(ll pos,ll op)</span><span class="hljs-comment">//区间右边</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)<br>        &#123;<br>            ans+=T.<span class="hljs-built_in">sum</span>(col[pos]<span class="hljs-number">-1</span>);<br>            T.<span class="hljs-built_in">add</span>(col[pos],<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ans-=T.<span class="hljs-built_in">sum</span>(col[pos]<span class="hljs-number">-1</span>);<br>            T.<span class="hljs-built_in">add</span>(col[pos],<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll l,ll r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        l++;<br>        <span class="hljs-keyword">while</span>(L&lt;l) <span class="hljs-built_in">add1</span>(L++,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span>(L&gt;l) <span class="hljs-built_in">add1</span>(--L,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span>(R&gt;r) <span class="hljs-built_in">add2</span>(R--,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span>(R&lt;r) <span class="hljs-built_in">add2</span>(++R,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> pp[l<span class="hljs-number">-1</span>]+ans;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solve</span><span class="hljs-params">(ll l,ll r,ll pl,ll pr)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    ll pos;<br>    dp[mid]=Mo::<span class="hljs-built_in">gt</span>(pos=pl,mid);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pl+<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">min</span>(mid<span class="hljs-number">-1</span>,pr);++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(dp[mid]&gt;Mo::<span class="hljs-built_in">gt</span>(i,mid)) dp[mid]=Mo::<span class="hljs-built_in">gt</span>(pos=i,mid);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(l&lt;mid) <span class="hljs-built_in">Solve</span>(l,mid<span class="hljs-number">-1</span>,pl,pos);<br>    <span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">Solve</span>(mid+<span class="hljs-number">1</span>,r,pos,pr);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;Mo::col[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) pp[i]=Mo::<span class="hljs-built_in">gt</span>(<span class="hljs-number">0</span>,i);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;k;++i)<br>    &#123;<br>        <span class="hljs-built_in">Solve</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">0</span>,n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) pp[j]=dp[j];<br>    &#125;<br>    cout&lt;&lt;pp[n]&lt;&lt;endl;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// ll t;t=read();while(t--)</span><br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="smawk">SMAWK</h4><p>SMAWK的用途跟分治一样，用于处理同一层之间没有转移关系的情况，但是复杂度会更优，可以达到<spanclass="math inline">\(O(n)\)</span></p><p>我们考虑从另一个角度来理解决策单调性</p><blockquote><p><strong>定义1</strong>若矩阵A满足∀i,j∈[0,k],pos(i)&lt;pos(j)则称A为单调矩阵。若A的任意子矩阵均为单调矩阵，则称A为完全单调矩阵</p></blockquote><p>重新定义四边形不等式</p><blockquote><p>定义2 对于n*m的矩阵A，若<span class="math inline">\(\forall1&lt;i_1&lt;i_2\leq n,1\leq j_1,\leq j_2\leq m\)</span>,均有<spanclass="math inline">\(A_{i_1,j_1}+A_{i_2,j_2}\leqA_{i_1,j_2}+A_{i_2,j_1}\)</span>,则称A满足四边形不等式</p></blockquote><p>快速判断矩阵是否满足四边形不等式：</p><blockquote><p>定理1 对于n*m的矩阵A，若<span class="math inline">\(\forall1&lt;i&lt;n,1\leq j&lt;m\)</span>,均有<spanclass="math inline">\(A_{i,j}+A_{i+1,j+1}\leqA_{i,j+1}+A_{i+1,j}\)</span>,则称A满足四边形不等式</p></blockquote><blockquote><p>定理2 若矩阵A满足四边形不等式，则A以及<spanclass="math inline">\(A^{T}\)</span>是完全单调矩阵</p></blockquote><p>接下来考虑<spanclass="math inline">\(dp_i=min_{j&lt;i}\{a_j+w(j,i)\}\)</span>,放到矩阵上，当<spanclass="math inline">\(j&lt;i\)</span>时，<spanclass="math inline">\(A_{i,j}=dp_j+w(j,i),j\geq i\)</span>时，令<spanclass="math inline">\(A_{i,j}=inf\)</span>，那么求<spanclass="math inline">\(dp_i\)</span>其实就是在第i行找最小值对应的列j.如果矩阵是一个单调矩阵，也就是dp满足决策单调性，我们就可以采用SMAWK</p><p>SMAWK的核心内容是reduce的过程，当列数m远大于n的时候，我们的枚举量会多很多，但是其实一行只会对应一个最优列，所以大量列是多余的，reduce过程就是在去除这些冗余列</p><p>当然，为了保证一行只有一个答案，我们要限定取每一行最左边/最右边的最小值<strong>（这一点在与WQS二分结合的时候很重要）</strong></p><p>其步骤如下：</p><ul><li><p>1初始定义 <em>k</em> = 1；</p></li><li><p>2当 <em>n</em> <em>≥</em> <em>m</em> 时结束过程；否则比较 <spanclass="math inline">\(A_{k,k}\)</span> 和 <spanclass="math inline">\(A_{k,k+1}\)</span></p></li><li><p>3若 <span class="math inline">\(A_{k,k}\geqA_{k,k+1}\)</span>，删除第 <em>k</em> 列，<em>k</em> <em>←</em>max(<em>k</em> <em>−</em> 1<em>,</em> 1)，回到步骤 2；</p></li><li><p>4若 <span class="math inline">\(A_{k,k}&lt; A_{k,k+1}\)</span> 且<em>k</em> = <em>n</em>，删除第 <em>n</em> + 1 列，回到步骤 2；</p></li><li><p>5若 <span class="math inline">\(A_{k,k}&lt; A_{k,k+1}\)</span> 且<em>k</em> = <em>n</em>，<em>k</em> <em>←</em> <em>k</em> + 1，回到步骤2。</p></li></ul><p>每一步的原因还是很显然的，这里不多赘述了。复杂度是<spanclass="math inline">\(O(m+n)\)</span></p><p>为了保证线性复杂度的正确性，可以用链表实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    ll val,opt;<br>    Node *lst,*nxt;<br>    <span class="hljs-built_in">Node</span>()&#123;val=opt=<span class="hljs-number">0</span>;lst=nxt=<span class="hljs-literal">NULL</span>;&#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">List</span><br>&#123;<br>    ll len;<span class="hljs-comment">//列表长度</span><br>    Node *s,*e;<br>    <span class="hljs-built_in">List</span>()<br>    &#123;<br>        len=<span class="hljs-number">0</span>;<br>        s=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();s-&gt;opt=<span class="hljs-number">1</span>;<br>        e=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();e-&gt;opt=<span class="hljs-number">-1</span>;<br>        s-&gt;nxt=e;e-&gt;lst=s;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//将x加入尾部</span><br>        Node *n=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        n-&gt;val=x;<br>        Node *a=e-&gt;lst;<span class="hljs-comment">//尾部元素</span><br>        a-&gt;nxt=n;n-&gt;lst=a;<br>        n-&gt;nxt=e;e-&gt;lst=n;<br>        len++;<span class="hljs-comment">//长度</span><br>    &#125;<br>    <span class="hljs-built_in">List</span>(<span class="hljs-type">const</span> List &amp;a)<br>    &#123;<br>        <span class="hljs-comment">//Copy</span><br>        len=<span class="hljs-number">0</span>;<br>        s=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();s-&gt;opt=<span class="hljs-number">1</span>;<br>        e=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();e-&gt;opt=<span class="hljs-number">-1</span>;<br>        s-&gt;nxt=e;e-&gt;lst=s;<br>        Node *n=a.s-&gt;nxt;<br>        <span class="hljs-keyword">while</span>(n-&gt;opt!=<span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-built_in">append</span>(n-&gt;val);<br>            n=n-&gt;nxt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">Node* <span class="hljs-title">del</span><span class="hljs-params">(Node *n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        --len;<br>        Node *a=n-&gt;lst,*b=n-&gt;nxt;<br>        a-&gt;nxt=b,b-&gt;lst=a;<br>        <span class="hljs-built_in">delete</span>(n);<br>        <span class="hljs-keyword">return</span> a;<span class="hljs-comment">//前一个节点</span><br>    &#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">submat</span><br>&#123;<br>    List r,c;<br>    <span class="hljs-comment">//row,column</span><br>&#125;A;<br><span class="hljs-function">submat <span class="hljs-title">Reduce</span><span class="hljs-params">(<span class="hljs-type">const</span> submat &amp;A)</span></span><br><span class="hljs-function"></span>&#123;<br>    submat B;<br>    B.r=(List)A.r;B.c=(List)A.c;<br>    <span class="hljs-type">int</span> n=A.r.len;<span class="hljs-comment">//行数</span><br>    <span class="hljs-type">int</span> m=A.c.len;<span class="hljs-comment">//列数</span><br>    Node *nr=B.r.s-&gt;nxt;<span class="hljs-comment">//第一个节点</span><br>    Node *nc=B.c.s-&gt;nxt;<br>    ll k=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(n&lt;m)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(nr-&gt;val,nc-&gt;val)&gt;<span class="hljs-built_in">get</span>(nr-&gt;val,nc-&gt;nxt-&gt;val))<br>        &#123;<br>            nc=B.c.<span class="hljs-built_in">del</span>(nc);<br>            m--;<br>            <span class="hljs-keyword">if</span>(k&gt;<span class="hljs-number">1</span>)<br>            &#123;<br>                --k;<br>                nr=nr-&gt;lst;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">//k=1</span><br>                nr=B.r.s-&gt;nxt;nc=B.c.s-&gt;nxt;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k==n)<br>        &#123;<br>            B.c.<span class="hljs-built_in">del</span>(nc-&gt;nxt);m--;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            k++;<br>            nr=nr-&gt;nxt;nc=nc-&gt;nxt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> B;<br>&#125;<br></code></pre></td></tr></table></figure><p>reduce之后我们就真正开始SMAWK了</p><p>SMAWK(A) 表示计算 <em>n</em> <em>×</em> <em>m</em> 的完全单调矩阵<em>A</em> 的<strong>每行最小值</strong>所在</p><p>列。步骤如下：</p><ul><li>1若 min(<em>n,</em> <em>m</em>) = 1 直接计算答案；</li><li>2对Areduce，得到矩阵B,并且我们取其所有偶数行组成一个新矩阵C</li><li>4递归SMAWK(C),得到C的每一行的最小值所在位置</li><li>4对于B中的奇数行，其答案在相邻两行的答案之间，那么之间暴力遍历一下即可。该步骤的复杂度为<spanclass="math inline">\(O(m)\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SMAWK</span><span class="hljs-params">(submat A)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n=A.r.len;<span class="hljs-comment">//行数</span><br>    <span class="hljs-type">int</span> m=A.c.len;<span class="hljs-comment">//列数</span><br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>    &#123;<br>        ll x=A.r.s-&gt;nxt-&gt;val;<span class="hljs-comment">//只有一行</span><br>        Node *nc=A.c.s-&gt;nxt;<br>        ll maxn=<span class="hljs-number">0</span>;<br>        ll maxp=<span class="hljs-number">0</span>;<span class="hljs-comment">//最值位置</span><br>        <span class="hljs-keyword">while</span>(nc-&gt;opt!=<span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(x,nc-&gt;val)&gt;=maxn)<br>            &#123;<br>                maxp=nc-&gt;val,maxn=<span class="hljs-built_in">get</span>(x,nc-&gt;val);<br>            &#125;<br>            nc=nc-&gt;nxt;<br>        &#125;<br>        ans[x]=maxp;<span class="hljs-comment">//存储最大值所在位置</span><br>        <span class="hljs-comment">///</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(m==<span class="hljs-number">1</span>)<br>    &#123;<br>        ll y=A.c.s-&gt;nxt-&gt;val;<br>        Node *nr=A.r.s-&gt;nxt;<span class="hljs-comment">//第一行</span><br>        <span class="hljs-keyword">while</span>(nr-&gt;opt!=<span class="hljs-number">-1</span>)<br>        &#123;<br>            ans[nr-&gt;val]=y;<br>            nr=nr-&gt;nxt;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    submat B=<span class="hljs-built_in">Reduce</span>(A);<br>    submat C;C.c=<span class="hljs-built_in">List</span>(B.c);<span class="hljs-comment">//首先保存每一列的信息</span><br>    Node *nr=B.r.s-&gt;nxt;<span class="hljs-comment">//行第一个元素</span><br>    <span class="hljs-type">bool</span> fl=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(nr-&gt;opt!=<span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(fl) C.r.<span class="hljs-built_in">append</span>(nr-&gt;val);<span class="hljs-comment">//C保存偶数行</span><br>        nr=nr-&gt;nxt;<br>        fl^=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//得到一个只有偶数行，列不变的矩阵</span><br>    <span class="hljs-built_in">SMAWK</span>(C);<span class="hljs-comment">//递归</span><br>    nr=B.r.s-&gt;nxt;fl=<span class="hljs-number">0</span>;<br>    Node *nc=B.c.s-&gt;nxt;<span class="hljs-comment">//列指针</span><br>    <span class="hljs-keyword">while</span>(nr-&gt;opt!=<span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!fl)<br>        &#123;<br>            ll z=ans[nr-&gt;nxt-&gt;val];<span class="hljs-comment">//已经处理过了，这里是有值的</span><br>            ll x=nr-&gt;val;<br>            ll maxn=<span class="hljs-number">0</span>,maxp=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(z==<span class="hljs-number">0</span>) z=inf;<br>            <span class="hljs-keyword">while</span>(nc-&gt;opt!=<span class="hljs-number">-1</span> &amp;&amp; nc-&gt;val&lt;=z)<br>            &#123;<br>                <span class="hljs-comment">//枚举列</span><br>                <span class="hljs-comment">//返回的是最右边的最小值</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(x,nc-&gt;val)&gt;=maxn)<br>                &#123;<br>                    maxn=<span class="hljs-built_in">get</span>(x,nc-&gt;val);<br>                    maxp=nc-&gt;val;<br>                &#125;<br>                nc=nc-&gt;nxt;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nc-&gt;lst-&gt;val==z) nc=nc-&gt;lst;<br>            ans[x]=maxp;<br>        &#125;<br>        nr=nr-&gt;nxt;<br>        fl^=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>理论上是可以平替分治的，但是写起来太烦了。。。</p><p>有一份短一点的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//求每行最左边最小值</span><br><span class="hljs-type">int</span> pre[N],suf[N],M[N],n,m,ans=<span class="hljs-number">1e18</span>,P=<span class="hljs-number">0</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;L,H;<br>map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;Mp[N];<br><span class="hljs-function">ll <span class="hljs-title">get</span><span class="hljs-params">(ll a,ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//返回第a行第b列的元素</span><br>&#125; <br><span class="hljs-type">int</span> pre[N],suf[N],M[N],P=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (pre[x]!=<span class="hljs-number">-1</span>)<br>        suf[pre[x]]=suf[x]; <span class="hljs-keyword">else</span> P=suf[x];<br>    pre[suf[x]]=pre[x];<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">reduce</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;X,vector&lt;<span class="hljs-type">int</span>&gt;Y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;Y.<span class="hljs-built_in">size</span>();i++) pre[i]=i<span class="hljs-number">-1</span>,suf[i]=i+<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,y=<span class="hljs-number">0</span>;<br>    P=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> nmsl=Y.<span class="hljs-built_in">size</span>()-X.<span class="hljs-built_in">size</span>();nmsl&gt;<span class="hljs-number">0</span>;nmsl--)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>(X[x],Y[y])&lt;<span class="hljs-built_in">get</span>(X[x],Y[suf[y]]))<br>        &#123;<br>            y=suf[y];<br>            <span class="hljs-built_in">del</span>(pre[y]);<br>            <span class="hljs-keyword">if</span> (x) y=pre[y],x--;<br>        &#125; <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (x==X.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>) <span class="hljs-built_in">del</span>(suf[y]);<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                y=suf[y];<br>                x++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt;ret;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=P;i!=Y.<span class="hljs-built_in">size</span>();i=suf[i])  ret.<span class="hljs-built_in">push_back</span>(Y[i]);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solve</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;X,vector&lt;<span class="hljs-type">int</span>&gt;Y)</span></span><br><span class="hljs-function"></span>&#123;<br>    Y=<span class="hljs-built_in">reduce</span>(X,Y);<br>    <span class="hljs-keyword">if</span> (X.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)<br>    &#123;<br>        M[X[<span class="hljs-number">0</span>]]=Y[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt;Z;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;X.<span class="hljs-built_in">size</span>();i++)<br>        <span class="hljs-keyword">if</span> (!(i%<span class="hljs-number">2</span>)) Z.<span class="hljs-built_in">push_back</span>(X[i]);<br>    <span class="hljs-built_in">Solve</span>(Z,Y);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;X.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!(i%<span class="hljs-number">2</span>)) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> l=<span class="hljs-built_in">lower_bound</span>(Y.<span class="hljs-built_in">begin</span>(),Y.<span class="hljs-built_in">end</span>(),M[X[i<span class="hljs-number">-1</span>]])-Y.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-type">int</span> r=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i==X.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>) r=Y.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            r=<span class="hljs-built_in">lower_bound</span>(Y.<span class="hljs-built_in">begin</span>(),Y.<span class="hljs-built_in">end</span>(),M[X[i+<span class="hljs-number">1</span>]])-Y.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>        M[X[i]]=Y[l];<br>        <span class="hljs-keyword">while</span> (l&lt;r)<br>        &#123;<br>            l++;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>(X[i],Y[l])&gt;<span class="hljs-built_in">get</span>(X[i],M[X[i]])) M[X[i]]=Y[l];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br>H.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++) L.<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-built_in">Solve</span>(H,L);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="wqs二分">WQS二分+</h4><p>可以与其它方法结合在一起，达到一个非常优秀的时间复杂度</p><p>关于WQS二分本身的内容这里就不多赘述了，可以去看其它文章理解一下，这里主要讲一下如何将其应用在决策单调性中</p><p>考虑一类问题：将一个序列强制分为k段，每一段<spanclass="math inline">\([l,r]\)</span>有一个价值<spanclass="math inline">\(w(l,r)\)</span>,问总价值最小的分段</p><p>假设将序列分为k段的最优价值为<spanclass="math inline">\(f_k\)</span>，<strong>如果</strong>所有的<spanclass="math inline">\((k,f_k)\)</span>组成一个凸函数，那么我们就可以使用WQS二分了。外层枚举斜率，内层就去掉了分段的限制，就可以使用二分队列/斜率优化/分治等措施了。</p><p>现在问题还是很多的，比如凸性的证明，WQS二分的边界问题，内部求最优值时更新的取等问题等。一个一个来</p><h5 id="wqs多解情况">WQS多解情况</h5><p>多解情况是指答案K与多个点在一条线段上，此时我们无法直接通过枚举斜率来做到只切到点K，所以我们需要在枚举的同时让得到的方案具有完全的偏序，来保证我们枚举斜率的时候，知道当前斜率对应的答案是哪一点的答案，是线段左端点的，还是右端点的，从而保证后面二分调整mid的时候不会弄混淆。很重要的一点是，我们需要的只是正确的斜率，不需要保证当前斜率做出来的最优点一定是K,因为<spanclass="math inline">\(f_k=mid*k+b\)</span>,其中斜率<spanclass="math inline">\(mid\)</span>和截距<spanclass="math inline">\(b\)</span>都是二分之后确定的值，在同一线段上的点做出的<spanclass="math inline">\(mid,b\)</span>都是一样的。</p><p>那么为了做到严格偏序，我们需要对每一个属性都定义大小</p><p><ahref="https://blog.csdn.net/Emm_Titan/article/details/124035796?spm=1001.2014.3001.5502">这篇博客</a>讲的很清晰，我可能讲的有点抽象，可以去再看看</p><p><img src="https://s2.loli.net/2023/12/19/3lAUxiLe4rvwNRa.png" alt="image-20230916171500911" style="zoom:100%;" /></p><h5id="满足四边形不等式的序列划分问题的答案凸性以及wqs二分的方案构造">满足四边形不等式的序列划分问题的答案凸性以及WQS二分的方案构造</h5><p>这里我们尝试证明满足四边形不等式的序列划分问题都具有凸性</p><blockquote><p>不妨先来看另一个问题：给定一张n个点的DAG，点<spanclass="math inline">\(i\)</span>与点<spanclass="math inline">\(j\)</span>当<spanclass="math inline">\(i&lt;j\)</span>时有权值<spanclass="math inline">\(w(i,j)\)</span>,问从1走到n的经过k条边的最短路</p></blockquote><p>简单转化一下，这个问题的dp方程就是我们熟悉的:<spanclass="math inline">\(dp_{i,j}=min\{dp_{k,j-1}+w(k,i)\}\)</span>,<spanclass="math inline">\(dp_{i,j}\)</span>表示走到i，经过j条边的最短路</p><p>设<span class="math inline">\(f_k\)</span>表示经过k条边的最短路</p><p>下面我们尝试证明：当权值矩阵w满足四边形不等式的时候，<spanclass="math inline">\(f_k\)</span>是一个下凸函数。换句话说，<spanclass="math inline">\(\forall k\in[2,n-2]\)</span>，<spanclass="math inline">\(f_{k+1}-f_k&gt;f_k-f_{k-1}\)</span></p><blockquote><p>引理：<em>∀</em>1 <em>≤</em> <em>s</em> <em>&lt;</em> <em>r</em><em>&lt;</em> <em>t</em> <em>≤</em> <em>n</em> <em>−</em> 1<em>,</em><em>f</em>(<em>s</em>) + <em>f</em>(<em>t</em>) <em>≥</em><em>f</em>(<em>r</em>) + <em>f</em>(<em>s</em> + <em>t</em> <em>−</em><em>r</em>)</p></blockquote><p>如果我们能够证明该引理的话，带入<spanclass="math inline">\(s=k-1,r=k,t=k+1\)</span>,则命题得证</p><p>下面尝试证明引理：</p><hr /><p>不妨记<span class="math inline">\(f_s\)</span>对应的最优方案是<spanclass="math inline">\(p_1,p_2...p_{s+1}\)</span>,<spanclass="math inline">\(f_t\)</span>对应的最优方案是<spanclass="math inline">\(q_1,q_2,..q_{t+1}\)</span></p><p>记<spanclass="math inline">\(v=r-s&gt;0\)</span>,如果我们能够找到<spanclass="math inline">\(i \in [1,s]\)</span>,满足<spanclass="math inline">\(p_i\leq q_{i+v}&lt;q_{i+v+1}\leq p_{i+1}(i+v+1\leqs+v+1\leq t)\)</span>,就能够构造路径<spanclass="math inline">\(R_1:\)</span><spanclass="math inline">\(p_1,...p_i,q_{i+v+1},q_{i+v+2},..q_{t+1}\)</span>,以及路径<spanclass="math inline">\(R_2:\)</span><spanclass="math inline">\(q_1,...q_{i+v},p_{i+1},p_{i+2},...p_{s+1}\)</span>(也就是把两段路径的后半段交换了一下，并且保证一定交换了一部分)</p><p>两段路径的<strong>长度</strong>分别是<spanclass="math inline">\(i-1+(t+1-i-v-1)+1=t-v=t-r+s\)</span>,以及<spanclass="math inline">\(i-1+v+(s+1-i-1)+1=s+v=r\)</span>,</p><p>那么由f的定义,<spanclass="math inline">\(R_1\)</span>的<strong>路径长度</strong><spanclass="math inline">\(len（R_1) \geq f_{t-r+s}\)</span>,<spanclass="math inline">\(R_2\)</span>的<strong>路径长度</strong><spanclass="math inline">\(len(R_2)\geq f_{r}\)</span>,</p><p>由四边形不等式<spanclass="math inline">\(w(p_i,q_{i+v+1})+w(q_{i+v},p_{i+1})\leqw(q_{i+v}+q_{i+v+1})+w(p_i,p_{i+1})\)</span></p><p>故<span class="math inline">\(f_s+f_t\geq len(R_1)+len(R_2)\geqf_{t-r+s}+f_r\)</span></p><p>第一个不等式是因为<spanclass="math inline">\(R_1,R_2\)</span>与原本路径的区别只有中间衔接的一段</p><p>由上，我们只要证明存在这样的一个<spanclass="math inline">\(i\)</span>即可。</p><figure><img src="https://s2.loli.net/2023/12/19/r69QhC8pR2SqgJM.png"alt="image-20230916142205317" /><figcaption aria-hidden="true">image-20230916142205317</figcaption></figure><p>不妨记路径P将<spanclass="math inline">\((1,n]\)</span>分成了s个部分，其中第i个部分是<spanclass="math inline">\((p_i,p_{i+1}]\)</span></p><p>我们记<span class="math inline">\(a_i\)</span>表示<spanclass="math inline">\(q_{i+v}\)</span>在哪一段，那么如果存在<spanclass="math inline">\(i\)</span>,<spanclass="math inline">\(a_i=a_i+1=k\)</span>,我们就找到答案为k了。</p><p>记<span class="math inline">\(b_i=a_i-i\)</span>,显然<spanclass="math inline">\(b_1\geq 0,b_{s+1}\leq -1\)</span>，后者是因为<spanclass="math inline">\(a_{s+1}-(s+1)\leqs-(s+1)=-1\)</span>,此外显然<spanclass="math inline">\(b_i-b_{i-1}=0\)</span>或<spanclass="math inline">\(-1\)</span>,故<spanclass="math inline">\(b_i-b_{i-1}\geq -1\)</span></p><p>由此序列b中一定存在一个-1,取最靠前的-1，记为<spanclass="math inline">\(b_{i+1}\)</span>.它前面一定是<spanclass="math inline">\(b_i=0\)</span>,故<spanclass="math inline">\(a_i=a_{i+1}\)</span></p><p>这样我们就找到了一个合法的<spanclass="math inline">\(i\)</span>,引理得证，故命题得证 Q.E.D</p><hr /><p>这段证明还是非常玄妙(玄幻)的。当然它对于我们的方案构造也有帮助</p><p>WQS二分中有时候会存在要求为k，但是<spanclass="math inline">\(k&gt;l,k&lt;r\)</span>且<spanclass="math inline">\(l,r,k\)</span>在一条线段上的情况，这时候我们一般通过限定边数尽可能多/少来保证取到线段的端点。但是想要构造方案的话就会不知所措了</p><p>我们记答案斜率为mid,这条包含答案k的线段的端点为<spanclass="math inline">\((l,f_l),(r,f_r)\)</span>,则<spanclass="math inline">\(\forall i\in[l,r],f_i=f_l+mid*(i-l)\)</span></p><p>我们可以先把<spanclass="math inline">\(l,r\)</span>对应的最优方案找出来，长度分别为<spanclass="math inline">\(l,r\)</span>,那么按照上述证明中的构造方式我们得到长度为<spanclass="math inline">\(k,l+r-k\)</span>的路径<spanclass="math inline">\(R_1,R_2\)</span>,记其<strong>路径长度</strong>分别为<spanclass="math inline">\(len(R_1)=a,len(R_2)=b\)</span>,有<spanclass="math inline">\(a\geq f_l+mid*(k-l),b\geqf_l+mid*(l+r-k-l)\)</span></p><p>且有<spanclass="math inline">\(2f_l+mid*(k-l)+mid*(l+r-k-l)=2f_l+mid*(r-l)\leqa+b\leq f_l+f_r=2f_l+mid*(r-l)\)</span></p><p>第二个不等号的原因见证明片段</p><p>发现<span class="math inline">\(a+b\)</span>被边界夹住了，故<spanclass="math inline">\(a= f_l+mid*(k-l)\)</span>,由此a就是<spanclass="math inline">\(f_{k}\)</span>,我们就得到了长度为k的构造方案</p><p>以上内容参考 <a href="https://www.osti.gov/biblio/10146169">论文</a>《The <em>d</em>-Edge Shortest-Path Problem for a MongeGrapll》，以及APIO2021《决策单调性与四边形不等式》</p><hr /><h5 id="wqs外层二分时的边界">WQS外层二分时的边界</h5><p>一般来说直接取<spanclass="math inline">\([-inf,inf]\)</span>即可，或者稍微算一下卡住边界</p><p>不管是这样的</p><p><img src="https://s2.loli.net/2023/12/19/knMY3pRujfh4ZiU.png" alt="image-20230916170032830" style="zoom:60%;" /></p><p>还是这样的</p><p><img src="https://s2.loli.net/2023/12/19/irx2etJHF1LEcWR.png" alt="image-20230916170003304" style="zoom:60%;" /></p><p>只要边界范围足够就不会有问题。但是有一类分段问题，图像长这样</p><p><img src="https://s2.loli.net/2023/12/19/QXIrSU7uc1BfaWv.png" alt="image-20230916170405876" style="zoom:70%;" /></p><p>分段为0的时候，总价值为0，然后开始分段之后价值随分段减少。不考虑0的话，后面的一段也是满足凸函数的，那么这个对我们的边界会有影响吗？个人感觉没有，因为我们只要保证wqs二分之后在做最优决策的时候保证不让段数为0即可</p><p>比如这题就是这个情况<ahref="https://www.luogu.com.cn/problem/CF321E">CF321 E</a>(在分治部分此题作为练习出现，当然它也可以WQS二分，毕竟它满足四边形不等式，而我们已经证明了该类问题的凸性)</p><p>那么到这里，理论部分就差不多完善了，我们就可以看看应用了</p><p>不妨就看看这题<a href="https://www.luogu.com.cn/problem/CF321E">CF321E</a></p><p>按照套路，我们外层枚举斜率，内层就是每一段的贡献要减去一个<spanclass="math inline">\(mid\)</span>,问最优分段数及其对应的总贡献。dp式满足决策单调性，可以直接上单调队列，复杂度是<spanclass="math inline">\(O(nlogn^2)\)</span>,外层<spanclass="math inline">\(O(log)\)</span>,内层<spanclass="math inline">\(O(nlog)\)</span>，可以看到比普通的<spanclass="math inline">\(O(n^2log)\)</span>分治要优化了不少</p><p>code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> il inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">4010</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br>ll n,m;<br>ll mp[N][N];<br>ll cnt[N];<br>ll sum[N][N];<br>ll dp[N];<br>ll que[N];<br>ll ls[N],rs[N];<br>ll ANS;<br><span class="hljs-function">ll <span class="hljs-title">cal</span><span class="hljs-params">(ll l,ll r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//l+1-&gt;r</span><br>    <span class="hljs-keyword">return</span> sum[r][r]-sum[l][r]-sum[r][l]+sum[l][l];<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll k,ll x,ll val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> dp[k]+<span class="hljs-built_in">cal</span>(k,x)-val;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>    que[++tl]=<span class="hljs-number">0</span>;ls[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>,rs[<span class="hljs-number">0</span>]=n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cnt[i]=<span class="hljs-number">0</span>,ls[i]=rs[i]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;rs[que[hd]]&lt;i) hd++;<br>        dp[i]=<span class="hljs-built_in">gt</span>(que[hd],i,x);<br>        cnt[i]=cnt[que[hd]]+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">gt</span>(i,ls[que[tl]],x)&lt;<span class="hljs-built_in">gt</span>(que[tl],ls[que[tl]],x)) tl--;<br>        ll L=ls[que[tl]],R=n+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(L&lt;=R)<br>        &#123;<br>            ll mid=(L+R)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(i,mid,x)&lt;=<span class="hljs-built_in">gt</span>(que[tl],mid,x)) R=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> L=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;que[tl]&lt;&lt;&#x27; &#x27;&lt;&lt;R+1&lt;&lt;&quot; &quot;&lt;&lt;gt(i,R+1,x)&lt;&lt;&quot; &quot;&lt;&lt;gt()</span><br>        ll p_ans=R+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(p_ans&gt;n) <span class="hljs-keyword">continue</span>;<br>        rs[que[tl]]=p_ans<span class="hljs-number">-1</span>;<br>        que[++tl]=i;<br>        ls[i]=p_ans,rs[i]=n;<br>    &#125;<br>    ANS=dp[n];<br><span class="hljs-comment">//     cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;cnt[n]&lt;&lt;&quot; &quot;&lt;&lt;ANS&lt;&lt;&quot; &quot;&lt;&lt;ANS+m*x&lt;&lt;endl;</span><br>    <span class="hljs-keyword">return</span> cnt[n]&gt;=m;<br>    <span class="hljs-comment">//尽可能分多段，尽可能选靠后的点转移</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)<br>        &#123;<br>            cin&gt;&gt;mp[i][j];<br>            <span class="hljs-keyword">if</span>(i&gt;j) mp[i][j]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)<br>        &#123;<br>            sum[i][j]=sum[i][j<span class="hljs-number">-1</span>]+sum[i<span class="hljs-number">-1</span>][j]+mp[i][j]-sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>        &#125;<br>    &#125;<br>    ll l=<span class="hljs-number">-1e18</span>,r=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;=r)<br>    &#123;<br>        ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(mid)) r=mid<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">judge</span>(r+<span class="hljs-number">1</span>);<br>    cout&lt;&lt;ANS+m*(r+<span class="hljs-number">1</span>)&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P6246">IOI2000 邮局加强版</a></p><p><a href="https://www.luogu.com.cn/problem/P4072">SDOI2016征途</a></p><p>套路都差不多，套一个WQS的事，内层看情况用不同的优化手段</p><p><a href="https://www.luogu.com.cn/problem/P5308">Akvizna</a></p><p>你面临 <em>n</em> 名参赛者的挑战，最终要将他们全部战胜。每一轮中，都会淘汰一些选手；你会得到这一轮奖金池中 被淘汰者 除以这一轮对手总数 比例的奖金。</p><p>例如某一轮有 10 个对手，淘汰了 3 个，那么你将获得奖金池中 3/10的奖金。</p><p>假设每一轮的奖金池均为一元，<code>Mirko</code> 希望通过恰好<em>k</em> 轮赢得比赛，那么他最多可能获得多少奖金呢？</p><p>你只需要输出答案保留 9 位小数即可。</p><p>这题略阴间，二分的时候不枚举小数的话过不了，肥肠卡精度，不过思维难度一般</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-12</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-type">const</span> ll N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">double</span> dp[N];<br><span class="hljs-type">double</span> ANS;<br><span class="hljs-type">double</span> inv[N];<br>ll cnt[N];<span class="hljs-comment">//分的段数</span><br>ll que[N];<br>ll ls[N],rs[N];<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">gt</span><span class="hljs-params">(ll k,ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> dp[k]+(<span class="hljs-type">double</span>)((x-k)*<span class="hljs-number">1.0</span>*inv[n-k]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>    que[++tl]=<span class="hljs-number">0</span>;ls[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>,rs[<span class="hljs-number">0</span>]=n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cnt[i]=<span class="hljs-number">0</span>,ls[i]=rs[i]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;rs[que[hd]]&lt;i) hd++;<br>        cnt[i]=cnt[que[hd]]+<span class="hljs-number">1</span>;<br>        dp[i]=<span class="hljs-built_in">gt</span>(que[hd],i)-x;<br>        <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;que[hd]&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i]&lt;&lt;endl;</span><br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">gt</span>(i,ls[que[tl]])&gt;=<span class="hljs-built_in">gt</span>(que[tl],ls[que[tl]])) tl--;<br>        ll L=ls[que[tl]],R=n+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(L&lt;=R)<br>        &#123;<br>            ll mid=(L+R)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(i,mid)&gt;=<span class="hljs-built_in">gt</span>(que[tl],mid)) R=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> L=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        ll p_ans=R+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(p_ans&gt;n) <span class="hljs-keyword">continue</span>;<br>        rs[que[tl]]=p_ans<span class="hljs-number">-1</span>;<br>        que[++tl]=i;<br>        ls[i]=p_ans,rs[i]=n;<br>    &#125;<br>    ANS=dp[n];<br>    <span class="hljs-comment">// cout&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;cnt[n]&lt;&lt;&#x27; &#x27;&lt;&lt;ANS&lt;&lt;&#x27; &#x27;&lt;&lt;ANS+m*x&lt;&lt;endl;</span><br>    <span class="hljs-keyword">return</span> cnt[n]&lt;=m;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) inv[i]=<span class="hljs-number">1.0</span>/(i*<span class="hljs-number">1.0</span>);<br>    <span class="hljs-comment">// for(int i=1;i&lt;=n;++i)</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     for(int j=1;j&lt;=min(i,m);++j)</span><br>    <span class="hljs-comment">//     &#123;</span><br>    <span class="hljs-comment">//         for(int k=j-1;k&lt;i;++k)</span><br>    <span class="hljs-comment">//         &#123;</span><br>    <span class="hljs-comment">//             dp[i][j]=max(dp[i][j],dp[k][j-1]+(double)((i-k)*1.0/(n-k)));</span><br>    <span class="hljs-comment">//         &#125;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// judge(0);</span><br>    <span class="hljs-comment">// for(double i=-2;i&lt;=2;i+=0.1) judge(i);</span><br>    <span class="hljs-type">double</span> l=<span class="hljs-number">-100</span>,r=<span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">while</span>(l+eps&lt;=r)<br>    &#123;<br>        <span class="hljs-type">double</span> mid=(l+r)/<span class="hljs-number">2.0</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(mid)) r=mid;<br>        <span class="hljs-keyword">else</span> l=mid;<br>    &#125;<br>    <span class="hljs-built_in">judge</span>(r);<br>    <span class="hljs-comment">// cout&lt;&lt;r+1&lt;&lt;endl;</span><br>    cout&lt;&lt;fixed&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">9</span>)&lt;&lt;ANS+m*<span class="hljs-number">1.0</span>*(r)&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="tips">Tips：</h5><p>做WQS二分一定要注意问题函数是一个上凸包还是下凸包</p><p>注意左右边界</p><p>有时候也是也是要二分小数的！</p><h4 id="斜率优化">斜率优化</h4><p>基本的斜率优化本人已经在<ahref="https://blog.csdn.net/sophilex/article/details/132634582?spm=1001.2014.3001.5502">另一篇博客</a>中讲的很详细了，从入门到精通应该都有了。</p><p>然后更多的应用大概就是与WQS二分结合了吧</p><p>注意点好像也没啥，毕竟WQS二分之后内部就是一个纯纯的一维dp</p><p><a href="https://www.luogu.com.cn/problem/P4072">SDOI2016征途</a></p><p><a href="https://www.luogu.com.cn/problem/P5308">Akvizna</a></p><p>值得一提的还有这道题<ahref="https://www.luogu.com.cn/problem/P5504">JSOI2001 柠檬</a></p><p>之前在二分栈里提过它，但其实它也可以用斜率优化做，但是因为斜率实际上是递减的，所以内部维护凸包的时候是用一个栈（因为最优点在最后了，放入点也是在最后），这个还是比较少见的</p><p>code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ld long double</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IL inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">100010</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">998244353</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> X=<span class="hljs-number">0</span>; <span class="hljs-type">bool</span> flag=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">0</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="hljs-number">1</span>)+(X&lt;&lt;<span class="hljs-number">3</span>)+ch-<span class="hljs-string">&#x27;0&#x27;</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> X;<br>    <span class="hljs-keyword">return</span> ~(X<span class="hljs-number">-1</span>);<br>&#125;<br>ll n,a;<br>ll dp[N];<br>vector&lt;ll&gt; col[N],st[N];<span class="hljs-comment">//栈</span><br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll x,ll c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> dp[col[c][x]<span class="hljs-number">-1</span>]+c*x*x<span class="hljs-number">-2</span>*x*c;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Slope</span><span class="hljs-params">(ll a,ll b,ll col)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a==b) <span class="hljs-keyword">return</span> inf;<br>    <span class="hljs-type">double</span> x=<span class="hljs-built_in">gt</span>(a,col)-<span class="hljs-built_in">gt</span>(b,col);x=x*<span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">double</span> y=a-b;y*=<span class="hljs-number">1.0</span>;<br>    <span class="hljs-keyword">return</span> x/y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10000</span>;++i) col[i].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;a;<br>        ll len=col[a].<span class="hljs-built_in">size</span>();<br>        col[a].<span class="hljs-built_in">push_back</span>(i);<span class="hljs-comment">//放入id</span><br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">1</span>) st[a].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//st存的是横坐标（颜色前缀和）</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//维护上凸包</span><br>            <span class="hljs-keyword">while</span>(st[a].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;<span class="hljs-built_in">Slope</span>(st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>],st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>],a)&lt;=<span class="hljs-number">2</span>*a*len) st[a].<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//sum_i=len</span><br>            ll id=st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>            dp[i]=dp[col[a][id]<span class="hljs-number">-1</span>]+a*(<span class="hljs-number">1</span>+len-id)*(<span class="hljs-number">1</span>+len-id);<br>            <span class="hljs-keyword">while</span>(st[a].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;<span class="hljs-built_in">Slope</span>(st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>],st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>],a)&lt;=<span class="hljs-built_in">Slope</span>(st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>],len,a)) st[a].<span class="hljs-built_in">pop_back</span>();<br>            st[a].<span class="hljs-built_in">push_back</span>(len);<br>        &#125;<br>        dp[i]=<span class="hljs-built_in">max</span>(dp[i],dp[i<span class="hljs-number">-1</span>]+a);<br>    &#125;<br>    cout&lt;&lt;dp[n]&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// ll t;t=read();while(t--)</span><br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一些特殊情况">一些特殊情况</h4><p>可以看到，如果题目已经有了决策单调性，大部分情况下还是比较套路的，但是有些时候问题在全局上不满足决策单调性并不意味着局部也没有。</p><p>还是<a href="https://www.luogu.com.cn/problem/P5504">JSOI2001柠檬</a>这道题，它就是在同种颜色内部满足决策单调性（这么一看这真是道好题啊，哪哪都这么与众不同）</p><p>以及<a href="https://codeforces.com/gym/101002/attachments">2016NAIPH</a></p><p>大意：</p><p>有n个物品，每个物品有一个体积<spanclass="math inline">\(w_i\)</span>和价值<spanclass="math inline">\(v_i\)</span>，现在要求对<spanclass="math inline">\(V∈[1,m]\)</span>，求出体积为<spanclass="math inline">\(V\)</span>的 背包能够装下的最大价值</p><p><spanclass="math inline">\(1≤n≤1000000;1≤m≤100000;1≤w_i≤300;1≤v_i≤10^9\)</span></p><p>其实就是对每一个<spanclass="math inline">\(V\)</span>，做一个多重背包</p><p>思路：</p><p>发现每一个物品的体积都比较小，所以可以按照体积分类。那么对于同一种体积的物品，我们肯定贪心选择价值最大的，所以可以排个序</p><p>考虑<span class="math inline">\(dp_{i,j}\)</span>表示使用体积<spanclass="math inline">\(\leqi\)</span>的物品，总体积为j的最大价值。我们可以将所有需要更新的体积按照%i来重新编号。比如当前i是2，m是9，我们就可以将<spanclass="math inline">\(0,2,4,6,8\)</span>化为一类各自重新编号为<spanclass="math inline">\(0,1,2,3,4\)</span>，<spanclass="math inline">\(1,3,5,7,9\)</span>划为一类，编号同理</p><p>这样的好处就是我们对于每一个i，j的范围也只有<spanclass="math inline">\([0,i]\)</span>这么大了，以及同一组体积内部的差恰好为i，那么物品就可以直接按照价值大小贪心塞了。</p><p>那么此时dp的意义就变了。如果当前是在更新%i=a的体积，则<spanclass="math inline">\(dp_{i,j}\)</span>表示使用体积<spanclass="math inline">\(\leq i\)</span>的物品，总体积为<spanclass="math inline">\(j*i+a\)</span>的最大值</p><p>%i=a时，<span class="math inline">\(dp_{i,j}=max_{k\leqj}\{dp_{i-1,k}+w(k,j)\}\)</span>,其中<spanclass="math inline">\(w(k,j)\)</span>表示体积=i的物品中最大的<spanclass="math inline">\(j-k\)</span>个物品的价值和，记为前缀和<spanclass="math inline">\(vt_{i,j-k}\)</span></p><p>简单证一下四边形不等式:</p><p>考虑<span class="math inline">\(i,i+1,j,j+1,i+1&lt;j\)</span></p><p><span class="math inline">\(w(i,j)+w(i+1,j+1)=2vt_{j-i}\)</span></p><p><spanclass="math inline">\(w(i+1,j)+w(i,j+1)=vt_{j-i-1}+vt_{j-i+1}=2vt_{j-i}+a_{j-i+1}-a_{j-i-1}\leqw(i,j)+w(i+1,j+1)\)</span></p><p>得证</p><p>那么直接分治即可</p><p>code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-11</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-type">const</span> ll N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br>ll n,m;<br>vector&lt;ll&gt; vt[<span class="hljs-number">310</span>];<br>ll dp[N],pp[N];<br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll id,ll x,ll mod,ll res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> pp[id*mod+res]+vt[mod][x-id<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(ll a,ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a&gt;b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solve</span><span class="hljs-params">(ll l,ll r,ll pl,ll pr,ll mod,ll res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span>;<br>    ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    ll pos=mid;<br>    dp[mid*mod+res]=pp[mid*mod+res];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">min</span>(mid<span class="hljs-number">-1</span>,pr);i&gt;=pl;--i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(mid-i&gt;(<span class="hljs-type">int</span>)vt[mod].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(i,mid,mod,res)&gt;dp[mid*mod+res]) dp[mid*mod+res]=<span class="hljs-built_in">gt</span>(pos=i,mid,mod,res);<br>    &#125;<br>    <span class="hljs-built_in">Solve</span>(l,mid<span class="hljs-number">-1</span>,pl,pos,mod,res);<br>    <span class="hljs-built_in">Solve</span>(mid+<span class="hljs-number">1</span>,r,pos,pr,mod,res);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        ll a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        vt[a].<span class="hljs-built_in">push_back</span>(b);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">300</span>;++i)<br>    &#123;<br>        <span class="hljs-built_in">sort</span>(vt[i].<span class="hljs-built_in">begin</span>(),vt[i].<span class="hljs-built_in">end</span>(),cmp);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;(<span class="hljs-type">int</span>)vt[i].<span class="hljs-built_in">size</span>();++j) vt[i][j]+=vt[i][j<span class="hljs-number">-1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">300</span>;++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!vt[i].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//枚举物品体积的类别</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;++j)<br>        &#123;<br>            <span class="hljs-comment">//枚举%i=j的体积</span><br>            <span class="hljs-built_in">Solve</span>(<span class="hljs-number">0</span>,(m-j)/i,<span class="hljs-number">0</span>,(m-j)/i,i,j);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j<span class="hljs-number">-1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) pp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) cout&lt;&lt;pp[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>本来想用SMAWK写的，但是一直MLE，不懂，求懂的佬教教</p><p>当然这题的决策单调性也是分组才有的，很抽象，感觉本人是不可能看出来的（哭</p><p>总结：</p><p>大工程，希望对自己&amp;大家有用:heartpulse:</p><p>参考文章</p><p><a href="https://oi-wiki.org/">OIWIKI</a></p><p><a href="https://www.osti.gov/biblio/10146169">Bein, W W, Larmore, LL, and Park, J K. <em>The d-edge shortest-path problem for a Mongegraph</em>. United States: N. p., 1992. Web.</a></p><p><a href="https://www.osti.gov/biblio/10175042">Bein, W W, Brucker, P,and Park, J K. <em>Applications of an algebraic Monge property</em>.United States: N. p., 1993. Web.</a></p><p><ahref="https://cp-algorithms.com/dynamic_programming/divide-and-conquer-dp.html">Divideand Conquer DP</a></p><p><ahref="https://www.luogu.com.cn/blog/MCAdam/jue-ce-dan-diao-xing">决策单调性- MCAdam</a></p><p><ahref="https://www.luogu.com.cn/blog/flashblog/solution-p1912">关于决策单调性与图像的结合</a></p><p>彭思进 《决策单调性与四边形不等式》</p>]]></content>
    
    
    <categories>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>动态规划</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斜率优化dp总结</title>
    <link href="/posts/94c8a29b/"/>
    <url>/posts/94c8a29b/</url>
    
    <content type="html"><![CDATA[<h2 id="斜率优化dp">斜率优化dp</h2><h3 id="前言">前言：</h3><p>我们学过不少优化类的算法了，大部分都是基于凸函数的性质给出的优化，比如SlopeTrick，Wqs二分，又比如今天的斜率优化（不知道什么时候会有空把SlopeTrick写掉）</p><h3 id="正文">正文：</h3><p>我们考虑一类比较常见的dp方程：<spanclass="math inline">\(dp_i=min/max_{j}(a_i*b_j+c_j+d_i)\)</span>,其中<strong><spanclass="math inline">\(b_j是单调增的\)</span></strong><spanclass="math inline">\(（事实上b_j\)</span>不单调增也可以用斜率优化处理，但是这里我们为了简化先考虑这样一种特殊情况）。同时，为了方便，接下来我们先以min为讨论对象，实际上max是同理的，读者可以自己对应手推一遍</p><p>一般的暴力递推，复杂度是<spanclass="math inline">\(O(N^2)\)</span>的。</p><p>我们考虑改变一下式子的形式：<spanclass="math inline">\(dp_i=min_{j}\{a_i*b_j+c_j\}+d_i\)</span>,此时对于固定的<spanclass="math inline">\(i\)</span>,外面的<spanclass="math inline">\(d_i\)</span>是固定的，所以我们真正要考虑的其实是<spanclass="math inline">\(a_i*b_j+c_j\)</span>这样一个式子的最小值，它其实就是一个一次函数<spanclass="math inline">\(kx+b\)</span>的形式，其中<spanclass="math inline">\(k=b_j,b=c_j\)</span>。我们不妨记<spanclass="math inline">\(f_{i,j}=a_i*b_j+c_j\)</span></p><h4 id="凸包">凸包</h4><p>我们不妨来看一下，如果两个点<spanclass="math inline">\(x&lt;y\)</span>，对于某一个i满足<spanclass="math inline">\(f(i,y)\leq f(i,x)\)</span>,也就是说<spanclass="math inline">\(y\)</span>是比<spanclass="math inline">\(x\)</span>更加优的一个决策点，它们之间会有什么关系</p><p><span class="math inline">\(f(i,y)=a_i*b_y+c_y\leqf(i,x)=a_i*b_x+c_x\)</span></p><p>即：<span class="math inline">\(\large \frac{c_y-c_x}{b_y-b_x}\leq-a_i\)</span>(注意之前我们假定<spanclass="math inline">\(b_i\)</span>是单增的)</p><blockquote><p>这里是在做一个参变分离，注意这里我们其实是将x,y的信息视为已知量，而将i作为变量</p></blockquote><p>放到二维坐标系下考虑，就是<spanclass="math inline">\((b_x,c_x),(b_y,c_y)\)</span>两个点的连线的斜率<spanclass="math inline">\(\leq -a_i\)</span></p><p><img src="https://s2.loli.net/2023/12/19/Y2egrsEdxcBw9U8.png" alt="image-20230901175709520" style="zoom:100%;" /></p><p>换句话说，这里如果x是y之前的比较优的一个点，在y出现之后它就被淘汰了，判断的条件我们记为<spanclass="math inline">\(k_{xy}&lt;=K(X)\)</span>,其中<spanclass="math inline">\(K(X)=-a_i\)</span>。</p><p>接着我们将考虑的点数扩大到三个点<span class="math inline">\(x\leq y\leq z\)</span>,这里我们不妨先限定<span class="math inline">\(K_{yz}\leqK_{xy}\)</span></p><p><img src="https://s2.loli.net/2023/12/19/KeSIpcrOGB5f2hJ.png" alt="image-20230901175709520" style="zoom:100%;" /></p><p>边界条件还是<span class="math inline">\(K(X)=-a_i\)</span></p><blockquote><p>按照之前的讨论，对于两个点<spanclass="math inline">\(x,y\)</span>,若<spanclass="math inline">\(k_{x,y}\leq K(x)\)</span>,则点<spanclass="math inline">\(y优于x\)</span>,否则<spanclass="math inline">\(点x优于y\)</span></p></blockquote><p>那么我们有如下几种情况：</p><ul><li>$K_{yz}&lt;K_{xy} K(X) <spanclass="math inline">\(,则\)</span>点z优于点x,y$</li><li><span class="math inline">\(K_{yz}\leqK(X)&lt;K_{xy}\)</span>,则点<spanclass="math inline">\(x,z\)</span>优于<spanclass="math inline">\(点y\)</span></li><li><span class="math inline">\(K(X)\leqK_{yz}&lt;K_{zy}\)</span>,则点x优于点<spanclass="math inline">\(y,z\)</span></li></ul><p>此时我们惊奇地发现，不管是哪一种情况，点<spanclass="math inline">\(y\)</span>都不可能作为最优解。按照之前所说，我们其实是对于这样一系列固定的点，对于不同的i，考察最优决策点的变化。也就是说，如果我们提前处理好了这样若干个点，那么我们就已经知道点y永远不会成为最优决策点了（在三个点都能选择的情况下）</p><blockquote><p>讲回我们在这部分讨论前做的假设<span class="math inline">\(K_{yz}\leqK_{x,y}\)</span>,读者可以自行验证，当三点不满足该关系的时候，我们并不能得到类似或者什么更优的结论。</p></blockquote><p>那么我们对于一个固定的点i，将所有能进行决策的点进行这样一个预处理过程的话（大部分情况下对于固定的点i，我们只能够在<spanclass="math inline">\([1,i-1]\)</span>内决策，这里直接取该情况，其它情况其实同理），<spanclass="math inline">\(\forall 1\leq x&lt;y&lt;z&lt; i\)</span>,若<spanclass="math inline">\(K_{yz}\leqK_{x,y}\)</span>,则将点y删除（因为它永远不会成为一个最优）,那么将留下来的点两两按横坐标顺序前后链接，斜率是<strong>单调不降的</strong>，换句话说，留下来的点就形成了一个<strong>下凸包</strong>，如下图所示，其中绿色连接部分就是一个凸包，红色点是在处理过程中被删除的点</p><p><img src="https://s2.loli.net/2023/12/19/1IxmWoDGw9PSRen.png" alt="image-20230901175709520" style="zoom:100%;" /></p><h4 id="最优决策点的快速寻找">最优决策点的快速寻找</h4><p>一旦要维护的东西变成了一个凸包，那么我们的手段就可以很骚了，因为此时它的斜率具有单调性，我们就可以上二分等手段了:)</p><p>对于一个固定的i，我们有<spanclass="math inline">\(K(X)=-a_i\)</span>,由于下凸包的斜率是单增的，所以将斜率从左到右一一写出来的话，我们会得到如下关系</p><p><span class="math inline">\(K_1&lt;K_2&lt;...&lt;K_s\leqK(X)&lt;K_{s+1}...K_{m}\)</span></p><p>那么我们要找的点显然就是s，也就是最后一个与前面的点连线的斜率<spanclass="math inline">\(\leq K(X)\)</span>的点</p><p>那么我们维护好这个凸包之后，直接用二分线段即可，最后一个斜率<spanclass="math inline">\(\leq K(X)\)</span>的线段的右端点就是答案了</p><blockquote><p>考虑凸包的一个特殊情况：多个点处于一条线段上，就如上图的第二条线段，但是该情况对我们的选择并没有影响，因为我们取的是每一个线段的最右端点</p></blockquote><p>这样每次去寻找最优决策点的复杂度是<spanclass="math inline">\(O(log)\)</span>的，再加上维护凸包的复杂度<spanclass="math inline">\(O(N)\)</span>,时间复杂度就是<spanclass="math inline">\(O(NlogN)\)</span>的</p><p>具体流程:</p><ul><li><p>A 在凸包上二分找到最优决策点x</p></li><li><p>B 用x的值更新<span class="math inline">\(dp_i\)</span></p></li><li><p>C在将i加入凸包之前，我们要先将队尾一部分一定没有i优的点踢掉，然后再将i加入凸包</p></li></ul><p>对步骤C的解释：这里将i直接加入凸包的话，有可能我们维护的就不再是一个凸包了，如下图情况</p><p><img src="https://s2.loli.net/2023/12/19/OCarLxQ3tYJR1SE.png" alt="image-20230901175709520" style="zoom:100%;" /></p><p>不难发现，此时<spanclass="math inline">\(x,y,i\)</span>三点形成的就是之前讨论过的三个点的情形，所以y是一定不会成为最优决策点的。同理，踢掉y之后，如果<spanclass="math inline">\(z,x,i\)</span>也是一个情况的话，x也会被踢掉，直到最后不再有这样的点为止</p><h4 id="再优化">再优化</h4><p>注意到上面的复杂度还是有点高，我们考虑dp过程中常见的决策单调性情况</p><p>决策单调性：在dp过程中，设<spanclass="math inline">\(S_i表示dp_i\)</span>的最优决策点，如果<spanclass="math inline">\(\forall i&lt;j,S_i\leqS_j\)</span>则称该dp过程满足决策单调性，也就是说随着dp过程的进行，最优决策点是单调不降的</p><p>关于决策单调性的证明，常见的就是四边形不等式，这里暂且不提，后面有空再说:)</p><p>决策单调性在这里意味着什么？意味着之前已经被淘汰的点是不会再作为最优决策点出现的。所以我们就可以考虑用单调队列来维护。</p><p>具体流程：</p><ul><li>A <strong>将队列首部斜率<span class="math inline">\(\leqK(X)\)</span>的线段的左端点不断踢出，最后剩下的队首元素x就是最优决策点。（正确性显然）</strong></li><li>B 用x的值更新<span class="math inline">\(dp_i\)</span></li><li>C在将i加入凸包之前，我们要先将队尾一部分一定没有i优的点踢掉，然后再将i加入凸包</li></ul><p>与直接二分的区别就在于步骤A</p><blockquote><p>同时我们注意到，如果<spanclass="math inline">\(K(X)\)</span>是单调的，其自然满足决策点的单调性。（在横坐标单调的前提下）</p></blockquote><p><img src="https://s2.loli.net/2023/12/19/lvNPTIB4QUHjGx6.png" alt="image-20230901175709520" style="zoom:100%;" /></p><h4 id="类型总结单调队列维护凸包">类型总结（单调队列维护凸包）</h4><p>当dp式子满足<span class="math inline">\(\large\frac{c_y-c_x}{b_y-b_x}\leq-a_i\)</span>的时候，我们要维护的是一个下凸包</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>que[++tl]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>    <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[hd],que[hd+<span class="hljs-number">1</span>])&lt;=k[x]) hd++;<span class="hljs-comment">//这里k[x]表示K(X)</span><br>    dp[i]=...<span class="hljs-comment">//用que[hd]来更新dp[i]即可</span><br>    <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[tl<span class="hljs-number">-1</span>],que[tl])&gt;=<span class="hljs-built_in">Slope</span>(que[tl],i)) tl--;<br>    que[++tl]=i;<span class="hljs-comment">//插入凸包</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当dp式子满足<span class="math inline">\(\large\frac{c_y-c_x}{b_y-b_x}\geq-a_i\)</span>的时候，同理就是维护一个上凸包</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>que[++tl]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>    <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[hd],que[hd+<span class="hljs-number">1</span>])&gt;=k[x]) hd++;<span class="hljs-comment">//这里k[x]表示K(X)</span><br>    dp[i]=...<span class="hljs-comment">//用que[hd]来更新dp[i]即可</span><br>    <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[tl<span class="hljs-number">-1</span>],que[tl])&lt;=<span class="hljs-built_in">Slope</span>(que[tl],i)) tl--;<br>    que[++tl]=i;<span class="hljs-comment">//插入凸包</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="tip">Tip</h4><ul><li>当两个点的横坐标相等的时候，实际上不存在斜率，这里我们要特判，取为inf</li><li>到底维护的是上凸包还是下凸包不要弄混，仔细推导一遍最好</li><li>一般是直接用double类型来计算斜率并进行比较，但是有时候出题人不讲武德卡精度，那就要转成乘式类型来比较了，这时候要注意一下负号改变方向的情况</li><li>队列一开始要放进去一个0，毕竟也不一定非有上一个转移点</li><li>有时候dp值会需要预处理，要小心</li><li>比较斜率的时候最好使用<spanclass="math inline">\(\leq,\geq\)</span></li></ul><h4 id="一些特殊情况">一些特殊情况</h4><ul><li><spanclass="math inline">\(b_j\)</span>是单调减的：实际与之前的情况同理。在一开始的推导中我们假定<spanclass="math inline">\(x&lt;y\)</span>，本质上就是为了保证<spanclass="math inline">\(b_j\)</span>是单增的，如果此时它是单减的，我们只要在原本的式子中在对应位置取负，再改变前面符号，重新推导即可。此时<spanclass="math inline">\(-b_j\)</span>就是单增的了</li><li><spanclass="math inline">\(b_j\)</span>不具备单调性：此时我们不能直接通过单调队列来维护凸包，因为新加入的点的横坐标并不是单调的，可能会插入在凸包的中间的位置。此时需要采用cdq分治</li><li>不具备决策单调性：那就只能二分了，不能强行弹出点，因为它可能在后面会成为最优决策点</li><li>不具备决策单调性&amp;横坐标不单调：cdq分治 后面会讲</li></ul><h3 id="例子">例子</h3><p><a href="https://www.luogu.com.cn/problem/P2120">仓库建设</a></p><p>大意：</p><p><span class="math inline">\(n\)</span>个工厂，由高到低分布在一座山上，工厂 <spanclass="math inline">\(1\)</span> 在山顶，工厂 <spanclass="math inline">\(n\)</span> 在山脚。第 <spanclass="math inline">\(i\)</span> 个工厂目前已有成品 <spanclass="math inline">\(p_i\)</span> 件，在第 <spanclass="math inline">\(i\)</span> 个工厂位置建立仓库的费用是 <spanclass="math inline">\(c_i\)</span>。对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，产品只能往山下运（即<strong>只能运往编号更大的工厂的仓库</strong>），一件产品运送一个单位距离的费用是<span class="math inline">\(1\)</span>。</p><ul><li>工厂 <span class="math inline">\(i\)</span> 距离工厂 <spanclass="math inline">\(1\)</span> 的距离 <spanclass="math inline">\(x_i\)</span>（其中 <spanclass="math inline">\(x_1=0\)</span>）。</li><li>工厂 <span class="math inline">\(i\)</span> 目前已有成品数量 <spanclass="math inline">\(p_i\)</span>。</li><li>在工厂 <span class="math inline">\(i\)</span> 建立仓库的费用 <spanclass="math inline">\(c_i\)</span>。</li></ul><p>问修建仓库的最小代价</p><p>思路：</p><p>设<spanclass="math inline">\(dp_i\)</span>表示前i个工厂的最小代价，写出dp式子的过程还是比较套路的，</p><p><span class="math inline">\(dp_i=min_{j\leqi}\{dp_j+x_i\sum_{k=j+1}^{i}(p_k)-\sum_{k=j+1}^{i}(x_kp_k)\}+c_i\)</span></p><p>转化得到</p><p><span class="math inline">\(dp_i=min_{j\leqi}\{dp_j+x_i(sum_i-sum_j)-(xsum_i-xsum_j)\}+c_i\)</span></p><p>其中<spanclass="math inline">\(sum_i=\sum_{k=1}^{i}p_k,xsum_i=\sum_{k=1}^{i}p_k*x_k\)</span></p><p>所以<span class="math inline">\(dp_i=min_{j\leqi}\{-sum_jx_i+(dp_j+xsum_j)\}+x_isum_i-xsum_i+c_i\)</span></p><p>这里<span class="math inline">\(sum_j\)</span>是单调增的</p><p>考虑<span class="math inline">\(a&lt;yb\)</span>,且b优于a:</p><p>令<span class="math inline">\(f_j=dp_j+xsum_j\)</span></p><p><span class="math inline">\(-sum_bx_i+f_b\leq-sum_ax_i+f_a\)</span></p><p><span class="math inline">\(\frac{f_b-f_a}{sum_b-sum_a}\leqx_i\)</span>,这里我们要维护的就是一个下凸包了，并且斜率<spanclass="math inline">\(K(X)=x_i\)</span>是单调增的</p><p>因此直接套板子即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ty</span><br>&#123;<br>    ll x,p,c;<br>&#125;mas[N];<br>ll sum[N];<br>ll xsum[N];<br>ll n;<br>ll dp[N];<br>ll que[N];<br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll l,ll r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> mas[r].x*(sum[r]-sum[l])-(xsum[r]-xsum[l]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Slope</span><span class="hljs-params">(ll a,ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(sum[a]==sum[b]) <span class="hljs-keyword">return</span> inf;<br>    <span class="hljs-type">double</span> x=(dp[a]+xsum[a]-dp[b]-xsum[b])*<span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">double</span> y=(sum[a]-sum[b])*<span class="hljs-number">1.0</span>;<br>    <span class="hljs-keyword">return</span> x/y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;mas[i].x&gt;&gt;mas[i].p&gt;&gt;mas[i].c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) sum[i]=sum[i<span class="hljs-number">-1</span>]+mas[i].p,xsum[i]=xsum[i<span class="hljs-number">-1</span>]+mas[i].x*mas[i].p;<br>    ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>    que[++tl]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[hd],que[hd+<span class="hljs-number">1</span>])&lt;mas[i].x) hd++;<br>        dp[i]=dp[que[hd]]+<span class="hljs-built_in">gt</span>(que[hd],i)+mas[i].c;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[tl<span class="hljs-number">-1</span>],que[tl])&gt;<span class="hljs-built_in">Slope</span>(que[tl],i)) tl--;<br>        que[++tl]=i;<br>    &#125;<br>    ll pos=n;<br>    <span class="hljs-keyword">while</span>(mas[pos].p==<span class="hljs-number">0</span>) pos--;<br>    ll ans=inf;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos;i&lt;=n;++i) ans=<span class="hljs-built_in">min</span>(ans,dp[i]);<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>PS:此题有其它坑点，读者自己小心~</p><p><a href="https://www.luogu.com.cn/problem/P2900">[USACO08MAR] LandAcquisition G</a></p><p>大意：</p><p>将<spanclass="math inline">\(n\)</span>块土地分组，每组的价格是这组土地中最大的长宽乘积，问买下所有土地的最小花费。</p><p>思路：</p><p>个人感觉一开始的思路还是有点妙的</p><p>不妨按照长升序排序，如果长相同就宽升序</p><p>从前往后遍历的时候，考虑<spanclass="math inline">\(i&lt;j\)</span>，显然如果<spanclass="math inline">\(i,j\)</span>放一组，长一定是取<spanclass="math inline">\(j\)</span>的，那么如果<spanclass="math inline">\(j\)</span>的宽也大于<spanclass="math inline">\(i\)</span>的话，那么<spanclass="math inline">\(i\)</span>就没有任何贡献。所以我们可以用一个栈来维护，把没用的东西踢掉。显然在最优决策下，每一组的土地会是连续的一段</p><p>考虑<spanclass="math inline">\(dp_i\)</span>表示排序弹出处理之后前i个土地的最小值：</p><p><span class="math inline">\(dp_i=min_{j\leqi}\{dp_j+b_{j+1}a_i\}\)</span>,其中<spanclass="math inline">\(a\)</span>表示长，<spanclass="math inline">\(b\)</span>表示宽</p><p>这里<spanclass="math inline">\(b_j\)</span>在处理之后是降序的，我们可以转化成<spanclass="math inline">\(dp_i=min_{j\leqi}\{dp_j-b&#39;_{j+1}a_i\},b&#39;_j=-b_j\)</span></p><p>考虑<span class="math inline">\(x&lt;y\)</span>,且y优于x</p><p><span class="math inline">\(-b&#39;_ya_i+dp_j\leq-b&#39;_xa_i+dp_x\)</span></p><p><span class="math inline">\(\frac{dp_x-dp_y}{b&#39;_x-b&#39;_y}\leqa_i\)</span>，还是维护一个下凸包，并且斜率<spanclass="math inline">\(a_i\)</span>是单增的，所以也是直接套板子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ty</span><br>&#123;<br>    ll a,b;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> ty &amp; B) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(a==B.a) <span class="hljs-keyword">return</span> b&lt;B.b;<br>        <span class="hljs-keyword">return</span> a&lt;B.a;<br>    &#125;<br>&#125;mas[N];<br>ll n;<br>ll que[N];<br>ll dp[N];<br>ty st[N];<br>ll top=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Slope</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(st[x+<span class="hljs-number">1</span>].b==st[y+<span class="hljs-number">1</span>].b) <span class="hljs-keyword">return</span> inf;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>*((dp[y]-dp[x])/(-st[y+<span class="hljs-number">1</span>].b+st[x+<span class="hljs-number">1</span>].b));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;mas[i].a&gt;&gt;mas[i].b;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(mas+<span class="hljs-number">1</span>,mas+<span class="hljs-number">1</span>+n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(top)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(mas[i].b&gt;=st[top].b) top--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        st[++top]=mas[i];<br>    &#125;<br>    ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>    que[++tl]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=top;++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[hd],que[hd+<span class="hljs-number">1</span>])&lt;st[i].a) hd++;<br>        <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;que[hd]&lt;&lt;endl;</span><br>        dp[i]=dp[que[hd]]+st[que[hd]+<span class="hljs-number">1</span>].b*st[i].a;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[tl<span class="hljs-number">-1</span>],que[tl])&gt;<span class="hljs-built_in">Slope</span>(que[tl],i)) tl--;<br>        que[++tl]=i;<br>    &#125;<br>    cout&lt;&lt;dp[top]&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><ahref="https://www.luogu.com.cn/problem/P4027">[ZJOI2007]仓库建设</a></p><p>大意：</p><p><del>本人太懒。。。</del></p><p>思路：</p><p>这题就是需要cdq分治的题了</p><p>考虑<spanclass="math inline">\(f_i\)</span>表示第i天能够获得的最大钱数，<spanclass="math inline">\(g_i\)</span>表示第i天最多能买多少张B券</p><p>则<span class="math inline">\(\largeg_i=\frac{f_i}{r_ia_i+b_i}\)</span></p><p>故<span class="math inline">\(f_i=max\{max_{j\leqi-1}\{g_j\frac{b_i}{a_i}+r_jg_j\}*a_i,f_{i-1}\}\)</span></p><p>外层的max我们可以直接特判，内层的max就是一个典型的斜率优化dp了。</p><p>考虑<spanclass="math inline">\(g_x&lt;g_y\)</span>,且y优于x（这里<spanclass="math inline">\(g\)</span>不是单调的，我们不能直接假设<spanclass="math inline">\(x&lt;y\)</span>）,l令<spanclass="math inline">\(F_j=r_jg_j\)</span></p><p><span class="math inline">\(g_x\frac{b_i}{a_i}+F_x\geqg_y\frac{b_i}{a_i}+F_y\)</span></p><p>即<span class="math inline">\(\large \frac{F_x-F_y}{g_x-g_y}\leq-\frac{b_i}{a_i}\)</span></p><p>实际还是一个下凸包。这里横坐标是<spanclass="math inline">\(g_j\)</span>,纵坐标是<spanclass="math inline">\(F_j\)</span>,斜率是<spanclass="math inline">\(-\frac{b_i}{a_i}\)</span></p><p>横坐标不是单调的，斜率也不是单调的，看起来不是能用普通凸包来维护的样子。所以我们可以使用cdq分治</p><p>想要用单调队列维护凸包的话，我们实际上有三维偏序：</p><ul><li>对于每一个i，它的决策点是<spanclass="math inline">\(\{j|j&lt;i\}\)</span>，也就是id较小的点才可以更新id较大的点</li><li>维护凸包的时候，如果x先于y加入凸包，要满足<spanclass="math inline">\(g_x&lt;g_y\)</span></li><li>凸包查询最优决策点的时候，如果x先于y查询，要满足<spanclass="math inline">\(K(x)&lt;K(y)\)</span>，因为我们要利用决策点不降的性质来加速选择最优点的过程</li></ul><p>显然，三维偏序正是cdq分治的拿手好戏~</p><ul><li>第一关键字：首先将点按照斜率升序排序，能够保证查询的斜率递增，从而能用单调队列维护</li><li>第二关键字：分治时按照id分成左右两个部分。这样保证最后递归到叶子节点的时候是符合原本顺序的，且斜率查询的时候保证都是维护的点的id都是在自己之前的（其实就是一个归并排序）</li><li>第三关键字：x每次分治结束之后内部不再有贡献，所以我们可以直接按照横坐标升序排序方便后面维护凸包</li></ul><p>我们会发现这样处理之后就能够实现三维偏序了。</p><p>cdq分治的灵魂是用前半部分的信息来统计对后半部分的贡献，当一段区间分治结束之后，这段区间内的信息就全部处理完了，换句话说，区间内部的点之间是不会再产生贡献了，因此我们才可以随意更改该区间内部的点的顺序。将其按照横坐标排序，我们才能进行凸包的维护。同时，以横坐标为关键字的排序我们可以直接sort，但是也可以采用归并排序</p><p>最后，求出<span class="math inline">\(f_i\)</span>之后，再与<spanclass="math inline">\(f_{i-1}取max\)</span>，并更新<spanclass="math inline">\(g_i\)</span></p><p>具体流程：</p><ul><li>if(l==r) 更新，退出</li><li>按照id分成左右两部分<spanclass="math inline">\([l,mid],(mid,r]\)</span></li><li>cdq(l,mid)</li><li>此时<spanclass="math inline">\([l,mid]\)</span>已经处理好了，所以用单调队列对<spanclass="math inline">\([l,mid]\)</span>建凸包</li><li><span class="math inline">\((mid,r]\)</span>区间此时是以<spanclass="math inline">\(\frac{-b_i}{a_i}\)</span>升序,所以按顺序更新即可，并更新凸包</li><li>cdq(mid+1,r)</li><li>按照横坐标对<spanclass="math inline">\([l,r]\)</span>进行归并，因为该区间内部不会再有互相的贡献了</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> il inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps =<span class="hljs-number">1e-8</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e17</span>;<br>ll n;<br><span class="hljs-type">double</span> s;<br><span class="hljs-type">double</span> A[N],B[N],R[N];<br><span class="hljs-type">double</span> f[N],X[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ty</span><br>&#123;<br>    ll id;<br>    <span class="hljs-type">double</span> slope;<br>    <span class="hljs-type">double</span> a,b,k;<br>    <span class="hljs-comment">//第一关键字：斜率 按照斜率升序能够保证查询的斜率递增，从而能用单调队列维护</span><br>    <span class="hljs-comment">//第二关键字：id 分治时按照id分成左右两个部分。这样保证最后递归到叶子节点的时候是符合原本顺序的</span><br>    <span class="hljs-comment">//且斜率查询的时候保证都是维护的点的id都是在自己之前的</span><br>    <span class="hljs-comment">//第三关键字：x 每次分治结束之后内部不再有贡献，则按照x升序排方便后面维护凸包</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> ty &amp; b) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(slope==b.slope) <span class="hljs-keyword">return</span> id&lt;b.id;<br>        <span class="hljs-keyword">return</span> slope&gt;b.slope;<span class="hljs-comment">//斜率递减</span><br>    &#125;<br>&#125;mas[N],tmp[N];<br>ll que[N];<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Slope</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(X[mas[x].id]==X[mas[y].id])<br>    &#123;<br>        <span class="hljs-keyword">return</span> inf;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (X[mas[y].id]*mas[y].k-X[mas[x].id]*mas[x].k)/(X[mas[y].id]-X[mas[x].id]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> id,<span class="hljs-type">double</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[mas[id].id]&lt;val)<br>    &#123;<br>        f[mas[id].id]=val;<br>        X[mas[id].id]=f[mas[id].id]/(mas[id].k*mas[id].a+mas[id].b);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cdq</span><span class="hljs-params">(ll l,ll r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r)<br>    &#123;<br>        f[mas[l].id] = <span class="hljs-built_in">max</span>(f[mas[l].id],f[mas[l].id<span class="hljs-number">-1</span>]);<span class="hljs-comment">//这里的f_&#123;i-1&#125;是所有排序前的i-1，所以要稍微绕一下，注意别弄错</span><br>        X[mas[l].id]=f[mas[l].id]/(mas[l].k*mas[l].a+mas[l].b);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    ll posl=l,posr=mid+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(mas[i].id&lt;=mid) tmp[posl++]=mas[i];<br>        <span class="hljs-keyword">else</span> tmp[posr++]=mas[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;++i) mas[i]=tmp[i];<br>    <span class="hljs-comment">//按照id处理好了</span><br>    <span class="hljs-built_in">cdq</span>(l,mid);<br>    <span class="hljs-comment">//先处理前一个部分，保证此时前半部分的x是升序的</span><br>    ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=mid;++i)<span class="hljs-comment">//维护凸包</span><br>    &#123;<br>        <span class="hljs-keyword">while</span>(tl&gt;hd&amp;&amp;<span class="hljs-built_in">Slope</span>(que[tl<span class="hljs-number">-1</span>],que[tl])&lt;<span class="hljs-built_in">Slope</span>(que[tl],i)+eps) tl--;<br>        que[++tl]=i;<br>    &#125;<br>    ll id;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=mid+<span class="hljs-number">1</span>;i&lt;=r;++i)<span class="hljs-comment">//计算两边产生的贡献</span><br>    &#123;<br>        <span class="hljs-keyword">while</span>(tl&gt;hd&amp;&amp;<span class="hljs-built_in">Slope</span>(que[hd],que[hd+<span class="hljs-number">1</span>])&gt;mas[i].slope) hd++;<br>        <span class="hljs-built_in">upd</span>(i,X[mas[que[hd]].id]*(mas[que[hd]].k-mas[i].slope)*mas[i].a);<br>    &#125;<br>    <span class="hljs-built_in">cdq</span>(mid+<span class="hljs-number">1</span>,r);<br><br>    posl=l,posr=mid+<span class="hljs-number">1</span>;<br>    ll tot=l<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(posl&lt;=mid&amp;&amp;posr&lt;=r)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(X[mas[posl].id]&lt;X[mas[posr].id]) tmp[++tot]=mas[posl++];<br>        <span class="hljs-keyword">else</span> tmp[++tot]=mas[posr++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(posl&lt;=mid) tmp[++tot]=mas[posl++];<br>    <span class="hljs-keyword">while</span>(posr&lt;=r) tmp[++tot]=mas[posr++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;++i) mas[i]=tmp[i];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;A[i]&gt;&gt;B[i]&gt;&gt;R[i];<br>        mas[i].id=i;<br>        mas[i].a=A[i];mas[i].b=B[i];mas[i].k=R[i];<br>        mas[i].slope=-B[i]/A[i];<br>        <span class="hljs-comment">// if(i&gt;1) continue;</span><br>        X[mas[i].id]=s/(R[i]*A[i]+B[i]);<br>        <span class="hljs-comment">// mas[i].y=R[i]*mas[i].x;</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) f[i]=s;<br>    <span class="hljs-built_in">sort</span>(mas+<span class="hljs-number">1</span>,mas+<span class="hljs-number">1</span>+n);<br>    <span class="hljs-built_in">cdq</span>(<span class="hljs-number">1</span>,n);<br>    cout&lt;&lt;fixed&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">4</span>)&lt;&lt;f[n]&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="后记">后记</h3><p>斜率优化dp在大部分情况下都是结合决策单调性进行的（<strong>大部分</strong>），所以也比较套路</p><p>另外还有结合Wqs二分来处理前n个数限定分m段的情况等的套路，个人感觉决策单调性优化的水还是有点深的，有空会试试写一期总结</p><p>加油~</p>]]></content>
    
    
    <categories>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>动态规划</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>群作用</title>
    <link href="/posts/3b5fa2a8/"/>
    <url>/posts/3b5fa2a8/</url>
    
    <content type="html"><![CDATA[<h1 id="群作用轨道-稳定化子定理">群作用，轨道-稳定化子定理</h1><p>不妨通过一个简单的例子来引入群作用的概念，恕我直言这个东西真的很神奇</p><h2 id="引入">引入</h2><blockquote><p>令<spanclass="math inline">\(S\)</span>是一个非空集合，我们考虑所有<spanclass="math inline">\(S \rightarrow S\)</span>的双射<spanclass="math inline">\(f\)</span>所组成的集合，记为<spanclass="math inline">\(Perm(S)\)</span>，事实上它关于映射的复合作成一个群，即<span class="math inline">\(S\)</span>上的置换群，即<spanclass="math inline">\((Perm(s),\circ)\)</span></p></blockquote><p>接下来考虑群<spanclass="math inline">\(G\)</span>上，对于一个特定的元素<spanclass="math inline">\(x\in G\)</span>的映射： <spanclass="math inline">\(\phi_x: G\rightarrow G,a\mapstoxa\)</span>,事实上它是一个双射，对于这一点我们只需证明<spanclass="math inline">\(\phi_x\)</span>存在逆映射即可。显然<spanclass="math inline">\(\phi_x\)</span>的逆映射就是<spanclass="math inline">\(\phi_{x^{-1}}: G\rightarrow G,a\mapstox^{-1}a\)</span>，</p><p><font color='orange'><strong>证明： </strong></font> <spanclass="math display">\[(\phi_x\circ\phi_{x^{-1}})(a)=\phi_x((\phi_{x^{-1}}(a)))=\phi_x(x^{-1}a)=xx^{-1}a=a=Id(a)\\(\phi_{x^{-1}}\circ\phi_{x})(a)=\phi_{x^{-1}}((\phi_{x}(a)))=\phi_{x^{-1}}(xa)=x^{-1}xa=a=Id(a)\\\]</span> 其中<span class="math inline">\(Id\)</span>就表示<spanclass="math inline">\(S\rightarrow S\)</span>的恒等映射</p><p>那么此时就有<spanclass="math inline">\((\phi_x)^{-1}=\phi_{x^{-1}}\)</span> ，故<spanclass="math inline">\(\phi_x\)</span>是<spanclass="math inline">\(G到G\)</span>的一个双射 <spanclass="math inline">\(\square\)</span></p><hr /><p>我们很快就注意到<strong><span class="math inline">\(\phi_x\inPerm(G)\)</span></strong> 。将目光从<spanclass="math inline">\(\phi_x\)</span>上再抽象出来一层，我们定义映射<spanclass="math inline">\(\phi:(G,\cdot)\rightarrow (Perm(G),\circ),x\mapsto\phi_x\)</span>。这里有点抽象，前者是一个群<spanclass="math inline">\(G\)</span>，后者也是一个群，但是它是从一个<strong>集合</strong><spanclass="math inline">\(G\)</span>当中得到的，在这个集合里我们忽略了<spanclass="math inline">\(G\)</span>的运算的结构，只考虑它作为集合的结构，从而得到所有在其上的双射组成的<spanclass="math inline">\((Perm(G),\circ)\)</span></p><p>映射的两个对象都是群，令人惊奇的是，事实上<spanclass="math inline">\(\phi\)</span>也是一个群同态：</p><p><font color='orange'><strong>证明：</strong></font></p><p><span class="math inline">\(\phi是良定义的:这一点显然\\\)</span></p><p><span class="math inline">\(\forall x,y\in G，z\in G\)</span> <spanclass="math display">\[(\phi_x\circ\phi_y)(z)=x(yz)=(xy)z=\phi_{xy}(z)\]</span> 对于所有的<spanclass="math inline">\(z\)</span>都满足该性质，故 <spanclass="math display">\[\phi_x\circ \phi_y=\phi_{xy}\]</span> 故 <span class="math display">\[\phi(x\cdot y)=\phi(x)\circ \phi(y)\]</span> <strong>故<span class="math inline">\(\phi\)</span>是<spanclass="math inline">\(G\rightarrow Perm(G)\)</span>的一个群同态</strong> <span class="math inline">\(\square\)</span></p><p>这样的一个神奇的<spanclass="math inline">\(\phi\)</span>就是一个群作用。现在我们给出定义如下</p><h2 id="定义1">定义1</h2><blockquote><p>令<span class="math inline">\(G\)</span>是一个群，<spanclass="math inline">\(S\)</span>是一个非空集合，若<spanclass="math inline">\(\phi:G\rightarrowPerm(S)\)</span>是一个<strong>群同态</strong>，那么称<spanclass="math inline">\(\phi\)</span>是<strong>群</strong><spanclass="math inline">\(G\)</span>在<strong>集合</strong><spanclass="math inline">\(S\)</span>上的一个群作用</p></blockquote><p>在上例中集合<span class="math inline">\(S\)</span>恰好就是<spanclass="math inline">\(G\)</span>本身，但是我们也强调过在<spanclass="math inline">\((Perm(G),\circ)\)</span>中我们已经忽略了<spanclass="math inline">\(G\)</span>作为群的运算结构而只考虑其集合的结构</p><p>从这个定义中我们可以很清晰地看到<spanclass="math inline">\(\phi\)</span>作为一个群同态的优美性质，但是实际上还有另外一种等价的定义，它能帮助我们更好地判断一个映射是否为群作用</p><h2 id="定义2">定义2</h2><blockquote><p>令<span class="math inline">\(G\)</span>是一个群，<spanclass="math inline">\(S\)</span>是一个非空集合，如果映射 <spanclass="math display">\[\sigma: G\cross S\rightarrow S\\\forall a\in G,x\in S,(a,x)\mapstoa\cdot x\\我们记为a作用在x上\]</span> 满足： <span class="math display">\[e\cdot x=x,\forall x\in S\\(ab)\cdot x=a\cdot(b\cdot x),\forall a,b \inG,x\in S\]</span> 那么称群<span class="math inline">\(G\)</span>在集合<spanclass="math inline">\(S\)</span>上<strong>有一个作用</strong> <spanclass="math inline">\((a,x)\mapsto a\cdot x\)</span></p></blockquote><p>仔细观察定义1，<spanclass="math inline">\(\phi\)</span>是我们的群作用，是一个<spanclass="math inline">\(G\rightarrowPerm(s)\)</span>的映射，现在我们取出一个<spanclass="math inline">\(x\)</span>，得到一个<spanclass="math inline">\(\phi_x\inPerm(S)\)</span>,它又是一个映射（事实上是双射），它作用在<spanclass="math inline">\(s\in S\)</span>,会得到<spanclass="math inline">\(\phi_x(s)\in S\)</span>。整个过程实际上就是在<spanclass="math inline">\(G\)</span>中取出一个元素x，在<spanclass="math inline">\(S\)</span>中取出一个元素<spanclass="math inline">\(s\)</span>,也就是对应<spanclass="math inline">\(G\cross S\)</span>,得到一个<spanclass="math inline">\(S\)</span>中的元素，这一过程解释了在定义2中<spanclass="math inline">\(\sigma\)</span>为什么是<spanclass="math inline">\(G\cross S\rightarrow S\)</span>的映射。</p><h2 id="两个定义的联系">两个定义的联系</h2><p>下面我们来证明两个定义其实是等价的：</p><p><font color='orange'><strong>证明:</strong></font></p><p>定义1$$定义2：</p><p>首先<span class="math inline">\(\phi\)</span>确实是<spanclass="math inline">\(G\cross S\rightarrowS\)</span>的映射，我们定义双射 <span class="math display">\[\phi_a: S\rightarrow S\\(a,x)\mapsto a\cdot x,a\in G,x\in S\\\]</span> 则： <span class="math display">\[\forall x\in S,e\cdot x=\phi_e(x)=Id(x)=x,故第一条得证\\\forall a,b\inG,(ab)\cdot x=\phi_{ab}(x)=(\phi_a\circ\phi_b)(x)=\phi_a(\phi_b(x))=\phi_a(b\cdot x)=a\cdot(b\cdotx)\\从而第二条得证\]</span> 定义2<spanclass="math inline">\(\rightarrow\)</span>定义1：</p><p>还是定义 <span class="math display">\[\phi: G\rightarrow Perm(S)\\x\mapsto\phi_x\\其中\phi_x: S\rightarrow S\\s\mapsto x\cdot s,s\in S\]</span> 首先证明<spanclass="math inline">\(\phi_x\)</span>确实是一个双射： <spanclass="math display">\[x\cdot(x^{-1}\cdot s)=(xx^{-1})\cdot s=e\cdot s= s\\x^{-1}\cdot(x\cdots)=(x^{-1}x)\cdot s=e\cdot s= s\]</span> 故<spanclass="math inline">\((\phi_x)^{-1}=\phi_{x^{-1}}\)</span>,所以它确实是一个双射。这一结论是由性质1保证的，因为<spanclass="math inline">\(e\cdot s=s\)</span></p><p>而由性质2，我们知道<spanclass="math inline">\(\phi\)</span>保持运算，所以<spanclass="math inline">\(\phi\)</span>是一个<spanclass="math inline">\(G\rightarrow Perm(S)\)</span>的群同态，所以<spanclass="math inline">\(\phi\)</span>就是群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(S\)</span>上的作用 <spanclass="math inline">\(\square\)</span></p><p>所以第一条性质是为了保证良定义，第二条性质是为了保证群同态，两者合在一起就是对群作用的定义</p><p>这样我们对一个映射就有了判断的条件了，也认识到了其优美的同态性质</p><blockquote><p>同时，如果我们认识到了群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(S\)</span>上有一个群作用 <spanclass="math display">\[(a,x)\mapsto a\cdot x,a\in G,x\in S\]</span> 那么 <span class="math display">\[\phi:G\rightarrow Perm(S)\\x\mapsto a\cdot x\]</span> 就一定是群<span class="math inline">\(G\)</span>到集合<spanclass="math inline">\(S\)</span>的群同态，以及 <spanclass="math display">\[\forall a\in G,\phi_a是S\rightarrow S的双射\]</span> <font color='red'>（当然<spanclass="math inline">\(\phi_a\)</span>不一定是群同态）</font></p></blockquote><h2 id="群作用的核">群作用的核</h2><p>群作用的核定义为定义1中同态<spanclass="math inline">\(\phi\)</span>的核，即<spanclass="math inline">\(Ker\phi\)</span></p><p>故 <span class="math display">\[a\in G是群作用的核\\\Leftrightarrow \phi_a=Id\\ \Leftrightarrow\phi_a(x)=x,\forall x\in S \\\Leftrightarrow a\cdot x=x,\forall x\in S\]</span></p><h2 id="群作用的例子">群作用的例子</h2><p>我们重新审视一下开头讲的例子</p><h3 id="群g在集合g上的左平移">群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(G\)</span>上的左平移</h3><p>令 <span class="math display">\[G\cross G\rightarrow G\\x\mapsto ax      (1)\]</span> 显然有 <span class="math display">\[ex=x,\forall x\in G\\(ab)x=a(bx),\forall a,b\in G,\forall x\in G\]</span> 所以<spanclass="math inline">\((1)\)</span>式给出了一个群作用。这里我们用定义2重新证明了这是一个群作用。</p><p>我们考察一下这个群作用的核 <span class="math display">\[a\in G属于群作用的核\\\Leftrightarrow ax=x,\forall x\inG\\\Leftrightarrow a=e\]</span> 故群作用的核为<spanclass="math inline">\(\{e\}\)</span>,所以<spanclass="math inline">\(\phi:G\rightarrowPerm(G)\)</span>是一个单同态。那么显然<span class="math inline">\(G\congIm\phi\)</span>。又<spanclass="math inline">\(Im\phi&lt;Perm(G)\)</span>,所以群<spanclass="math inline">\(G\)</span>与集合<spanclass="math inline">\(G\)</span>上的一个变换群同构！</p><p>如此我们很轻松地就证明了<spanclass="math inline">\(Cayley\)</span>定理：任意一个群都同构于某一个集合上的变换群</p><p>推论：<font color='blue'>任意一个<strong>有限群</strong>都同构于一个<strong>置换群</strong></font></p><hr /><h3 id="群g在集合g上的共轭作用">群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(G\)</span>上的共轭作用</h3><p>令 <span class="math display">\[G\cross G\rightarrow G\\x\mapsto axa^{-1}      (2)\]</span> 显然有 <span class="math display">\[exe^{-1}=x,\forall x\in G\\(ab)\cdot x=abxb^{-1}a^{-1}=a\cdot(bxb^{-1})=a\cdot(b\cdot x)\]</span> 故<spanclass="math inline">\((2)\)</span>式同样给出了一个群作用，叫做群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(G\)</span>上的共轭作用</p><p>考察该作用的核 <span class="math display">\[a\in G属于群作用的核\\\Leftrightarrow axa^{-1}=x\\\Leftrightarrowax=xa\\ \Leftrightarrowa\in \{b\in G|bx=xb,\forall x\in G\}=Z(G)\]</span> 这里<span class="math inline">\(Z(G)\)</span>称为群<spanclass="math inline">\(G\)</span>的中心。得到<spanclass="math inline">\(Ker\phi=Z(G)\)</span>。</p><p>这里共轭作用比左乘作用的性质要更好一些，因为实际上对于一个作用来说，根据我们之前所说，<span class="math display">\[\phi_a: G\rightarrow G\\x\mapsto axa^{-1}(3)\]</span></p><p>一定是双射，但是却未必是群同态，而共轭作用的每一个<spanclass="math inline">\(\phi_x\)</span><font color='red'>都是一个群同态</font>，从而<font color='red'>都是群同构</font></p><p><strong><font color='orange'>证明：</font></strong></p><p>因为<spanclass="math inline">\(\phi_a\)</span>都是双射，我们只需证明它是群同态即可（不是说<spanclass="math inline">\(\phi\)</span>是群同态，而是对每一个<spanclass="math inline">\(\phi_a\)</span>都是群同态） <spanclass="math display">\[\forall y,z\inG,\phi_a(yz)=a(yz)a^{-1}=aya^{-1}aza^{-1}=\phi_a(y)\phi_a(z)\]</span> 这就证明了共轭作用下每一个<spanclass="math inline">\(\phi_a\)</span>都是<strong>群<spanclass="math inline">\(G\)</span>到自身</strong>的群同构 <spanclass="math inline">\(\square\)</span></p><p>我们称群<spanclass="math inline">\(G\)</span>到自身的同构映射为自同构(automorphism),而由<spanclass="math inline">\((3)\)</span>式定义的同构称为内自同构(innerautomorphism) <span class="math display">\[f是群G的内自同构\Leftrightarrow f是G的共轭作用给出的一个自同构\]</span></p><p>然后我们来研究一些更加深入的东西</p><h2 id="轨道-稳定化子定理">轨道-稳定化子定理</h2><h3 id="轨道">轨道</h3><p>令 <span class="math display">\[\phi:G\rightarrow Perm(s)\\\phi_a(x)=a\cdot x\]</span> 是一个群作用</p><p>那么定义<span class="math inline">\(s\in S\)</span>的轨道<spanclass="math inline">\(Orb(s)\)</span>为 <span class="math display">\[Orb(s)=\{s&#39;\in S|\exist x\in G,xs&#39;=s\}=\{xs|x\in G\}\]</span> 也就是<span class="math inline">\(s\)</span>在所有<spanclass="math inline">\(x\)</span>的作用下能到达的点的集合。我们很快就能看到这个定义有什么用</p><blockquote><p>所有元素<span class="math inline">\(s\)</span>的轨道是集合<spanclass="math inline">\(S\)</span>的一个划分，即</p></blockquote><p><strong><font color='orange'>证明：</font></strong></p><p>定义集合<span class="math inline">\(S\)</span>上的一个二元关系 <spanclass="math display">\[y\sim x\Leftrightarrow \exist a\in G,y=a\cdot x\]</span> 不难验证<spanclass="math inline">\(\sim\)</span>是一个等价关系。所以它给出<spanclass="math inline">\(S\)</span>上的一个划分 <spanclass="math display">\[\begin{flalign}\forall x\in S,\bar{x}&amp;=\{y\in S|y\sim x\}\\&amp;=\{y\in S|\exista\in G,y=a\cdot x\}\\&amp;=\{a\cdot x|a\in G\}\\&amp;=Orb(x)\end{flalign}\\\]</span> <span class="math inline">\(\square\)</span></p><h3 id="一些杂谈">一些杂谈</h3><p>我们先来看看<span class="math inline">\(T\cross X\rightarrowX\)</span>的映射<spanclass="math inline">\(\phi\)</span>,当然它不一定满足群作用的性质，但是这个结构本身有很多值得研究的东西</p><p>不过我们不妨还是定义<span class="math inline">\((t,x)\mapsto t\cdotx\)</span></p><ul><li><p>令<span class="math inline">\(t\in T\)</span>，则集合 <spanclass="math display">\[\{x\in X|t\cdot x=x\}\]</span> 表示的是在变换t下不变的元素</p></li><li><p>令<span class="math inline">\(K\subset T\)</span>，则集合 <spanclass="math display">\[\{x\in X|\forall t\in K,t\cdot x=x\}\]</span> 表示的是在<spanclass="math inline">\(K\)</span>中所有变换<spanclass="math inline">\(t\)</span>下都保持不变的x的集合</p></li></ul><p>相对应的，我们以<spanclass="math inline">\(x\)</span>为主视角看看</p><ul><li><p>令<span class="math inline">\(x\in X\)</span>,则集合 <spanclass="math display">\[\{t\in T|t\cdot x=x\}\]</span> 表示的是固定了<spanclass="math inline">\(x\)</span>的所有变换t</p></li><li><p>令<span class="math inline">\(A\subset X\)</span>,则集合 <spanclass="math display">\[\{t\in T|\forall x\in A,t\cdot x=x\}\]</span> 表示的是固定了A中所有元素<spanclass="math inline">\(x\)</span>的t的集合</p></li></ul><p>事实上，只要给定了形如<span class="math inline">\(T\crossX\rightarrowX\)</span>的映射，我们都能很清晰地指出以上四个集合的内容</p><p>现在再回过头来看稳定化子。</p><h3 id="稳定化子">稳定化子</h3><p>定义<span class="math inline">\(s\in S\)</span>的稳定化子<spanclass="math inline">\(Stab(s)\)</span>为 <span class="math display">\[Stab(s)=\{x\in G|xs=s\}\]</span> 也就是固定了元素<spanclass="math inline">\(s\)</span>的所有<spanclass="math inline">\(x\)</span>,实际上也就是上文的第三个集合</p><blockquote><p>Stab(s)&lt;G</p></blockquote><p><strong><font color='orange'>证明：</font></strong></p><p><span class="math inline">\(\forall x,y\in Stab(s)\)</span>,有 <spanclass="math display">\[x\cdot s=y\cdot s=s\]</span> 从而<span class="math inline">\(x^{-1}\cdot s=x^{-1}\cdot(x\cdot s)=(x^{-1}x)\cdot s=e\cdot s=s\)</span>（关键步骤）</p><p>所以 <span class="math display">\[(yx^{-1})\cdot s=y(x^{-1}\cdot s)=y\cdot s=s\]</span> 故 <span class="math display">\[yx^{-1}\in Stab(s)\]</span> 从而<span class="math inline">\(Stab(s)&lt;G\)</span> <spanclass="math inline">\(\square\)</span></p><p><font color='red'>稍微总结一下我们就能看到一个很眼熟的东西</font></p><h4 id="引理1">引理1</h4><blockquote><p>令<span class="math inline">\(\phi:G\rightarrowPerm(S)\)</span>是一个群作用，则 <span class="math inline">\(\forallx,y\in G,s\in S,x\cdot s=y\cdot s\Leftrightarrow xy^{-1}\inStab(s)\)</span></p></blockquote><p>这与</p><blockquote><p>H&lt;G,则<span class="math inline">\(\forall x,y\inG,xH=yH\Leftrightarrow xy^{-1}\in H\)</span></p></blockquote><p>是很像的</p><p>现在我们知道<spanclass="math inline">\(Stab(s)\)</span>里的元素保持<spanclass="math inline">\(s\)</span>不变，我们还可以再探究一下其同一个陪集的元素对<spanclass="math inline">\(s\)</span>的作用</p><h4 id="引理2">引理2</h4><p><span class="math display">\[\begin{flalign}&amp;aStab(s)=bStab(s)\\&amp;\Leftrightarrow b^{-1}a\in Stab(s)\\&amp;由引理\\&amp;\Leftrightarrow a\cdot s=b\cdot s\end{flalign}\]</span></p><p>所以同一个陪集里的元素对<spanclass="math inline">\(s\)</span>的作用是一样的</p><p>从而我们令 <span class="math display">\[\phi:(G/Stab(s))_l\rightarrow Orb(s)\\ aStab(s)\mapsto a\cdot s\]</span> 那么从而我们可以通过引理2的正向推和逆向推得到<spanclass="math inline">\(\phi\)</span>的合理性以及单射的性质，又由于<spanclass="math inline">\(\phi\)</span>显然是一个满射，从而<spanclass="math inline">\(\phi\)</span>是一个<font color='red'><strong>双射！</strong></font></p><p>如次我们就证得了</p><h3 id="轨道-稳定化子定理-1">轨道-稳定化子定理</h3><blockquote><p>令<span class="math inline">\(\phi:G\rightarrowPerm(S)\)</span>是一个群作用，则<span class="math inline">\(\forall s\inS\)</span>,存在<span class="math inline">\((G/Stab(s))_l\)</span>到<spanclass="math inline">\(Orb(s)\)</span>的双射</p><p>从而<span class="math inline">\(|Orb(s)|=[G:Stab(s)]\)</span></p><p>若<span class="math inline">\(G\)</span>为有限群，则有<strong><spanclass="math inline">\(|G|=|Orb(s)|*|Stab(s)|\)</span></strong></p></blockquote><p>举一个形象的例子</p><p>二面体群 <spanclass="math inline">\(D_{2n}\)</span>，它是由所有正<spanclass="math inline">\(n\)</span>边形到自身的对称变换所构成的。对称变换,就是把<strong>自身映到自身</strong>，而且是保距的。保距指的是，原先距离相同的点，变换后距离仍然相同</p><blockquote><p><span class="math inline">\(|D_{2n}|=2n\)</span></p></blockquote><p><font color='orange'><strong>证明：</strong></font></p><p>首先正n边形有n个旋转变换，以及n个对称变换（绕n个对称轴分别翻转），这样就有<spanclass="math inline">\(2n\)</span>个元素了，我们要证明只有这些元素</p><p>任取正n边形的一个顶点<spanclass="math inline">\(s\)</span>,考虑其轨道<spanclass="math inline">\(Orb(s)\)</span>,最多只能到达n个顶点，而n个旋转变换就恰好可以让s到达n个不同顶点，所以<spanclass="math inline">\(|Orb(s)|=n\)</span></p><p>然后考虑<span class="math inline">\(Stab(s)\)</span>,我们要保持<spanclass="math inline">\(s\)</span>不变，不难发现只有两种变换满足要求，一个是恒等变换，另一个是绕s的对称轴翻转的变换，从而<spanclass="math inline">\(Stab(s)=2\)</span></p><p>所以<spanclass="math inline">\(|D_{2n}|=|Orb(s)|*|Stab(s)|=2n\)</span> <spanclass="math inline">\(\square\)</span></p>]]></content>
    
    
    <categories>
      
      <category>抽象代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>抽象代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Burnside 引理</title>
    <link href="/posts/bce2f7a6/"/>
    <url>/posts/bce2f7a6/</url>
    
    <content type="html"><![CDATA[<h1id="burnside引理pólya定理及其应用">Burnside引理,Pólya定理及其应用</h1><h2 id="burnside引理">Burnside引理</h2><p>书接上回，继续深入研究在群作用下集合的轨道与稳定子群的相关性质</p><p>现在我们想要研究这样一个问题： <span class="math display">\[有限群G在有限集合S上面有一个作用，那么S的G-轨道条数是多少\]</span> 也就是在有限群<spanclass="math inline">\(G\)</span>作用下集合<spanclass="math inline">\(S\)</span>的等价类的数量</p><p>不妨设<span class="math inline">\(S\)</span>有<spanclass="math inline">\(r\)</span>条<spanclass="math inline">\(G\)</span>-轨道条数，那么就有 <spanclass="math display">\[S=\bigcup_{i=1}^{r}Orb(x_i)\]</span> 其中<spanclass="math inline">\(x_i\)</span>就是每一条轨道的代表元。注意到任意两条轨道交集为空，所以<span class="math display">\[|S|=\bigcup_{i=1}^{r}|Orb(x_i)|=\bigcup_{i=1}^{r}\frac{|G|}{|Stab(x_i)|}\]</span>这里有点怪，它似乎暗示我们<strong>同一个轨道的元素的不变子群的阶都是一样的</strong>。我们再仔细研究一下</p><p><span class="math inline">\(\forall x,y\in S\)</span>,且<spanclass="math inline">\(x\)</span>,<spanclass="math inline">\(y\)</span>在同一条轨道里面，<spanclass="math inline">\(\exist a\in G,a\cdot x=y\)</span>。则 <spanclass="math display">\[\begin{flalign}&amp;h\in Stab(y)\Leftrightarrow h\cdot y=y\\ &amp;\Leftrightarrow h\cdot(a\cdot x)=a\cdot x\\ &amp;\Leftrightarrow (ha)\cdot x=a\cdot x\\ &amp;\Leftrightarrow a^{-1}\cdot ((ha)\cdot x)=(a^{-1}\cdot (a\cdotx))\\ &amp;\Leftrightarrow (a^{-1}ha)\cdot x=x\\ &amp;\Leftrightarrow a^{-1}ha\in Stab(x)\\ &amp;\Leftrightarrow h\in a^{-1}Stab(x)a\end{flalign}\]</span></p><p>注意到上述过程都是等价的，所以我们很快得到 <spanclass="math display">\[Stab(y)=a^{-1}Stab(x)a\]</span> <font color='green'>于是我们得到如下命题</font></p><blockquote><p>设有限群<span class="math inline">\(G\)</span>在有限集合<spanclass="math inline">\(S\)</span>上面有一个作用，那么同一个<spanclass="math inline">\(G\)</span>-轨道的点的稳定子群彼此共轭，从而它们彼此同构</p></blockquote><p>同构的群之间显然阶数相等，这也解答了我们刚刚的疑惑。</p><p>现在再来重新审视一个轨道<spanclass="math inline">\(Orb(x_i)\)</span>,其内部所有元素的稳定子群的阶是相同的，那么内部所有元素的稳定子群的阶数之和就会等于<span class="math display">\[\sum |Stab(x_i)|=|Stab(x_i)||Orb(x_i|=|G|\]</span>那么<font color='red'>集合内部所有元素的稳定子群的阶之和就会等于</font><span class="math display">\[\sum_{x\in S}|Stab(x)|=\sum_{i=1}^{r}|G|=r|G|\quad\quad\quad\quad\quad\quad(1)\]</span> 这启发我们用另一种方法来计算<spanclass="math inline">\(r\)</span>.只要能够得到<spanclass="math inline">\(\sum_{x\in S}|Stab(x)|\)</span>,再除以<spanclass="math inline">\(|G|\)</span>，就能得到<spanclass="math inline">\(r\)</span></p><hr /><p>我们考虑<span class="math inline">\(G\cross S\)</span>的一个子集<spanclass="math inline">\(K=\{(a,x)|a\cdot x=x\}\)</span>,</p><p>对于一个给定的<span class="math inline">\(x\in S\)</span>,以<spanclass="math inline">\(x\)</span>作为第二个值的有序对<spanclass="math inline">\((a,x)\)</span>的数量显然就是<spanclass="math inline">\(|Stab(x)|\)</span>,所以 <spanclass="math display">\[|K|=\sum_{x\in S}|Stab(x)|\]</span> 问题又转化成了求<spanclass="math inline">\(|K|\)</span>,不过我们离成功已经很近了。</p><p>事实上将问题转化成求<spanclass="math inline">\(|K|\)</span>是很有好处的，因为我们可以以<spanclass="math inline">\(x\)</span>为关键字来看待它，当然也可以以<spanclass="math inline">\(a\)</span>为关键字来看。如此，对于一个给定的<spanclass="math inline">\(a\in G\)</span>,所有以<spanclass="math inline">\(a\)</span>为第一个值的有序对对应的x组成一个集合<spanclass="math inline">\(F_a=\{x|a\cdot x=x\}\)</span>,我们记其为<spanclass="math inline">\(a\)</span>的不动点集</p><p>那么 <span class="math display">\[\sum_{x\in S}|Stab(x)|=|K|=\sum_{a\in G}|F_a|\]</span> 从而由<span class="math inline">\((1)\)</span>式可知 <spanclass="math display">\[r=\frac{\sum_{x\in S}|Stab(x)|}{|G|}=\frac{1}{|G|}\sum_{a\in G}|F_a|\]</span> <font color='green'>于是我们得到<spanclass="math inline">\(Burnside\)</span>引理如下：</font></p><blockquote><p>设有限群<span class="math inline">\(G\)</span>在有限集合<spanclass="math inline">\(S\)</span>上有一个群作用，那么<spanclass="math inline">\(S\)</span>的<spanclass="math inline">\(G\)</span>-轨道条数<spanclass="math inline">\(r\)</span>为 <span class="math display">\[r=\frac{1}{|G|}\sum_{a\in G}|F_a|\]</span></p></blockquote><p>这个引理的意义在于，原本单纯只跟集合<spanclass="math inline">\(S\)</span>有关的问题，我们可以借用群<spanclass="math inline">\(G\)</span>来解决了，而群<spanclass="math inline">\(G\)</span>在一些特定情况下有良好的性质能够帮助我们快速计算<spanclass="math inline">\(\sum_{a\in G}|F_a|\)</span></p><h3 id="应用">应用</h3><p>来个具体的例子</p><blockquote><p>给定一个大小为n的环，环上每一个点有m种染色方案。问总共可以染出多少个本质不同的环。这里环本质不同定义为无法通过旋转得到</p></blockquote><p>不妨记环上点的集合为<spanclass="math inline">\(B=\{b_1,b_2,...b_n\}\)</span>,染色方案集合为<spanclass="math inline">\(C=\{c_1,c_2,...c_m\}\)</span>,考虑集合 <spanclass="math display">\[S=B^C=\{X_i\},其中X_i=&lt;c_{i_1},c_{i_2},...c_{i_n}&gt;,1\leq i_j\leq m\]</span> <spanclass="math inline">\(S\)</span>的实际含义就是所有给<spanclass="math inline">\(B\)</span>中元素染色的方案的集合,每一个方案用一个n元排列表示,显然<spanclass="math inline">\(|S|=m^n\)</span></p><p>现在考虑在集合<span class="math inline">\(B\)</span>上的置换群<spanclass="math inline">\(Perm(B)\)</span>的子群<spanclass="math inline">\(G=\{\bigl(\begin{smallmatrix} 1 &amp; 2 &amp; ...&amp; n-1 &amp; n\\ 2 &amp; 3 &amp; ...&amp; n &amp; 1\end{smallmatrix}\bigr),\bigl(\begin{smallmatrix}  1&amp; 2 &amp; 3&amp; ... &amp; n-1 &amp; n\\ 3 &amp; 4&amp; ...&amp; n &amp; 1 &amp; 2\end{smallmatrix}\bigr),...,(1)\}\)</span>,其中<spanclass="math inline">\(G_i=\bigl(\begin{smallmatrix}  1&amp;2 &amp;3&amp;4&amp;... &amp; n-1 &amp; n\\  i+1&amp; i+2 &amp; ... &amp; n&amp; 1 &amp;...&amp;i \end{smallmatrix}\bigr)\)</span>。显然<spanclass="math inline">\(|G|=n\)</span>。此外不难证明<spanclass="math inline">\(G\)</span>确实是一个群，这里就不证了。</p><p><font color='red'><strong>至于为什么要这样定义，是因为<spanclass="math inline">\(G\)</span>中元素实际上代表的就是一个环的旋转（这一点不难发现）与题目给出的本质不同的定义相吻合。整个<spanclass="math inline">\(G\)</span>就恰好代表了环上的所有旋转操作，如果我们能证明有限群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(S\)</span>上有一个作用,那么本质不同的环的数量不就是<spanclass="math inline">\(S\)</span>的<spanclass="math inline">\(G\)</span>-轨道条数了吗，从而可以用<spanclass="math inline">\(Burnside\)</span>引理求解</strong></font></p><p>我们来证明有限群<span class="math inline">\(G\)</span>确实在集合<spanclass="math inline">\(S\)</span>上有一个作用</p><p><strong><font color='orange'>证明：</font></strong></p><p>考虑 <span class="math display">\[\phi:G\cross S\rightarrow S\\ (a,x)\mapsto a\cdot x\]</span> 这里<span class="math inline">\(a\)</span>是一个置换，<spanclass="math inline">\(x\)</span>是一个大小为<spanclass="math inline">\(n\)</span>的排列，那么此时<spanclass="math inline">\(a\cdot x\)</span>就是一个普通的置换在排列上的作用了，这样定义显然是合理的。</p><p>要证明<span class="math inline">\(G\)</span>在<spanclass="math inline">\(S\)</span>上有群作用，我们只需要证明 <spanclass="math display">\[e\cdot x=x,\forall x\in S\\ (a\circ b)\cdot x=a\cdot (b\cdot x)\]</span> 第一点非常显然，<spanclass="math inline">\(G\)</span>中的<spanclass="math inline">\(e\)</span>就是恒等变换，它作用在一个排列上显然保持不变</p><p>第二点其实就是置换的复合性质的描述，我们当然知道它是成立的</p><p>从而<span class="math inline">\(G\)</span>确实在<spanclass="math inline">\(S\)</span>上有一个群作用，那么我们就可以用<spanclass="math inline">\(Burnside\)</span>引理来处理这个问题了。 <spanclass="math inline">\(\square\)</span></p><p>我们要求本质不同的环的数量，也就是求<spanclass="math inline">\(S\)</span>的<spanclass="math inline">\(G\)</span>-轨道条数<spanclass="math inline">\(r\)</span>,从而 <span class="math display">\[r=\frac{1}{|G|}\sum_{a\in G}|F_a|=\frac{1}{n}\sum_{a\in G}|F_a|\]</span> 此时问题变成对于<spanclass="math inline">\(G\)</span>内的每一个置换，求其不动点集的阶</p><hr /><p>不妨来看个简单版本，我们就令<spanclass="math inline">\(n=4\)</span>。此时总共有4个置换，</p><ul><li><span class="math inline">\(a_1=\bigl(\begin{smallmatrix} 1 &amp; 2&amp; 3 &amp; 4 \\ 2 &amp; 3 &amp;4 &amp; 1\end{smallmatrix}\bigr)\)</span>,​此时显然需要<spanclass="math inline">\(x_i\)</span>内所有<spanclass="math inline">\(c_{i_j}\)</span>都相等，从而<spanclass="math inline">\(|F_{a_1}|=m\)</span></li><li><span class="math inline">\(a_2=\bigl(\begin{smallmatrix} 1 &amp; 2&amp; 3 &amp; 4 \\ 3 &amp; 4 &amp; 1 &amp; 2\end{smallmatrix}\bigr)\)</span>,<spanclass="math inline">\(1,3\)</span>是一组，<spanclass="math inline">\(2,4\)</span>是一组，所以<spanclass="math inline">\(|F_{a_2}|=m^2\)</span></li><li>同理可得<span class="math inline">\(|F_{a_3}|=m\)</span></li><li><span class="math inline">\(a_4=(1)\)</span>,每一个排列在<spanclass="math inline">\(a_4\)</span>作用下都保持不变，元素对应的颜色自然也不变，从而<spanclass="math inline">\(|F_{a_4}|=|S|=m^n\)</span></li></ul><p>从而<spanclass="math inline">\(r=\frac{1}{n}(m^n+2m+m^2)\)</span></p><hr /><p>但是当<spanclass="math inline">\(n\)</span>逐渐变大的时候,这种暴力枚举的方法将会变的寸步难行。这里再引入一个概念</p><h3 id="置换群的轮换指标">置换群的轮换指标</h3><p>置换型：如果<span class="math inline">\(n\)</span>元置换<spanclass="math inline">\(g\)</span>中有<spanclass="math inline">\(b_i\)</span>个长度为<spanclass="math inline">\(i\)</span>的轮换，那么<spanclass="math inline">\(g\)</span>的置换型为<spanclass="math inline">\({x_1}^{b_1}{x_2}^{b_2}...{x_n}^{b_n}\)</span>，其中<spanclass="math inline">\(\sum i*b_i=n\)</span>显然成立。这里<spanclass="math inline">\(x_i\)</span>只是一个形式</p><blockquote><p>设<span class="math inline">\((G,\circ)\)</span>是一个<spanclass="math inline">\(n\)</span>元置换群，那么它的轮换指标定义为 <spanclass="math display">\[P_G(x_1,x_2,...x_n)=\frac{1}{|G|}\sum_{g\inG}x_1^{b_1}x_2^{b_2}...x_{n}^{b_n}\]</span></p></blockquote><p><span class="math inline">\({x_i}^{b_i}\)</span>就表示在一个置换<spanclass="math inline">\(g\)</span>内有<spanclass="math inline">\(b_i\)</span>个<spanclass="math inline">\(i\)</span>-轮换，而对于一个轮换，其内所有点都是可以互相到达的，所以轮换内部的点的颜色一定得相同，从而这个轮换的染色方案就是<spanclass="math inline">\(m\)</span>,从而,对于置换<spanclass="math inline">\(g\)</span>,<spanclass="math inline">\(|F_g|=m^{b_1}m^{b_2}...m^{b_n}\)</span></p><p>从而 <span class="math display">\[r=\frac{1}{|G|}\sum_{a\in G}|F_a|=\frac{1}{|G|}\sum_{a\inG}x_1^{b_1}x_2^{b_2}...x_{n}^{b_n}=P_G(x_1,x_2,...x_n)\]</span> 现在问题就变成了求置换群<spanclass="math inline">\(G\)</span>的轮换指标</p><p>这里给出一些结论</p><h4 id="正n边形的旋转群的轮换指标">正n边形的旋转群的轮换指标</h4><p><span class="math display">\[P_G=\frac{1}{n}\sum_{d|n}\phi_d{x_d}^{\frac{n}{d}}\]</span></p><p>这其实就是我们刚刚在研究的问题</p><p>注意到正n边形的旋转群<span class="math inline">\(G\)</span>中，<spanclass="math inline">\(G_i\)</span>就表示旋转步长为<spanclass="math inline">\(i\)</span>的置换组成，我们有如下结论： <spanclass="math display">\[|F_{G_i}|=(n,i)\]</span> <strong><font color='orange'>证明：</font></strong></p><ul><li><span class="math inline">\(i|n\)</span>,每次走i步，<spanclass="math inline">\(n/i\)</span>次后回到原点，所以该置换可以拆成i个轮换，每一个轮换的阶为<spanclass="math inline">\(n/i\)</span>。显然有<spanclass="math inline">\(|F_{G_i}|=i=(n,i)\)</span></li><li><span class="math inline">\(i\nmid n\)</span>,每次走<spanclass="math inline">\(i\)</span>步，回到原点需要<spanclass="math inline">\(lcm(n,i)\)</span>次，从而每一个轮换的阶为<spanclass="math inline">\(lcm(n,i)/i\)</span>,那么<spanclass="math inline">\(|F_{G_i}|=n/(lcm(n,i)/i)=ni/lcm(n,i)=(n,i)\)</span></li></ul><p><span class="math inline">\(\square\)</span></p><p>未完待续</p>]]></content>
    
    
    <categories>
      
      <category>抽象代数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>抽象代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
