<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>各类基于决策单调性的dp优化</title>
    <link href="/2023/12/19/%E5%90%84%E7%B1%BB%E5%9F%BA%E4%BA%8E%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7%E7%9A%84dp%E4%BC%98%E5%8C%96/"/>
    <url>/2023/12/19/%E5%90%84%E7%B1%BB%E5%9F%BA%E4%BA%8E%E5%86%B3%E7%AD%96%E5%8D%95%E8%B0%83%E6%80%A7%E7%9A%84dp%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="基于决策单调性的dp优化">基于决策单调性的dp优化</h2><h3 id="对于决策单调性的一般解释">对于决策单调性的一般解释</h3><p>众所周知，dp中会有转移，每一个状态可能会有若干个状态转移而来。现在我们考虑一类较为特殊的dp，最优化dp，在其中每一个点只能从一个最优状态转移而来。在此基础上，如果随着dp顺序的推进，每一个点的最优转移点也是单调移动的，我们就称其具有决策单调性.</p><p>比如说，对于一个常见一维<spanclass="math inline">\(dp:dp_i=min/max\{dp_j+w(j,i)\}\)</span>,显然每一个点的dp值只能从<spanclass="math inline">\(\{j|j&lt;i\}\)</span>的<spanclass="math inline">\(dp_j\)</span>转移而来，我们记每一个点<spanclass="math inline">\(i\)</span>的最优决策转移点为<spanclass="math inline">\(p_i\)</span>.如果我们从1-n遍历i，<spanclass="math inline">\(p_i\)</span>也随之单调变化，那么这个dp就具有决策单调性了.大部分决策单调性体现在决策点单调递增，但是也有决策点单调递减的情况(都是建立在枚举的点是从小到大的情况下)</p><h3 id="关于决策单调性的证明">关于决策单调性的证明</h3><p>显然我们可以打表。只要暴力写一个dp，然后毛估估看一看转移点是否单调即可。当然还有其它更加稳妥的方式</p><p>该部分讲解如无特殊声明，都是建立在求<strong>最小化</strong>问题的基础上，如果要求最大化的话，要把对应不等号取反</p><h4 id="四边形不等式">四边形不等式</h4><h5 id="一维dp">一维dp</h5><p>对应方程形式<span class="math inline">\(F\)</span> :<spanclass="math inline">\(\largedp_i=min_{j&lt;i}\{dp_j+w(j,i)\}\)</span></p><p>我们考虑<span class="math inline">\(p_1\leq p_2\leq p_3\leqp_4\)</span></p><p>则<strong>最小化情况</strong>下的<strong>四边形不等式</strong>表示为：<spanclass="math inline">\(w(p_1,p_3)+w(p_2,p_4)\leqw(p_1,p_4)+w(p_2,p_3)\)</span></p><p>特别的，如果等号永远成立，称为<strong>四边形恒等式</strong></p><p>一般记为：<strong>交叉<spanclass="math inline">\(\leq\)</span>包含</strong></p><blockquote><p>定理1：如果对于dp式F,其w满足四边形不等式，则F满足决策单调性</p></blockquote><ul><li><p><span class="math inline">\(Proof:\)</span></p><p>反证法。记<spanclass="math inline">\(dp_i\)</span>的最优决策点为<spanclass="math inline">\(p_i\)</span>,假设<spanclass="math inline">\(y&lt;x\)</span>且<spanclass="math inline">\(p_x&lt;p_y\)</span>.根据<spanclass="math inline">\(F\)</span>的定义有：<spanclass="math inline">\(dp_x=dp_{p_x}+w(p_x,x)\leqdp_{p_y}+w(p_y,x)(1)\)</span></p><p>不难发现<spanclass="math inline">\(p_x&lt;p_y&lt;y&lt;x\)</span>,故由四边形不等式：<spanclass="math inline">\(w(p_x,y)+w(p_y,x)\leqw(p_x,x)+w(p_y,y)(2)\)</span></p><p><span class="math inline">\(1,2\)</span>两式相加得到:<spanclass="math inline">\(dp_{p_x}+w(p_x,y)\leqdp_{p_y}+w(p_y,y)\)</span></p><p>则对于<span class="math inline">\(y\)</span>来说，<spanclass="math inline">\(p_x\)</span>是一个比<spanclass="math inline">\(p_y\)</span>更优的决策点，与条件矛盾。</p><p>故<span class="math inline">\(y&lt;x\)</span>意味着<spanclass="math inline">\(p_y\leq p_x\)</span>，单调性得证</p></li></ul><h5 id="区间dp">区间dp</h5><p>一般来说高维dp的决策单调性体现在某一个维度，相对一维dp来说也会更加难发现，但是一种区间dp具有较好的性质</p><p>对应方程形式<span class="math inline">\(F\)</span> <spanclass="math inline">\(\large:dp_{i,j}=min_{k=i}^{j-1}\{dp_{i,k}+dp_{k+1,j}+w(i,j)\}\)</span></p><p>这里先介绍一个跟四边形不等式非常像的<strong>区间包含不等式</strong>：考虑<spanclass="math inline">\(p_1\leq p_2\leq p_3\leq p_4\)</span>,则<spanclass="math inline">\(w(p_1,p_4)\geq w(p_2,p_3)\)</span></p><blockquote><p>引理1：如果对于dp式F，其w同时满足四边形不等式以及区间包含不等式，则F也满足四边形不等式</p></blockquote><ul><li><p><span class="math inline">\(Proof:\)</span></p><p><ahref="https://oi-wiki.org/dp/opt/quadrangle/">我不会但是有人会</a></p></li></ul><blockquote><p>定理2：如果对于dp式F，其满足四边形不等式，记<spanclass="math inline">\(p_{i,j}为dp_{i,j}\)</span>的最优决策点，则<spanclass="math inline">\(\forall i&lt;j,p_{i,j-1}\leq p_{i,j}\leqp_{i+1,j}\)</span></p></blockquote><ul><li><p><span class="math inline">\(Proof:\)</span></p><p><ahref="https://oi-wiki.org/dp/opt/quadrangle/">不会+1但是有人会</a></p></li></ul><p>基于此，我们对于<spanclass="math inline">\(F\)</span>就能给出一个复杂度为<spanclass="math inline">\(O(n^2)\)</span>的优化。</p><p>如果在计算<span class="math inline">\(f_{i,j}\)</span>的同时记录<spanclass="math inline">\(p_{i,j}\)</span>，则对决策点<spanclass="math inline">\(K\)</span>的枚举量为<spanclass="math inline">\(\sum_{1\leq i&lt;j\leq n}p_{i+1,j}-p_{i,j-1}=\sum_{i=1}^{n}p_{i,n}-p_{1,i}\leq n^2\)</span></p><p>例题：</p><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=3506">HDU MonkeyParty</a></p><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=3516">HDU TreeConstruction</a></p><p>大致来说就是看到对应形式，证一下四边形不等式，包含不等式，然后套板子即可</p><p>这里给个Monkey Party的代码(幼年码风，不喜勿喷)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">2020</span>;<br>ll n;<br>ll mas[N];<br>ll dp[N][N];<br>ll s[N][N];<br>ll sum[N];<br><span class="hljs-function">ll <span class="hljs-title">w</span><span class="hljs-params">(ll l,ll r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> sum[r]-sum[l<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">while</span>(cin&gt;&gt;n)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;mas[i];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>+n;i&lt;=n+n;++i) mas[i]=mas[i-n];<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+n;++i) sum[i]=sum[i<span class="hljs-number">-1</span>]+mas[i];<br><span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dp);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n+n;++i) dp[i][i]=<span class="hljs-number">0</span>,s[i][i]=i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">2</span>;len&lt;=n;len++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*n-len+<span class="hljs-number">1</span>;i++)&#123;<br>                <span class="hljs-type">int</span> j=i+len<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=s[i][j<span class="hljs-number">-1</span>];k&lt;=s[i+<span class="hljs-number">1</span>][j];k++)&#123;<br>                    <span class="hljs-keyword">if</span>(dp[i][j]&gt;dp[i][k]+dp[k+<span class="hljs-number">1</span>][j]+sum[j]-sum[i<span class="hljs-number">-1</span>])&#123;<br>                        dp[i][j]=dp[i][k]+dp[k+<span class="hljs-number">1</span>][j]+sum[j]-sum[i<span class="hljs-number">-1</span>];<br>                        s[i][j]=k;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>ll ans=<span class="hljs-number">1e17</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>;l&lt;=n;++l)<br>&#123;<br>ans=<span class="hljs-built_in">min</span>(ans,dp[l][l+n<span class="hljs-number">-1</span>]);<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h5 id="一种二维dp">一种二维dp</h5><p>这一块存疑</p><p>也是一种非常常见的dp式<span class="math inline">\(f\)</span> <spanclass="math inline">\(:dp_{i,j}=min_{k&lt;i}\{dp_{k,j-1}+w(k,i)\}\)</span></p><p>按理说它跟上一块的区间dp是不同类型的，但是仿佛只要<spanclass="math inline">\(w\)</span>满足引理1，<spanclass="math inline">\(F\)</span>也有同样的结论。我没看到过严格证明，OIWIKI上也没找到对应介绍，但是大家好像都默认这是正确的，而且我目前也没找到反例...并不是很懂</p><p>反正用定理2来优化该dp的话，时间复杂度是<spanclass="math inline">\(O(n^2)\)</span>的</p><p>例题：</p><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=3480">HDUDivision</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll int</span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">10005</span>;<br>ll t,n,m;<br>ll dp[N][<span class="hljs-number">5010</span>];<br>ll mas[N];<br><span class="hljs-function">ll <span class="hljs-title">f</span><span class="hljs-params">(ll l,ll r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (mas[r]-mas[l])*(mas[r]-mas[l]);<br>&#125; <br>ll d[N][<span class="hljs-number">5010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;t;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> s=<span class="hljs-number">1</span>;s&lt;=t;++s)<br>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;mas[i];<br><span class="hljs-built_in">sort</span>(mas+<span class="hljs-number">1</span>,mas+<span class="hljs-number">1</span>+n);<br><span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dp);<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j)<br>&#123;<br>d[n+<span class="hljs-number">1</span>][j]=n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i;--i)<br>&#123;<br>ll tmp=<span class="hljs-number">0x3f3f3f3f</span>;<br>ll p;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=d[i][j<span class="hljs-number">-1</span>];k&lt;=d[i+<span class="hljs-number">1</span>][j];++k)<br>&#123;<br><span class="hljs-keyword">if</span>(tmp&gt;dp[k][j<span class="hljs-number">-1</span>]+<span class="hljs-built_in">f</span>(k+<span class="hljs-number">1</span>,i))<br>&#123;<br>tmp=dp[k][j<span class="hljs-number">-1</span>]+<span class="hljs-built_in">f</span>(k+<span class="hljs-number">1</span>,i);<br>p=k;<br>&#125;<br>&#125;<br>dp[i][j]=tmp;<br>d[i][j]=p;<br>&#125;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;Case &quot;</span>&lt;&lt;s&lt;&lt;<span class="hljs-string">&quot;: &quot;</span>&lt;&lt;dp[n][m]&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><h5 id="一些满足四边形不等式的函数类">一些满足四边形不等式的函数类</h5><ul><li>若<spanclass="math inline">\(w_{1(i,j)},w_{2(i,j)}\)</span>均满足四边形不等式（或区间包含不等式），则<spanclass="math inline">\(\forall c_1,c_2\geq 0\)</span>,<spanclass="math inline">\(c_1w_{1(i,j)}+c_2w_{2(i,j)}\)</span>也对应地满足四边形不等式（或区间包含不等式）</li><li>若存在函数<span class="math inline">\(f,g\)</span>，使得<spanclass="math inline">\(w_{l,r}=f_r-g_l\)</span>,则<spanclass="math inline">\(w\)</span>满足<strong>四边形恒等式</strong>（等号永远成立）。当<spanclass="math inline">\(f,g\)</span>单调增的时候，<spanclass="math inline">\(w\)</span>还满足区间包含不等式</li><li>设<spanclass="math inline">\(h_x\)</span>是一个单调增的下凸函数，若<spanclass="math inline">\(w\)</span>满足四边形不等式以及区间包含不等式，则<spanclass="math inline">\(h(w(x))\)</span>也满足四边形不等式以及区间包含不等式</li><li>设<span class="math inline">\(h_x\)</span>是一个下凸函数,若<spanclass="math inline">\(w\)</span>满足<strong>四边形恒等式</strong>以及区间包含不等式，则<spanclass="math inline">\(h(w(x))\)</span>满足四边形不等式</li></ul><p>具体证明详见<ahref="https://oi-wiki.org/dp/opt/quadrangle/">OIWIKI</a></p><p>这里以<a href="https://www.luogu.com.cn/problem/P1912">NOI 2009诗人小G</a>的dp递推式来试着用这些结论证一下决策单调性</p><p><span class="math inline">\(dp_i=min_{0\leqj&lt;i}\{dp_j+|s_i-s_j-1-L|^P\}\)</span>,其中<spanclass="math inline">\(s_i=i+\sum_{k=1}^{i}a_k\)</span>,<spanclass="math inline">\(a_k&gt;0\)</span>为常值</p><p>这里<spanclass="math inline">\(w_{j,i}=|s_i-s_j-1-L|^P\)</span>,我们不妨记<spanclass="math inline">\(m_{j,i}=s_i-s_j-1-L\)</span>,则<spanclass="math inline">\(w_{j,i}=|m_{j,i}|^P\)</span></p><p>我们考虑利用第2条结论：记<spanclass="math inline">\(f_i=s_i-1-L,g_i=s_i\)</span>,显然<spanclass="math inline">\(m_{j,i}=f_i-g_j\)</span>,故<spanclass="math inline">\(m_{j,i}\)</span>满足四边形不等式,又<spanclass="math inline">\(f_i,g_i\)</span>显然单增，故<spanclass="math inline">\(m_{j,i}\)</span>满足区间包含不等式</p><p>又函数<spanclass="math inline">\(|x|^P\)</span>显然是一个下凸函数，故由第4条结论可知，<spanclass="math inline">\(w_{j,i}=m_{j,i}\)</span>也满足四边形不等式。再由定理1，该dp式满足决策单调性。证毕。</p><p>可以看到如果式子能记住的话，在面对一些比较复杂的递推式的时候能够较从容地推出决策单调性，如果直接用四边形不等式的定义硬证这题的话，还是需要不少分类讨论和强大的推柿子能力的（啊...只会套公式的屑）</p><h4 id="与图形相结合">与图形相结合</h4><p>来自一位大佬的<ahref="https://www.luogu.com.cn/problem/solution/P1912">奇妙讨论</a>,从另一个视角帮助我们理解了决策单调性</p><p>这里讨论一维最优化dp，也就是<span class="math inline">\(F\)</span><span class="math inline">\(:dp_i=min_{j\leqi}\{dp_j+w(j,i)\}\)</span></p><p>决策单调性意味着决策点是单调的，换句话说，每一个点能够作为最优决策点的范围是一段连续区间</p><p><img src="https://s2.loli.net/2023/12/19/Ju8HYI5Z7Ge3hcb.png" alt="image-20230904215014871" style="zoom:100%;" /></p><p>在绿色区间内的点都是被<spanclass="math inline">\(dp_{j_1}\)</span>更新，在黄色区间内的点都是被<spanclass="math inline">\(dp_{j_2}\)</span>更新，不会出现黄色区间内有某个点是被<spanclass="math inline">\(dp_{j_1}\)</span>更新的情况，否则就违背了决策单调性的定义</p><p>从几何视角来看这一事实。我们考虑<spanclass="math inline">\(g_j(i)\)</span>，表示<spanclass="math inline">\(dp_j+w(j,i)\)</span>,则<spanclass="math inline">\(dp_i\)</span>可以重新表示为<spanclass="math inline">\(dp_i=min_{j\leqi}\{g_j(i)\}\)</span>。我们可以将<spanclass="math inline">\(g_j(i)\)</span>看成<spanclass="math inline">\(j\)</span>为常值，<spanclass="math inline">\(i\)</span>为自变量的一个函数，那么<spanclass="math inline">\(dp_i\)</span>本质上就是在所有函数<spanclass="math inline">\(g_j(i)\)</span>里取最小值来转移</p><p>还是以上图为例，绿色区间内的点对应函数<spanclass="math inline">\(g_{j_1}(i)\)</span>,黄色区间内对应函数<spanclass="math inline">\(g_{j_2}(i)\)</span>,我们可以得到一个结论：两个函数只能有一个交点，否则就会出现前一段是<spanclass="math inline">\(g_{j_1}(i)\)</span>更小,中间是<spanclass="math inline">\(g_{j_2}(i)\)</span>,后面又变成<spanclass="math inline">\(g_{j_1}(i)\)</span>更小的局面，那就违背了决策单调性的定义。反过来，如果只有一个交点的话，这两段区间就满足决策单调性</p><p>整体来看，我们可以得到：<strong>如果所有<spanclass="math inline">\(g_j(i)\)</span>两两之间都至多只有一个交点的话，<spanclass="math inline">\(F\)</span>是满足决策单调性的</strong>。个人感觉该命题的逆命题并不成立，毕竟实际在转移的时候只用考虑最小值的变化，值较大的函数之间是如何纠缠的我们并不关系。所以该结论应该只适用于证明决策单调性，而不能证否决策单调性</p><p>接下来我们考虑，如果<spanclass="math inline">\(g_j(i)\)</span>之间至多只有一个交点，需要满足什么性质</p><p>该大佬给出的两个条件是：</p><ul><li><spanclass="math inline">\(g_j(i)\)</span>之间可以通过平移相互变换</li><li><spanclass="math inline">\(g_j(i)\)</span>的导函数在定义域内单调增/减（凸性唯一）</li></ul><p>以下分别是不满足对应条件的反例</p><p><img src="https://s2.loli.net/2023/12/19/xuIRkf4nhUZlaJr.png" alt="image-20230904215014871" style="zoom:100%;" /></p><p><img src="https://s2.loli.net/2023/12/19/uT5wJd3liy2AYzs.png" alt="image-20230904215014871" style="zoom:100%;" /></p><p>这两个条件不一定充分，只是感觉上可能也够了</p><p>然后大佬给出的一些总结：</p><ul><li><p>如果导函数递增，求最大值，或导函数递减，求最小值用单调栈</p></li><li><p>如果导函数递增，求最小值，或导函数递减，求最大值用单调队列</p></li></ul><p>具体怎么用单调栈，单调队列，我会在后面有所涉及</p><h3 id="决策单调性的常见优化手段">决策单调性的常见优化手段</h3><h4 id="二分队列">二分队列</h4><p>这应该算是最常见的一种利用决策单调性来优化dp的手段了。它只能用于决策点单调增的情况。</p><p>考虑之前的一个结论：每一个决策点的更新范围是一段连续区间。这意味着相邻两个决策点的更新范围之间存在着一个分界线<spanclass="math inline">\(K\)</span>,当<spanclass="math inline">\(i&lt;=k\)</span>的时候，由前一个点<spanclass="math inline">\(j_1\)</span>更新，之后就由后一个点<spanclass="math inline">\(j_2\)</span>更新,并且<spanclass="math inline">\(j_1\)</span>就再也没有机会了。那么我们就可以维护一个单调队列来实现每次<spanclass="math inline">\(O(logn)\)</span>的更新</p><p>具体来说，我们的单调队列中的每一个元素是一个三元组<spanclass="math inline">\(\{P,l_p,r_p\}\)</span>,分别表示当前的决策点<spanclass="math inline">\(P\)</span>,它能更新区间的左界<spanclass="math inline">\(l_p\)</span>,它能更新区间的右界<spanclass="math inline">\(r_p\)</span>。那么当我们尝试更新<spanclass="math inline">\(dp_i\)</span>的时候，</p><ul><li><p>弹出队头。因为队列里的点的对应决策区间是单调的，所以我们可以直接将<spanclass="math inline">\(r_p&lt;i\)</span>的队头三元组不断弹出。</p></li><li><p>用队头的<span class="math inline">\(P\)</span>更新<spanclass="math inline">\(dp_i\)</span></p></li><li><p>将三元组<spanclass="math inline">\(\{i,l_i,r_i\}\)</span>放入队列尾部。那么怎么求<spanclass="math inline">\(l_i,r_i\)</span>?在求<spanclass="math inline">\(l_i\)</span>之前，我们要意识到一个事实：我们所求的<spanclass="math inline">\(l_p,r_p\)</span>都是建立在已经遍历到的点的信息上而建立的，换句话说，随着后面新的点<spanclass="math inline">\(i\)</span>加入，它的决策区间有可能会完全包含某一个点<spanclass="math inline">\(P\)</span>的决策区间。这一点很好理解：原本<spanclass="math inline">\(l_i,r_i\)</span>就是由<spanclass="math inline">\(i\)</span>更新的，但是因为我们还没有遍历到<spanclass="math inline">\(i\)</span>,所以这段区间就会先被其它点占据。所以我们在求<spanclass="math inline">\(l_i\)</span>之前，要先将队尾那些完全不会比<spanclass="math inline">\(i\)</span>优的点踢出。具体如何判断？我们只要看一下在<spanclass="math inline">\(l_p\)</span>处<spanclass="math inline">\(i\)</span>是否比<spanclass="math inline">\(P\)</span>更优即可。如果是，显然<spanclass="math inline">\(P\)</span>就再也没有机会比<spanclass="math inline">\(i\)</span>更优了，因为<spanclass="math inline">\(p&lt;i\)</span>。</p><p>该操作之后<span class="math inline">\(i\)</span>就不能将队尾的<spanclass="math inline">\(P\)</span>的区间完全覆盖了，我们就可以利用单调性二分一下两者的决策区间的边界，作为<spanclass="math inline">\(l_i\)</span>.至于<spanclass="math inline">\(r_i\)</span>,我们直接设成<spanclass="math inline">\(n\)</span>即可。毕竟此时后面的点还没加入，我们只能用<spanclass="math inline">\(i\)</span>来更新它们。</p></li></ul><p>贴个模板</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs stata">void Optimize()<br>&#123;<br>    <span class="hljs-comment">//该模板适用于最小化问题，若求最大化，自行将对应不等号取反即可</span><br>    <span class="hljs-comment">//cal()</span><br>    hd=1,tl=0;<br>    <span class="hljs-keyword">que</span>[++tl]=0;<span class="hljs-keyword">ls</span>[0]=1,rs[0]=<span class="hljs-keyword">n</span>;<br>    <span class="hljs-keyword">for</span>(int i=1;i&lt;=<span class="hljs-keyword">n</span>;++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;rs[<span class="hljs-keyword">que</span>[hd]]&lt;i) hd++;<span class="hljs-comment">//弹出无用点</span><br>        dp[i]=cal(<span class="hljs-keyword">que</span>[hd],i);<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;cal(i,<span class="hljs-keyword">ls</span>[<span class="hljs-keyword">que</span>[tl]])&lt;=cal(<span class="hljs-keyword">que</span>[tl],<span class="hljs-keyword">ls</span>[<span class="hljs-keyword">que</span>[tl]])) tl--;<span class="hljs-comment">//弹出无用点，若要求最大这里要改方向</span><br>        ll <span class="hljs-keyword">l</span>=<span class="hljs-keyword">ls</span>[<span class="hljs-keyword">que</span>[tl]],r=<span class="hljs-keyword">n</span>+1;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">l</span>&lt;=r)<br>        &#123;<br>            ll mid=(<span class="hljs-keyword">l</span>+r)&gt;&gt;1;<br>            <span class="hljs-keyword">if</span>(cal(i,mid)&lt;=cal(<span class="hljs-keyword">que</span>[tl],mid)) r=mid-1;<span class="hljs-comment">//若要求最大这里要改方向</span><br>            <span class="hljs-comment">//二分查找i与que[tl]的转移分界点，也就是最小的满足i优于que[tl]的点</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">l</span>=mid+1;<br>        &#125;<br>        p_ans=r+1;<br>        <span class="hljs-keyword">if</span>(p_ans&gt;<span class="hljs-keyword">n</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//i并没有用</span><br>        rs[<span class="hljs-keyword">que</span>[tl]]=p_ans-1;<br>        <span class="hljs-keyword">que</span>[++tl]=i;<span class="hljs-comment">//插入队列</span><br>        <span class="hljs-keyword">ls</span>[i]=p_ans,rs[i]=<span class="hljs-keyword">n</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Tips:二分决策区间边界的时候，右界设置为n+1,因为i有可能完全不如P优，要防一手</p></blockquote><p>如果<span class="math inline">\(w(j,i)\)</span>我们能够以<spanclass="math inline">\(O(1)\)</span>的复杂度求出的话，该方法的时间复杂度式<spanclass="math inline">\(O(nlog)\)</span>的</p><p>例题：</p><p><a href="https://www.luogu.com.cn/problem/P1912">NOI 2009诗人小G</a></p><p>dp式并不难列出，关于其决策单调性我们已经在上一块里证明过了，所以这里直接用二分队列即可</p><p>数据范围有点大，记得开long double</p><p>code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ld long double</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IL inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">100010</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">998244353</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> X=<span class="hljs-number">0</span>; <span class="hljs-type">bool</span> flag=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">0</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="hljs-number">1</span>)+(X&lt;&lt;<span class="hljs-number">3</span>)+ch-<span class="hljs-string">&#x27;0&#x27;</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> X;<br>    <span class="hljs-keyword">return</span> ~(X<span class="hljs-number">-1</span>);<br>&#125;<br><span class="hljs-type">int</span> n,L,P;<br><span class="hljs-type">char</span> s[N][<span class="hljs-number">50</span>];<br>ld mas[N];<br><span class="hljs-type">int</span> ls[N],rs[N],pre[N];<span class="hljs-comment">//记录最优决策点</span><br><span class="hljs-type">int</span> que[N];<br><span class="hljs-type">int</span> hd,tl,p_ans;<br>ld dp[N];<br><span class="hljs-function">ld <span class="hljs-title">ksm</span><span class="hljs-params">(ld x,ll y)</span></span><br><span class="hljs-function"></span>&#123;<br>    ld ans=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(y)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>) ans=ans*x;<br>        x=x*x;<br>        y&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function">ld <span class="hljs-title">cal</span><span class="hljs-params">(ll k,ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> dp[k]+<span class="hljs-built_in">ksm</span>(<span class="hljs-built_in">abs</span>(mas[x]-mas[k]<span class="hljs-number">-1</span>-L),P);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    n=<span class="hljs-built_in">read</span>();L=<span class="hljs-built_in">read</span>();P=<span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,s[i]);<br>    <span class="hljs-comment">// for(int i=1;i&lt;=n;++i) cin&gt;&gt;s[i];</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        mas[i]=mas[i<span class="hljs-number">-1</span>]+<span class="hljs-built_in">strlen</span>(s[i])+<span class="hljs-number">1</span>;<br>    &#125;<br>    hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>    que[++tl]=<span class="hljs-number">0</span>;ls[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>,rs[<span class="hljs-number">0</span>]=n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;rs[que[hd]]&lt;i) hd++;<br>        dp[i]=<span class="hljs-built_in">cal</span>(que[hd],i);<br>        pre[i]=que[hd];<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">cal</span>(i,ls[que[tl]])&lt;=<span class="hljs-built_in">cal</span>(que[tl],ls[que[tl]])) tl--;<br>        ll l=ls[que[tl]],r=n+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;=r)<br>        &#123;<br>            ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cal</span>(i,mid)&lt;=<span class="hljs-built_in">cal</span>(que[tl],mid)) r=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-comment">//二分查找i与que[tl]的转移分界点，也就是最小的满足i优于que[tl]的点</span><br>            <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        p_ans=r+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(p_ans&gt;n) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//i并没有用</span><br>        rs[que[tl]]=p_ans<span class="hljs-number">-1</span>;<br>        que[++tl]=i;<span class="hljs-comment">//插入队列</span><br>        ls[i]=p_ans,rs[i]=n;<br>    &#125;<br>    <span class="hljs-comment">///////</span><br><br>    <span class="hljs-keyword">if</span>(dp[n]&gt;inf)<br>    &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Too hard to arrange&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,(ll)dp[n]);<br>        vector&lt;string&gt; ans;<br>        ll pos=n;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>        &#123;<br>            ll x=pre[pos]+<span class="hljs-number">1</span>;<br>            string ss=<span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;pos;++i) ss+=s[i],ss+=<span class="hljs-string">&quot; &quot;</span>;<br>            ss+=s[pos];<br>            ans.<span class="hljs-built_in">push_back</span>(ss);<br>            pos=pre[pos];<br>            <span class="hljs-keyword">if</span>(pos==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(),ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:ans) cout&lt;&lt;i&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;--------------------&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);</span><br>    ll t;t=<span class="hljs-built_in">read</span>();<span class="hljs-keyword">while</span>(t--)<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二分栈">二分栈</h4><p>一般用于最优决策点是不增的情况。在原本的二分队列的做法中，我们从队列的首部取出最优决策点，从队列的尾部放入决策点。那么如果决策点是不增的，意味着我们需要从队列的尾部取最优决策点。这样取和放的操作都是在队列的尾部，我们只要用一个栈来实现就好了。同样的，相邻的两个决策点更新的区间会有一个边界，我们不妨记为<spanclass="math inline">\(k_{l,r}\)</span>,当尝试加入<spanclass="math inline">\(i\)</span>的时候，记队列倒数第一个元素为<spanclass="math inline">\(p_1\)</span>,倒数第二个元素为<spanclass="math inline">\(p_2\)</span>,那么如果<spanclass="math inline">\(k_{p_1,p_2}\leq k_{p_2,i}\)</span>,那么<spanclass="math inline">\(p_2\)</span>就可以踢掉了，因为它不管在什么时候都不会是<spanclass="math inline">\(i,p_1,p_2\)</span>中的最优解。然后将<spanclass="math inline">\(i\)</span>加入队列之后再按照<spanclass="math inline">\(k_{p_1,p_2}\)</span>是否<spanclass="math inline">\(\leq i\)</span>来踢即可</p><p><a href="https://www.luogu.com.cn/problem/P5504">JSOI2001柠檬</a></p><p>思路：</p><p>首先不难发现最优选择下每一段的首尾的颜色就是这段的<spanclass="math inline">\(s_0\)</span>，否则我们就可以将首尾的没用的点分出去自称一段，贡献一定更优</p><p>所以我们可以按照不同的颜色来分开处理</p><p><span class="math inline">\(dp_i=max_{col_j=col_i,j\leqi}\{dp_{j-1}+w(j,i)\}\)</span>,其中<spanclass="math inline">\(w(j,i)=(sum_i-sum_j+1)^2\)</span></p><p>这里我们画图就能发现决策点是单调不增的（按照上文与图形结合的方法），所以可以使用二分栈。但是这题的决策单调性是在相同颜色的点之间才存在的，所以我们要分开来做二分栈</p><p>然后每一个点不会从0转移，所以一开始也不用把0放进去</p><p>code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> il inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bc(idx) vt[idx].size()-1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> bd(idx) vt[idx].size()-2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> g(a,b) vt[a][b]</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">200000</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br>ll n;<br>ll mas[N];<br>vector&lt;ll&gt; vt[N];<br>ll dp[N];<br>ll ls[N],rs[N];<br>map&lt;ll,ll&gt; mp;<br>ll sum[N];<br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll k,ll num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> dp[k<span class="hljs-number">-1</span>]+mas[k]*num*num;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">gtf</span><span class="hljs-params">(ll a,ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll l=<span class="hljs-number">1</span>,r=n;<br>    <span class="hljs-keyword">while</span>(l&lt;=r)<br>    &#123;<br>        ll mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(a,mid-sum[a]+<span class="hljs-number">1</span>)&gt;=<span class="hljs-built_in">gt</span>(b,mid-sum[b]+<span class="hljs-number">1</span>)) r=mid<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;mas[i];<br>        mp[mas[i]]++;<br>        sum[i]=mp[mas[i]];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        ll idx=mas[i];<br>        <span class="hljs-keyword">while</span>(vt[idx].<span class="hljs-built_in">size</span>()&gt;=<span class="hljs-number">2</span>&amp;&amp; <span class="hljs-built_in">gtf</span>(<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bd</span>(idx)),<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bc</span>(idx)))&lt;=<span class="hljs-built_in">gtf</span>(<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bc</span>(idx)),i)) vt[idx].<span class="hljs-built_in">pop_back</span>();<br>        vt[idx].<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">while</span>(vt[idx].<span class="hljs-built_in">size</span>()&gt;=<span class="hljs-number">2</span>&amp;&amp; <span class="hljs-built_in">gtf</span>(<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bd</span>(idx)),<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bc</span>(idx)))&lt;=sum[i]) vt[idx].<span class="hljs-built_in">pop_back</span>();<br>        dp[i]=<span class="hljs-built_in">gt</span>(<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bc</span>(idx)),sum[i]-sum[<span class="hljs-built_in">g</span>(idx,<span class="hljs-built_in">bc</span>(idx))]+<span class="hljs-number">1</span>);<br>    &#125;<br>    cout&lt;&lt;dp[n]&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="分治">分治</h4><p>分治的方法主要用于同一层之间的点相互之间线性无关的情况。</p><p>比如<span class="math inline">\(F_1\)</span> <spanclass="math inline">\(:dp_{i,j}=min\{dp_{i-1,k}+w(k,i)\}\)</span>.<spanclass="math inline">\(F_2\)</span> <spanclass="math inline">\(:dp_i=min\{a_k+w(k,i)\}\)</span></p><p>可以看到同一层之间的点不会相互转移</p><p>那么如果同一层的点满足决策单调性的话，也就是意味着决策点是单调的，我们就可以采用分治的策略来优化转移的过程</p><p>假设当前需要转移的区间是<spanclass="math inline">\([L,R]\)</span>,决策点的选择区间是<spanclass="math inline">\([p_l,p_r]\)</span>(显然一开始转移区间和决策点的选择区间都为<spanclass="math inline">\([1,n]\)</span>)，设<spanclass="math inline">\(mid=\frac{L+R}{2}\)</span>,我们可以先暴力求出<spanclass="math inline">\(mid\)</span>的最优决策点<spanclass="math inline">\(pos\)</span>,那么<spanclass="math inline">\([L,mid-1]\)</span>的决策点选择区间就是<spanclass="math inline">\([p_l,pos]\)</span>,<spanclass="math inline">\([mid+1,R]\)</span>的决策点选择区间就是<spanclass="math inline">\([pos,p_r]\)</span>，那么这样分治下去就好了。</p><p>如果我们可以<spanclass="math inline">\(O(1)\)</span>求代价的话，对<spanclass="math inline">\(mid\)</span>求<spanclass="math inline">\(pos\)</span>的时间复杂度就只有<spanclass="math inline">\(O(n)\)</span>,再加上每次要处理的区间长度会变成原本的一半，所以处理区间为n的复杂度是<spanclass="math inline">\(f(n)=O(n)+O(f(n/2))\)</span>,总复杂度是<spanclass="math inline">\(O(nlogn)\)</span></p><p>一个板子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solve</span><span class="hljs-params">(ll l,ll r,ll pl,ll pr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//当前分治处理区间是[l,r],最佳决策区间是[pl,pr]</span><br>ll mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br>ll pos;<span class="hljs-comment">//mid的最佳决策点</span><br>dp[mid]=<span class="hljs-built_in">gt</span>(pos=pl,mid);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pl+<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">min</span>(mid<span class="hljs-number">-1</span>,pr);++i)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(i,mid)&lt;dp[mid]) dp[mid]=<span class="hljs-built_in">gt</span>(pos=i,mid);<br>&#125;<br><span class="hljs-keyword">if</span>(l&lt;mid) <span class="hljs-built_in">Solve</span>(l,mid<span class="hljs-number">-1</span>,pl,pos);<br><span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">Solve</span>(mid+<span class="hljs-number">1</span>,r,pos,pr);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P5503">JSOI2016灯塔</a></p><p>大意：</p><p>给定<span class="math inline">\(h_i\)</span>，对于每一个<spanclass="math inline">\(i\)</span>,要求<span class="math inline">\(\forallj,p_i\geq h_j-h_i+\sqrt{|i-j|}\)</span>,求最小的<spanclass="math inline">\(p_i\)</span></p><p>思路：</p><p>不妨先将绝对值去掉，那么<spanclass="math inline">\(p_i=\left\{\begin{matrix}min\{h_j+\sqrt{i-j}-h_i\} &amp; j&lt;i\\ min\{h_j+\sqrt{j-i}-h_i\} &amp;j&gt;i \end{matrix}\right.\)</span></p><p>那么我们只要处理第一个式子就好了，第二个式子只要把整个数组反一下即可</p><p>可以发现<spanclass="math inline">\(p_i=min\{h_j+\sqrt{i-j}-h_i\}\)</span>满足决策单调性，并且<spanclass="math inline">\(p_i\)</span>之间相互无关，所以直接分治就解决了</p><p>code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IL inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">5e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> ep=<span class="hljs-number">1e-9</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">998244353</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br>ll n;<br>ll mas[N];<br><span class="hljs-type">double</span> dp1[N],dp2[N];<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">gt</span><span class="hljs-params">(ll p,ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> mas[p]+<span class="hljs-built_in">sqrt</span>(x-p)-mas[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solve</span><span class="hljs-params">(ll l,ll r,ll pl,ll pr,<span class="hljs-type">double</span> *dp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// if(l&gt;r||pl&gt;pr) return;</span><br>    ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    ll pos=pl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pl;i&lt;=<span class="hljs-built_in">min</span>(mid,pr);++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(i,mid)-dp[mid]&gt;=-ep) dp[mid]=<span class="hljs-built_in">gt</span>(pos=i,mid);<span class="hljs-comment">//要取&gt;=0</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(l&lt;mid) <span class="hljs-built_in">Solve</span>(l,mid<span class="hljs-number">-1</span>,pl,pos,dp);<br>    <span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">Solve</span>(mid+<span class="hljs-number">1</span>,r,pos,pr,dp);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;mas[i];<br>    <span class="hljs-built_in">Solve</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,n,dp1);<br>    <span class="hljs-built_in">reverse</span>(mas+<span class="hljs-number">1</span>,mas+<span class="hljs-number">1</span>+n);<br>    <span class="hljs-built_in">Solve</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,n,dp2);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-type">double</span> x=<span class="hljs-built_in">fmax</span>(dp1[i],dp2[n-i+<span class="hljs-number">1</span>]);<br>        cout&lt;&lt;(ll)<span class="hljs-built_in">ceil</span>(x)&lt;&lt;endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// ll t;t=read();while(t--)</span><br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P4072">SDOI2016征途</a></p><p><a href="https://www.luogu.com.cn/problem/CF321E">CF321 E</a></p><h5 id="类莫队做法">类莫队做法</h5><p>注意到分治要保证时间复杂度的前提是每次求<spanclass="math inline">\(w\)</span>代价的复杂度是<spanclass="math inline">\(O(1)\)</span>的</p><p>但是有一类<spanclass="math inline">\(w\)</span>比较特殊：关于区间的信息的记录，比如区间数字种类数等。这种问题我们一般可以离线下来用莫队处理，那么仿照莫队用左右端点的连续移动就可以做到<spanclass="math inline">\(O(1)\)</span>转移了，因为我们的决策点的选择范围也刚好是一个连续的区间，所以这样的话复杂度是正确的</p><p><a href="https://www.luogu.com.cn/problem/CF868F">CF868 F</a></p><p><a href="https://www.luogu.com.cn/problem/P5574">CmdOI2019任务分配问题</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IL inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">3e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> ep=<span class="hljs-number">1e-9</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">998244353</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e9</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tree</span><br>&#123;<br>    ll tr[N];<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> low(x) x&amp;(-x)</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(x&lt;N)<br>        &#123;<br>            tr[x]+=y;<br>            x+=<span class="hljs-built_in">low</span>(x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">sum</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ll ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x)<br>        &#123;<br>            ans+=tr[x];<br>            x-=<span class="hljs-built_in">low</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;T;<br>ll n,k;<br>ll mas[N];<br>ll dp[N],pp[N];<br><span class="hljs-keyword">namespace</span> Mo<br>&#123;<br>    <span class="hljs-type">int</span> L=<span class="hljs-number">1</span>,R=<span class="hljs-number">0</span>;<br>    ll ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> col[N];<br>    ll cnt[N];<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add1</span><span class="hljs-params">(ll pos,ll op)</span><span class="hljs-comment">//区间左边</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)<br>        &#123;<br>            ans+=T.<span class="hljs-built_in">sum</span>(n+<span class="hljs-number">1</span>)-T.<span class="hljs-built_in">sum</span>(col[pos]);<br>            T.<span class="hljs-built_in">add</span>(col[pos],<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ans-=T.<span class="hljs-built_in">sum</span>(n+<span class="hljs-number">1</span>)-T.<span class="hljs-built_in">sum</span>(col[pos]);<br>            T.<span class="hljs-built_in">add</span>(col[pos],<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add2</span><span class="hljs-params">(ll pos,ll op)</span><span class="hljs-comment">//区间右边</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)<br>        &#123;<br>            ans+=T.<span class="hljs-built_in">sum</span>(col[pos]<span class="hljs-number">-1</span>);<br>            T.<span class="hljs-built_in">add</span>(col[pos],<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ans-=T.<span class="hljs-built_in">sum</span>(col[pos]<span class="hljs-number">-1</span>);<br>            T.<span class="hljs-built_in">add</span>(col[pos],<span class="hljs-number">-1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll l,ll r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        l++;<br>        <span class="hljs-keyword">while</span>(L&lt;l) <span class="hljs-built_in">add1</span>(L++,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span>(L&gt;l) <span class="hljs-built_in">add1</span>(--L,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span>(R&gt;r) <span class="hljs-built_in">add2</span>(R--,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span>(R&lt;r) <span class="hljs-built_in">add2</span>(++R,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> pp[l<span class="hljs-number">-1</span>]+ans;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solve</span><span class="hljs-params">(ll l,ll r,ll pl,ll pr)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    ll pos;<br>    dp[mid]=Mo::<span class="hljs-built_in">gt</span>(pos=pl,mid);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pl+<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">min</span>(mid<span class="hljs-number">-1</span>,pr);++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(dp[mid]&gt;Mo::<span class="hljs-built_in">gt</span>(i,mid)) dp[mid]=Mo::<span class="hljs-built_in">gt</span>(pos=i,mid);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(l&lt;mid) <span class="hljs-built_in">Solve</span>(l,mid<span class="hljs-number">-1</span>,pl,pos);<br>    <span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">Solve</span>(mid+<span class="hljs-number">1</span>,r,pos,pr);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;Mo::col[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) pp[i]=Mo::<span class="hljs-built_in">gt</span>(<span class="hljs-number">0</span>,i);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;k;++i)<br>    &#123;<br>        <span class="hljs-built_in">Solve</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">0</span>,n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j) pp[j]=dp[j];<br>    &#125;<br>    cout&lt;&lt;pp[n]&lt;&lt;endl;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// ll t;t=read();while(t--)</span><br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="smawk">SMAWK</h4><p>SMAWK的用途跟分治一样，用于处理同一层之间没有转移关系的情况，但是复杂度会更优，可以达到<spanclass="math inline">\(O(n)\)</span></p><p>我们考虑从另一个角度来理解决策单调性</p><blockquote><p><strong>定义1</strong>若矩阵A满足∀i,j∈[0,k],pos(i)&lt;pos(j)则称A为单调矩阵。若A的任意子矩阵均为单调矩阵，则称A为完全单调矩阵</p></blockquote><p>重新定义四边形不等式</p><blockquote><p>定义2 对于n*m的矩阵A，若<span class="math inline">\(\forall1&lt;i_1&lt;i_2\leq n,1\leq j_1,\leq j_2\leq m\)</span>,均有<spanclass="math inline">\(A_{i_1,j_1}+A_{i_2,j_2}\leqA_{i_1,j_2}+A_{i_2,j_1}\)</span>,则称A满足四边形不等式</p></blockquote><p>快速判断矩阵是否满足四边形不等式：</p><blockquote><p>定理1 对于n*m的矩阵A，若<span class="math inline">\(\forall1&lt;i&lt;n,1\leq j&lt;m\)</span>,均有<spanclass="math inline">\(A_{i,j}+A_{i+1,j+1}\leqA_{i,j+1}+A_{i+1,j}\)</span>,则称A满足四边形不等式</p></blockquote><blockquote><p>定理2 若矩阵A满足四边形不等式，则A以及<spanclass="math inline">\(A^{T}\)</span>是完全单调矩阵</p></blockquote><p>接下来考虑<spanclass="math inline">\(dp_i=min_{j&lt;i}\{a_j+w(j,i)\}\)</span>,放到矩阵上，当<spanclass="math inline">\(j&lt;i\)</span>时，<spanclass="math inline">\(A_{i,j}=dp_j+w(j,i),j\geq i\)</span>时，令<spanclass="math inline">\(A_{i,j}=inf\)</span>，那么求<spanclass="math inline">\(dp_i\)</span>其实就是在第i行找最小值对应的列j.如果矩阵是一个单调矩阵，也就是dp满足决策单调性，我们就可以采用SMAWK</p><p>SMAWK的核心内容是reduce的过程，当列数m远大于n的时候，我们的枚举量会多很多，但是其实一行只会对应一个最优列，所以大量列是多余的，reduce过程就是在去除这些冗余列</p><p>当然，为了保证一行只有一个答案，我们要限定取每一行最左边/最右边的最小值<strong>（这一点在与WQS二分结合的时候很重要）</strong></p><p>其步骤如下：</p><ul><li><p>1初始定义 <em>k</em> = 1；</p></li><li><p>2当 <em>n</em> <em>≥</em> <em>m</em> 时结束过程；否则比较 <spanclass="math inline">\(A_{k,k}\)</span> 和 <spanclass="math inline">\(A_{k,k+1}\)</span></p></li><li><p>3若 <span class="math inline">\(A_{k,k}\geqA_{k,k+1}\)</span>，删除第 <em>k</em> 列，<em>k</em> <em>←</em>max(<em>k</em> <em>−</em> 1<em>,</em> 1)，回到步骤 2；</p></li><li><p>4若 <span class="math inline">\(A_{k,k}&lt; A_{k,k+1}\)</span> 且<em>k</em> = <em>n</em>，删除第 <em>n</em> + 1 列，回到步骤 2；</p></li><li><p>5若 <span class="math inline">\(A_{k,k}&lt; A_{k,k+1}\)</span> 且<em>k</em> = <em>n</em>，<em>k</em> <em>←</em> <em>k</em> + 1，回到步骤2。</p></li></ul><p>每一步的原因还是很显然的，这里不多赘述了。复杂度是<spanclass="math inline">\(O(m+n)\)</span></p><p>为了保证线性复杂度的正确性，可以用链表实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>    ll val,opt;<br>    Node *lst,*nxt;<br>    <span class="hljs-built_in">Node</span>()&#123;val=opt=<span class="hljs-number">0</span>;lst=nxt=<span class="hljs-literal">NULL</span>;&#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">List</span><br>&#123;<br>    ll len;<span class="hljs-comment">//列表长度</span><br>    Node *s,*e;<br>    <span class="hljs-built_in">List</span>()<br>    &#123;<br>        len=<span class="hljs-number">0</span>;<br>        s=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();s-&gt;opt=<span class="hljs-number">1</span>;<br>        e=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();e-&gt;opt=<span class="hljs-number">-1</span>;<br>        s-&gt;nxt=e;e-&gt;lst=s;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">//将x加入尾部</span><br>        Node *n=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        n-&gt;val=x;<br>        Node *a=e-&gt;lst;<span class="hljs-comment">//尾部元素</span><br>        a-&gt;nxt=n;n-&gt;lst=a;<br>        n-&gt;nxt=e;e-&gt;lst=n;<br>        len++;<span class="hljs-comment">//长度</span><br>    &#125;<br>    <span class="hljs-built_in">List</span>(<span class="hljs-type">const</span> List &amp;a)<br>    &#123;<br>        <span class="hljs-comment">//Copy</span><br>        len=<span class="hljs-number">0</span>;<br>        s=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();s-&gt;opt=<span class="hljs-number">1</span>;<br>        e=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();e-&gt;opt=<span class="hljs-number">-1</span>;<br>        s-&gt;nxt=e;e-&gt;lst=s;<br>        Node *n=a.s-&gt;nxt;<br>        <span class="hljs-keyword">while</span>(n-&gt;opt!=<span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-built_in">append</span>(n-&gt;val);<br>            n=n-&gt;nxt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">Node* <span class="hljs-title">del</span><span class="hljs-params">(Node *n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        --len;<br>        Node *a=n-&gt;lst,*b=n-&gt;nxt;<br>        a-&gt;nxt=b,b-&gt;lst=a;<br>        <span class="hljs-built_in">delete</span>(n);<br>        <span class="hljs-keyword">return</span> a;<span class="hljs-comment">//前一个节点</span><br>    &#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">submat</span><br>&#123;<br>    List r,c;<br>    <span class="hljs-comment">//row,column</span><br>&#125;A;<br><span class="hljs-function">submat <span class="hljs-title">Reduce</span><span class="hljs-params">(<span class="hljs-type">const</span> submat &amp;A)</span></span><br><span class="hljs-function"></span>&#123;<br>    submat B;<br>    B.r=(List)A.r;B.c=(List)A.c;<br>    <span class="hljs-type">int</span> n=A.r.len;<span class="hljs-comment">//行数</span><br>    <span class="hljs-type">int</span> m=A.c.len;<span class="hljs-comment">//列数</span><br>    Node *nr=B.r.s-&gt;nxt;<span class="hljs-comment">//第一个节点</span><br>    Node *nc=B.c.s-&gt;nxt;<br>    ll k=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(n&lt;m)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(nr-&gt;val,nc-&gt;val)&gt;<span class="hljs-built_in">get</span>(nr-&gt;val,nc-&gt;nxt-&gt;val))<br>        &#123;<br>            nc=B.c.<span class="hljs-built_in">del</span>(nc);<br>            m--;<br>            <span class="hljs-keyword">if</span>(k&gt;<span class="hljs-number">1</span>)<br>            &#123;<br>                --k;<br>                nr=nr-&gt;lst;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">//k=1</span><br>                nr=B.r.s-&gt;nxt;nc=B.c.s-&gt;nxt;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k==n)<br>        &#123;<br>            B.c.<span class="hljs-built_in">del</span>(nc-&gt;nxt);m--;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            k++;<br>            nr=nr-&gt;nxt;nc=nc-&gt;nxt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> B;<br>&#125;<br></code></pre></td></tr></table></figure><p>reduce之后我们就真正开始SMAWK了</p><p>SMAWK(A) 表示计算 <em>n</em> <em>×</em> <em>m</em> 的完全单调矩阵<em>A</em> 的<strong>每行最小值</strong>所在</p><p>列。步骤如下：</p><ul><li>1若 min(<em>n,</em> <em>m</em>) = 1 直接计算答案；</li><li>2对Areduce，得到矩阵B,并且我们取其所有偶数行组成一个新矩阵C</li><li>4递归SMAWK(C),得到C的每一行的最小值所在位置</li><li>4对于B中的奇数行，其答案在相邻两行的答案之间，那么之间暴力遍历一下即可。该步骤的复杂度为<spanclass="math inline">\(O(m)\)</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SMAWK</span><span class="hljs-params">(submat A)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n=A.r.len;<span class="hljs-comment">//行数</span><br>    <span class="hljs-type">int</span> m=A.c.len;<span class="hljs-comment">//列数</span><br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>    &#123;<br>        ll x=A.r.s-&gt;nxt-&gt;val;<span class="hljs-comment">//只有一行</span><br>        Node *nc=A.c.s-&gt;nxt;<br>        ll maxn=<span class="hljs-number">0</span>;<br>        ll maxp=<span class="hljs-number">0</span>;<span class="hljs-comment">//最值位置</span><br>        <span class="hljs-keyword">while</span>(nc-&gt;opt!=<span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(x,nc-&gt;val)&gt;=maxn)<br>            &#123;<br>                maxp=nc-&gt;val,maxn=<span class="hljs-built_in">get</span>(x,nc-&gt;val);<br>            &#125;<br>            nc=nc-&gt;nxt;<br>        &#125;<br>        ans[x]=maxp;<span class="hljs-comment">//存储最大值所在位置</span><br>        <span class="hljs-comment">///</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(m==<span class="hljs-number">1</span>)<br>    &#123;<br>        ll y=A.c.s-&gt;nxt-&gt;val;<br>        Node *nr=A.r.s-&gt;nxt;<span class="hljs-comment">//第一行</span><br>        <span class="hljs-keyword">while</span>(nr-&gt;opt!=<span class="hljs-number">-1</span>)<br>        &#123;<br>            ans[nr-&gt;val]=y;<br>            nr=nr-&gt;nxt;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    submat B=<span class="hljs-built_in">Reduce</span>(A);<br>    submat C;C.c=<span class="hljs-built_in">List</span>(B.c);<span class="hljs-comment">//首先保存每一列的信息</span><br>    Node *nr=B.r.s-&gt;nxt;<span class="hljs-comment">//行第一个元素</span><br>    <span class="hljs-type">bool</span> fl=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(nr-&gt;opt!=<span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(fl) C.r.<span class="hljs-built_in">append</span>(nr-&gt;val);<span class="hljs-comment">//C保存偶数行</span><br>        nr=nr-&gt;nxt;<br>        fl^=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//得到一个只有偶数行，列不变的矩阵</span><br>    <span class="hljs-built_in">SMAWK</span>(C);<span class="hljs-comment">//递归</span><br>    nr=B.r.s-&gt;nxt;fl=<span class="hljs-number">0</span>;<br>    Node *nc=B.c.s-&gt;nxt;<span class="hljs-comment">//列指针</span><br>    <span class="hljs-keyword">while</span>(nr-&gt;opt!=<span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!fl)<br>        &#123;<br>            ll z=ans[nr-&gt;nxt-&gt;val];<span class="hljs-comment">//已经处理过了，这里是有值的</span><br>            ll x=nr-&gt;val;<br>            ll maxn=<span class="hljs-number">0</span>,maxp=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(z==<span class="hljs-number">0</span>) z=inf;<br>            <span class="hljs-keyword">while</span>(nc-&gt;opt!=<span class="hljs-number">-1</span> &amp;&amp; nc-&gt;val&lt;=z)<br>            &#123;<br>                <span class="hljs-comment">//枚举列</span><br>                <span class="hljs-comment">//返回的是最右边的最小值</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(x,nc-&gt;val)&gt;=maxn)<br>                &#123;<br>                    maxn=<span class="hljs-built_in">get</span>(x,nc-&gt;val);<br>                    maxp=nc-&gt;val;<br>                &#125;<br>                nc=nc-&gt;nxt;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nc-&gt;lst-&gt;val==z) nc=nc-&gt;lst;<br>            ans[x]=maxp;<br>        &#125;<br>        nr=nr-&gt;nxt;<br>        fl^=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>理论上是可以平替分治的，但是写起来太烦了。。。</p><p>有一份短一点的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//求每行最左边最小值</span><br><span class="hljs-type">int</span> pre[N],suf[N],M[N],n,m,ans=<span class="hljs-number">1e18</span>,P=<span class="hljs-number">0</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt;L,H;<br>map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;Mp[N];<br><span class="hljs-function">ll <span class="hljs-title">get</span><span class="hljs-params">(ll a,ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//返回第a行第b列的元素</span><br>&#125; <br><span class="hljs-type">int</span> pre[N],suf[N],M[N],P=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (pre[x]!=<span class="hljs-number">-1</span>)<br>        suf[pre[x]]=suf[x]; <span class="hljs-keyword">else</span> P=suf[x];<br>    pre[suf[x]]=pre[x];<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">reduce</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;X,vector&lt;<span class="hljs-type">int</span>&gt;Y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;Y.<span class="hljs-built_in">size</span>();i++) pre[i]=i<span class="hljs-number">-1</span>,suf[i]=i+<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,y=<span class="hljs-number">0</span>;<br>    P=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> nmsl=Y.<span class="hljs-built_in">size</span>()-X.<span class="hljs-built_in">size</span>();nmsl&gt;<span class="hljs-number">0</span>;nmsl--)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>(X[x],Y[y])&lt;<span class="hljs-built_in">get</span>(X[x],Y[suf[y]]))<br>        &#123;<br>            y=suf[y];<br>            <span class="hljs-built_in">del</span>(pre[y]);<br>            <span class="hljs-keyword">if</span> (x) y=pre[y],x--;<br>        &#125; <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (x==X.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>) <span class="hljs-built_in">del</span>(suf[y]);<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                y=suf[y];<br>                x++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt;ret;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=P;i!=Y.<span class="hljs-built_in">size</span>();i=suf[i])  ret.<span class="hljs-built_in">push_back</span>(Y[i]);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solve</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;X,vector&lt;<span class="hljs-type">int</span>&gt;Y)</span></span><br><span class="hljs-function"></span>&#123;<br>    Y=<span class="hljs-built_in">reduce</span>(X,Y);<br>    <span class="hljs-keyword">if</span> (X.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)<br>    &#123;<br>        M[X[<span class="hljs-number">0</span>]]=Y[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt;Z;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;X.<span class="hljs-built_in">size</span>();i++)<br>        <span class="hljs-keyword">if</span> (!(i%<span class="hljs-number">2</span>)) Z.<span class="hljs-built_in">push_back</span>(X[i]);<br>    <span class="hljs-built_in">Solve</span>(Z,Y);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;X.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!(i%<span class="hljs-number">2</span>)) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> l=<span class="hljs-built_in">lower_bound</span>(Y.<span class="hljs-built_in">begin</span>(),Y.<span class="hljs-built_in">end</span>(),M[X[i<span class="hljs-number">-1</span>]])-Y.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-type">int</span> r=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i==X.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>) r=Y.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            r=<span class="hljs-built_in">lower_bound</span>(Y.<span class="hljs-built_in">begin</span>(),Y.<span class="hljs-built_in">end</span>(),M[X[i+<span class="hljs-number">1</span>]])-Y.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>        M[X[i]]=Y[l];<br>        <span class="hljs-keyword">while</span> (l&lt;r)<br>        &#123;<br>            l++;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>(X[i],Y[l])&gt;<span class="hljs-built_in">get</span>(X[i],M[X[i]])) M[X[i]]=Y[l];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br>H.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++) L.<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-built_in">Solve</span>(H,L);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="wqs二分">WQS二分+</h4><p>可以与其它方法结合在一起，达到一个非常优秀的时间复杂度</p><p>关于WQS二分本身的内容这里就不多赘述了，可以去看其它文章理解一下，这里主要讲一下如何将其应用在决策单调性中</p><p>考虑一类问题：将一个序列强制分为k段，每一段<spanclass="math inline">\([l,r]\)</span>有一个价值<spanclass="math inline">\(w(l,r)\)</span>,问总价值最小的分段</p><p>假设将序列分为k段的最优价值为<spanclass="math inline">\(f_k\)</span>，<strong>如果</strong>所有的<spanclass="math inline">\((k,f_k)\)</span>组成一个凸函数，那么我们就可以使用WQS二分了。外层枚举斜率，内层就去掉了分段的限制，就可以使用二分队列/斜率优化/分治等措施了。</p><p>现在问题还是很多的，比如凸性的证明，WQS二分的边界问题，内部求最优值时更新的取等问题等。一个一个来</p><h5 id="wqs多解情况">WQS多解情况</h5><p>多解情况是指答案K与多个点在一条线段上，此时我们无法直接通过枚举斜率来做到只切到点K，所以我们需要在枚举的同时让得到的方案具有完全的偏序，来保证我们枚举斜率的时候，知道当前斜率对应的答案是哪一点的答案，是线段左端点的，还是右端点的，从而保证后面二分调整mid的时候不会弄混淆。很重要的一点是，我们需要的只是正确的斜率，不需要保证当前斜率做出来的最优点一定是K,因为<spanclass="math inline">\(f_k=mid*k+b\)</span>,其中斜率<spanclass="math inline">\(mid\)</span>和截距<spanclass="math inline">\(b\)</span>都是二分之后确定的值，在同一线段上的点做出的<spanclass="math inline">\(mid,b\)</span>都是一样的。</p><p>那么为了做到严格偏序，我们需要对每一个属性都定义大小</p><p><ahref="https://blog.csdn.net/Emm_Titan/article/details/124035796?spm=1001.2014.3001.5502">这篇博客</a>讲的很清晰，我可能讲的有点抽象，可以去再看看</p><p><img src="https://s2.loli.net/2023/12/19/3lAUxiLe4rvwNRa.png" alt="image-20230916171500911" style="zoom:100%;" /></p><h5id="满足四边形不等式的序列划分问题的答案凸性以及wqs二分的方案构造">满足四边形不等式的序列划分问题的答案凸性以及WQS二分的方案构造</h5><p>这里我们尝试证明满足四边形不等式的序列划分问题都具有凸性</p><blockquote><p>不妨先来看另一个问题：给定一张n个点的DAG，点<spanclass="math inline">\(i\)</span>与点<spanclass="math inline">\(j\)</span>当<spanclass="math inline">\(i&lt;j\)</span>时有权值<spanclass="math inline">\(w(i,j)\)</span>,问从1走到n的经过k条边的最短路</p></blockquote><p>简单转化一下，这个问题的dp方程就是我们熟悉的:<spanclass="math inline">\(dp_{i,j}=min\{dp_{k,j-1}+w(k,i)\}\)</span>,<spanclass="math inline">\(dp_{i,j}\)</span>表示走到i，经过j条边的最短路</p><p>设<span class="math inline">\(f_k\)</span>表示经过k条边的最短路</p><p>下面我们尝试证明：当权值矩阵w满足四边形不等式的时候，<spanclass="math inline">\(f_k\)</span>是一个下凸函数。换句话说，<spanclass="math inline">\(\forall k\in[2,n-2]\)</span>，<spanclass="math inline">\(f_{k+1}-f_k&gt;f_k-f_{k-1}\)</span></p><blockquote><p>引理：<em>∀</em>1 <em>≤</em> <em>s</em> <em>&lt;</em> <em>r</em><em>&lt;</em> <em>t</em> <em>≤</em> <em>n</em> <em>−</em> 1<em>,</em><em>f</em>(<em>s</em>) + <em>f</em>(<em>t</em>) <em>≥</em><em>f</em>(<em>r</em>) + <em>f</em>(<em>s</em> + <em>t</em> <em>−</em><em>r</em>)</p></blockquote><p>如果我们能够证明该引理的话，带入<spanclass="math inline">\(s=k-1,r=k,t=k+1\)</span>,则命题得证</p><p>下面尝试证明引理：</p><hr /><p>不妨记<span class="math inline">\(f_s\)</span>对应的最优方案是<spanclass="math inline">\(p_1,p_2...p_{s+1}\)</span>,<spanclass="math inline">\(f_t\)</span>对应的最优方案是<spanclass="math inline">\(q_1,q_2,..q_{t+1}\)</span></p><p>记<spanclass="math inline">\(v=r-s&gt;0\)</span>,如果我们能够找到<spanclass="math inline">\(i \in [1,s]\)</span>,满足<spanclass="math inline">\(p_i\leq q_{i+v}&lt;q_{i+v+1}\leq p_{i+1}(i+v+1\leqs+v+1\leq t)\)</span>,就能够构造路径<spanclass="math inline">\(R_1:\)</span><spanclass="math inline">\(p_1,...p_i,q_{i+v+1},q_{i+v+2},..q_{t+1}\)</span>,以及路径<spanclass="math inline">\(R_2:\)</span><spanclass="math inline">\(q_1,...q_{i+v},p_{i+1},p_{i+2},...p_{s+1}\)</span>(也就是把两段路径的后半段交换了一下，并且保证一定交换了一部分)</p><p>两段路径的<strong>长度</strong>分别是<spanclass="math inline">\(i-1+(t+1-i-v-1)+1=t-v=t-r+s\)</span>,以及<spanclass="math inline">\(i-1+v+(s+1-i-1)+1=s+v=r\)</span>,</p><p>那么由f的定义,<spanclass="math inline">\(R_1\)</span>的<strong>路径长度</strong><spanclass="math inline">\(len（R_1) \geq f_{t-r+s}\)</span>,<spanclass="math inline">\(R_2\)</span>的<strong>路径长度</strong><spanclass="math inline">\(len(R_2)\geq f_{r}\)</span>,</p><p>由四边形不等式<spanclass="math inline">\(w(p_i,q_{i+v+1})+w(q_{i+v},p_{i+1})\leqw(q_{i+v}+q_{i+v+1})+w(p_i,p_{i+1})\)</span></p><p>故<span class="math inline">\(f_s+f_t\geq len(R_1)+len(R_2)\geqf_{t-r+s}+f_r\)</span></p><p>第一个不等式是因为<spanclass="math inline">\(R_1,R_2\)</span>与原本路径的区别只有中间衔接的一段</p><p>由上，我们只要证明存在这样的一个<spanclass="math inline">\(i\)</span>即可。</p><figure><img src="https://s2.loli.net/2023/12/19/r69QhC8pR2SqgJM.png"alt="image-20230916142205317" /><figcaption aria-hidden="true">image-20230916142205317</figcaption></figure><p>不妨记路径P将<spanclass="math inline">\((1,n]\)</span>分成了s个部分，其中第i个部分是<spanclass="math inline">\((p_i,p_{i+1}]\)</span></p><p>我们记<span class="math inline">\(a_i\)</span>表示<spanclass="math inline">\(q_{i+v}\)</span>在哪一段，那么如果存在<spanclass="math inline">\(i\)</span>,<spanclass="math inline">\(a_i=a_i+1=k\)</span>,我们就找到答案为k了。</p><p>记<span class="math inline">\(b_i=a_i-i\)</span>,显然<spanclass="math inline">\(b_1\geq 0,b_{s+1}\leq -1\)</span>，后者是因为<spanclass="math inline">\(a_{s+1}-(s+1)\leqs-(s+1)=-1\)</span>,此外显然<spanclass="math inline">\(b_i-b_{i-1}=0\)</span>或<spanclass="math inline">\(-1\)</span>,故<spanclass="math inline">\(b_i-b_{i-1}\geq -1\)</span></p><p>由此序列b中一定存在一个-1,取最靠前的-1，记为<spanclass="math inline">\(b_{i+1}\)</span>.它前面一定是<spanclass="math inline">\(b_i=0\)</span>,故<spanclass="math inline">\(a_i=a_{i+1}\)</span></p><p>这样我们就找到了一个合法的<spanclass="math inline">\(i\)</span>,引理得证，故命题得证 Q.E.D</p><hr /><p>这段证明还是非常玄妙(玄幻)的。当然它对于我们的方案构造也有帮助</p><p>WQS二分中有时候会存在要求为k，但是<spanclass="math inline">\(k&gt;l,k&lt;r\)</span>且<spanclass="math inline">\(l,r,k\)</span>在一条线段上的情况，这时候我们一般通过限定边数尽可能多/少来保证取到线段的端点。但是想要构造方案的话就会不知所措了</p><p>我们记答案斜率为mid,这条包含答案k的线段的端点为<spanclass="math inline">\((l,f_l),(r,f_r)\)</span>,则<spanclass="math inline">\(\forall i\in[l,r],f_i=f_l+mid*(i-l)\)</span></p><p>我们可以先把<spanclass="math inline">\(l,r\)</span>对应的最优方案找出来，长度分别为<spanclass="math inline">\(l,r\)</span>,那么按照上述证明中的构造方式我们得到长度为<spanclass="math inline">\(k,l+r-k\)</span>的路径<spanclass="math inline">\(R_1,R_2\)</span>,记其<strong>路径长度</strong>分别为<spanclass="math inline">\(len(R_1)=a,len(R_2)=b\)</span>,有<spanclass="math inline">\(a\geq f_l+mid*(k-l),b\geqf_l+mid*(l+r-k-l)\)</span></p><p>且有<spanclass="math inline">\(2f_l+mid*(k-l)+mid*(l+r-k-l)=2f_l+mid*(r-l)\leqa+b\leq f_l+f_r=2f_l+mid*(r-l)\)</span></p><p>第二个不等号的原因见证明片段</p><p>发现<span class="math inline">\(a+b\)</span>被边界夹住了，故<spanclass="math inline">\(a= f_l+mid*(k-l)\)</span>,由此a就是<spanclass="math inline">\(f_{k}\)</span>,我们就得到了长度为k的构造方案</p><p>以上内容参考 <a href="https://www.osti.gov/biblio/10146169">论文</a>《The <em>d</em>-Edge Shortest-Path Problem for a MongeGrapll》，以及APIO2021《决策单调性与四边形不等式》</p><hr /><h5 id="wqs外层二分时的边界">WQS外层二分时的边界</h5><p>一般来说直接取<spanclass="math inline">\([-inf,inf]\)</span>即可，或者稍微算一下卡住边界</p><p>不管是这样的</p><p><img src="https://s2.loli.net/2023/12/19/knMY3pRujfh4ZiU.png" alt="image-20230916170032830" style="zoom:60%;" /></p><p>还是这样的</p><p><img src="https://s2.loli.net/2023/12/19/irx2etJHF1LEcWR.png" alt="image-20230916170003304" style="zoom:60%;" /></p><p>只要边界范围足够就不会有问题。但是有一类分段问题，图像长这样</p><p><img src="https://s2.loli.net/2023/12/19/QXIrSU7uc1BfaWv.png" alt="image-20230916170405876" style="zoom:70%;" /></p><p>分段为0的时候，总价值为0，然后开始分段之后价值随分段减少。不考虑0的话，后面的一段也是满足凸函数的，那么这个对我们的边界会有影响吗？个人感觉没有，因为我们只要保证wqs二分之后在做最优决策的时候保证不让段数为0即可</p><p>比如这题就是这个情况<ahref="https://www.luogu.com.cn/problem/CF321E">CF321 E</a>(在分治部分此题作为练习出现，当然它也可以WQS二分，毕竟它满足四边形不等式，而我们已经证明了该类问题的凸性)</p><p>那么到这里，理论部分就差不多完善了，我们就可以看看应用了</p><p>不妨就看看这题<a href="https://www.luogu.com.cn/problem/CF321E">CF321E</a></p><p>按照套路，我们外层枚举斜率，内层就是每一段的贡献要减去一个<spanclass="math inline">\(mid\)</span>,问最优分段数及其对应的总贡献。dp式满足决策单调性，可以直接上单调队列，复杂度是<spanclass="math inline">\(O(nlogn^2)\)</span>,外层<spanclass="math inline">\(O(log)\)</span>,内层<spanclass="math inline">\(O(nlog)\)</span>，可以看到比普通的<spanclass="math inline">\(O(n^2log)\)</span>分治要优化了不少</p><p>code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> il inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">4010</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br>ll n,m;<br>ll mp[N][N];<br>ll cnt[N];<br>ll sum[N][N];<br>ll dp[N];<br>ll que[N];<br>ll ls[N],rs[N];<br>ll ANS;<br><span class="hljs-function">ll <span class="hljs-title">cal</span><span class="hljs-params">(ll l,ll r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//l+1-&gt;r</span><br>    <span class="hljs-keyword">return</span> sum[r][r]-sum[l][r]-sum[r][l]+sum[l][l];<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll k,ll x,ll val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> dp[k]+<span class="hljs-built_in">cal</span>(k,x)-val;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>    que[++tl]=<span class="hljs-number">0</span>;ls[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>,rs[<span class="hljs-number">0</span>]=n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cnt[i]=<span class="hljs-number">0</span>,ls[i]=rs[i]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;rs[que[hd]]&lt;i) hd++;<br>        dp[i]=<span class="hljs-built_in">gt</span>(que[hd],i,x);<br>        cnt[i]=cnt[que[hd]]+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">gt</span>(i,ls[que[tl]],x)&lt;<span class="hljs-built_in">gt</span>(que[tl],ls[que[tl]],x)) tl--;<br>        ll L=ls[que[tl]],R=n+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(L&lt;=R)<br>        &#123;<br>            ll mid=(L+R)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(i,mid,x)&lt;=<span class="hljs-built_in">gt</span>(que[tl],mid,x)) R=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> L=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;que[tl]&lt;&lt;&#x27; &#x27;&lt;&lt;R+1&lt;&lt;&quot; &quot;&lt;&lt;gt(i,R+1,x)&lt;&lt;&quot; &quot;&lt;&lt;gt()</span><br>        ll p_ans=R+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(p_ans&gt;n) <span class="hljs-keyword">continue</span>;<br>        rs[que[tl]]=p_ans<span class="hljs-number">-1</span>;<br>        que[++tl]=i;<br>        ls[i]=p_ans,rs[i]=n;<br>    &#125;<br>    ANS=dp[n];<br><span class="hljs-comment">//     cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;cnt[n]&lt;&lt;&quot; &quot;&lt;&lt;ANS&lt;&lt;&quot; &quot;&lt;&lt;ANS+m*x&lt;&lt;endl;</span><br>    <span class="hljs-keyword">return</span> cnt[n]&gt;=m;<br>    <span class="hljs-comment">//尽可能分多段，尽可能选靠后的点转移</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)<br>        &#123;<br>            cin&gt;&gt;mp[i][j];<br>            <span class="hljs-keyword">if</span>(i&gt;j) mp[i][j]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)<br>        &#123;<br>            sum[i][j]=sum[i][j<span class="hljs-number">-1</span>]+sum[i<span class="hljs-number">-1</span>][j]+mp[i][j]-sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>        &#125;<br>    &#125;<br>    ll l=<span class="hljs-number">-1e18</span>,r=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(l&lt;=r)<br>    &#123;<br>        ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(mid)) r=mid<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">else</span> l=mid+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">judge</span>(r+<span class="hljs-number">1</span>);<br>    cout&lt;&lt;ANS+m*(r+<span class="hljs-number">1</span>)&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P6246">IOI2000 邮局加强版</a></p><p><a href="https://www.luogu.com.cn/problem/P4072">SDOI2016征途</a></p><p>套路都差不多，套一个WQS的事，内层看情况用不同的优化手段</p><p><a href="https://www.luogu.com.cn/problem/P5308">Akvizna</a></p><p>你面临 <em>n</em> 名参赛者的挑战，最终要将他们全部战胜。每一轮中，都会淘汰一些选手；你会得到这一轮奖金池中 被淘汰者 除以这一轮对手总数 比例的奖金。</p><p>例如某一轮有 10 个对手，淘汰了 3 个，那么你将获得奖金池中 3/10的奖金。</p><p>假设每一轮的奖金池均为一元，<code>Mirko</code> 希望通过恰好<em>k</em> 轮赢得比赛，那么他最多可能获得多少奖金呢？</p><p>你只需要输出答案保留 9 位小数即可。</p><p>这题略阴间，二分的时候不枚举小数的话过不了，肥肠卡精度，不过思维难度一般</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-12</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-type">const</span> ll N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">double</span> dp[N];<br><span class="hljs-type">double</span> ANS;<br><span class="hljs-type">double</span> inv[N];<br>ll cnt[N];<span class="hljs-comment">//分的段数</span><br>ll que[N];<br>ll ls[N],rs[N];<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">gt</span><span class="hljs-params">(ll k,ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> dp[k]+(<span class="hljs-type">double</span>)((x-k)*<span class="hljs-number">1.0</span>*inv[n-k]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>    que[++tl]=<span class="hljs-number">0</span>;ls[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>,rs[<span class="hljs-number">0</span>]=n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cnt[i]=<span class="hljs-number">0</span>,ls[i]=rs[i]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;rs[que[hd]]&lt;i) hd++;<br>        cnt[i]=cnt[que[hd]]+<span class="hljs-number">1</span>;<br>        dp[i]=<span class="hljs-built_in">gt</span>(que[hd],i)-x;<br>        <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;que[hd]&lt;&lt;&#x27; &#x27;&lt;&lt;dp[i]&lt;&lt;endl;</span><br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">gt</span>(i,ls[que[tl]])&gt;=<span class="hljs-built_in">gt</span>(que[tl],ls[que[tl]])) tl--;<br>        ll L=ls[que[tl]],R=n+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(L&lt;=R)<br>        &#123;<br>            ll mid=(L+R)&gt;&gt;<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(i,mid)&gt;=<span class="hljs-built_in">gt</span>(que[tl],mid)) R=mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> L=mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        ll p_ans=R+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(p_ans&gt;n) <span class="hljs-keyword">continue</span>;<br>        rs[que[tl]]=p_ans<span class="hljs-number">-1</span>;<br>        que[++tl]=i;<br>        ls[i]=p_ans,rs[i]=n;<br>    &#125;<br>    ANS=dp[n];<br>    <span class="hljs-comment">// cout&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;cnt[n]&lt;&lt;&#x27; &#x27;&lt;&lt;ANS&lt;&lt;&#x27; &#x27;&lt;&lt;ANS+m*x&lt;&lt;endl;</span><br>    <span class="hljs-keyword">return</span> cnt[n]&lt;=m;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) inv[i]=<span class="hljs-number">1.0</span>/(i*<span class="hljs-number">1.0</span>);<br>    <span class="hljs-comment">// for(int i=1;i&lt;=n;++i)</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     for(int j=1;j&lt;=min(i,m);++j)</span><br>    <span class="hljs-comment">//     &#123;</span><br>    <span class="hljs-comment">//         for(int k=j-1;k&lt;i;++k)</span><br>    <span class="hljs-comment">//         &#123;</span><br>    <span class="hljs-comment">//             dp[i][j]=max(dp[i][j],dp[k][j-1]+(double)((i-k)*1.0/(n-k)));</span><br>    <span class="hljs-comment">//         &#125;</span><br>    <span class="hljs-comment">//     &#125;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// judge(0);</span><br>    <span class="hljs-comment">// for(double i=-2;i&lt;=2;i+=0.1) judge(i);</span><br>    <span class="hljs-type">double</span> l=<span class="hljs-number">-100</span>,r=<span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">while</span>(l+eps&lt;=r)<br>    &#123;<br>        <span class="hljs-type">double</span> mid=(l+r)/<span class="hljs-number">2.0</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(mid)) r=mid;<br>        <span class="hljs-keyword">else</span> l=mid;<br>    &#125;<br>    <span class="hljs-built_in">judge</span>(r);<br>    <span class="hljs-comment">// cout&lt;&lt;r+1&lt;&lt;endl;</span><br>    cout&lt;&lt;fixed&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">9</span>)&lt;&lt;ANS+m*<span class="hljs-number">1.0</span>*(r)&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="tips">Tips：</h5><p>做WQS二分一定要注意问题函数是一个上凸包还是下凸包</p><p>注意左右边界</p><p>有时候也是也是要二分小数的！</p><h4 id="斜率优化">斜率优化</h4><p>基本的斜率优化本人已经在<ahref="https://blog.csdn.net/sophilex/article/details/132634582?spm=1001.2014.3001.5502">另一篇博客</a>中讲的很详细了，从入门到精通应该都有了。</p><p>然后更多的应用大概就是与WQS二分结合了吧</p><p>注意点好像也没啥，毕竟WQS二分之后内部就是一个纯纯的一维dp</p><p><a href="https://www.luogu.com.cn/problem/P4072">SDOI2016征途</a></p><p><a href="https://www.luogu.com.cn/problem/P5308">Akvizna</a></p><p>值得一提的还有这道题<ahref="https://www.luogu.com.cn/problem/P5504">JSOI2001 柠檬</a></p><p>之前在二分栈里提过它，但其实它也可以用斜率优化做，但是因为斜率实际上是递减的，所以内部维护凸包的时候是用一个栈（因为最优点在最后了，放入点也是在最后），这个还是比较少见的</p><p>code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ld long double</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IL inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">100010</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">998244353</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> X=<span class="hljs-number">0</span>; <span class="hljs-type">bool</span> flag=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">while</span>(ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>) flag=<span class="hljs-number">0</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="hljs-number">1</span>)+(X&lt;&lt;<span class="hljs-number">3</span>)+ch-<span class="hljs-string">&#x27;0&#x27;</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br>    <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> X;<br>    <span class="hljs-keyword">return</span> ~(X<span class="hljs-number">-1</span>);<br>&#125;<br>ll n,a;<br>ll dp[N];<br>vector&lt;ll&gt; col[N],st[N];<span class="hljs-comment">//栈</span><br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll x,ll c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> dp[col[c][x]<span class="hljs-number">-1</span>]+c*x*x<span class="hljs-number">-2</span>*x*c;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Slope</span><span class="hljs-params">(ll a,ll b,ll col)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a==b) <span class="hljs-keyword">return</span> inf;<br>    <span class="hljs-type">double</span> x=<span class="hljs-built_in">gt</span>(a,col)-<span class="hljs-built_in">gt</span>(b,col);x=x*<span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">double</span> y=a-b;y*=<span class="hljs-number">1.0</span>;<br>    <span class="hljs-keyword">return</span> x/y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10000</span>;++i) col[i].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;a;<br>        ll len=col[a].<span class="hljs-built_in">size</span>();<br>        col[a].<span class="hljs-built_in">push_back</span>(i);<span class="hljs-comment">//放入id</span><br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">1</span>) st[a].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//st存的是横坐标（颜色前缀和）</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">//维护上凸包</span><br>            <span class="hljs-keyword">while</span>(st[a].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;<span class="hljs-built_in">Slope</span>(st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>],st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>],a)&lt;=<span class="hljs-number">2</span>*a*len) st[a].<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//sum_i=len</span><br>            ll id=st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];<br>            dp[i]=dp[col[a][id]<span class="hljs-number">-1</span>]+a*(<span class="hljs-number">1</span>+len-id)*(<span class="hljs-number">1</span>+len-id);<br>            <span class="hljs-keyword">while</span>(st[a].<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;<span class="hljs-built_in">Slope</span>(st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>],st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>],a)&lt;=<span class="hljs-built_in">Slope</span>(st[a][st[a].<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>],len,a)) st[a].<span class="hljs-built_in">pop_back</span>();<br>            st[a].<span class="hljs-built_in">push_back</span>(len);<br>        &#125;<br>        dp[i]=<span class="hljs-built_in">max</span>(dp[i],dp[i<span class="hljs-number">-1</span>]+a);<br>    &#125;<br>    cout&lt;&lt;dp[n]&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// ll t;t=read();while(t--)</span><br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一些特殊情况">一些特殊情况</h4><p>可以看到，如果题目已经有了决策单调性，大部分情况下还是比较套路的，但是有些时候问题在全局上不满足决策单调性并不意味着局部也没有。</p><p>还是<a href="https://www.luogu.com.cn/problem/P5504">JSOI2001柠檬</a>这道题，它就是在同种颜色内部满足决策单调性（这么一看这真是道好题啊，哪哪都这么与众不同）</p><p>以及<a href="https://codeforces.com/gym/101002/attachments">2016NAIPH</a></p><p>大意：</p><p>有n个物品，每个物品有一个体积<spanclass="math inline">\(w_i\)</span>和价值<spanclass="math inline">\(v_i\)</span>，现在要求对<spanclass="math inline">\(V∈[1,m]\)</span>，求出体积为<spanclass="math inline">\(V\)</span>的 背包能够装下的最大价值</p><p><spanclass="math inline">\(1≤n≤1000000;1≤m≤100000;1≤w_i≤300;1≤v_i≤10^9\)</span></p><p>其实就是对每一个<spanclass="math inline">\(V\)</span>，做一个多重背包</p><p>思路：</p><p>发现每一个物品的体积都比较小，所以可以按照体积分类。那么对于同一种体积的物品，我们肯定贪心选择价值最大的，所以可以排个序</p><p>考虑<span class="math inline">\(dp_{i,j}\)</span>表示使用体积<spanclass="math inline">\(\leqi\)</span>的物品，总体积为j的最大价值。我们可以将所有需要更新的体积按照%i来重新编号。比如当前i是2，m是9，我们就可以将<spanclass="math inline">\(0,2,4,6,8\)</span>化为一类各自重新编号为<spanclass="math inline">\(0,1,2,3,4\)</span>，<spanclass="math inline">\(1,3,5,7,9\)</span>划为一类，编号同理</p><p>这样的好处就是我们对于每一个i，j的范围也只有<spanclass="math inline">\([0,i]\)</span>这么大了，以及同一组体积内部的差恰好为i，那么物品就可以直接按照价值大小贪心塞了。</p><p>那么此时dp的意义就变了。如果当前是在更新%i=a的体积，则<spanclass="math inline">\(dp_{i,j}\)</span>表示使用体积<spanclass="math inline">\(\leq i\)</span>的物品，总体积为<spanclass="math inline">\(j*i+a\)</span>的最大值</p><p>%i=a时，<span class="math inline">\(dp_{i,j}=max_{k\leqj}\{dp_{i-1,k}+w(k,j)\}\)</span>,其中<spanclass="math inline">\(w(k,j)\)</span>表示体积=i的物品中最大的<spanclass="math inline">\(j-k\)</span>个物品的价值和，记为前缀和<spanclass="math inline">\(vt_{i,j-k}\)</span></p><p>简单证一下四边形不等式:</p><p>考虑<span class="math inline">\(i,i+1,j,j+1,i+1&lt;j\)</span></p><p><span class="math inline">\(w(i,j)+w(i+1,j+1)=2vt_{j-i}\)</span></p><p><spanclass="math inline">\(w(i+1,j)+w(i,j+1)=vt_{j-i-1}+vt_{j-i+1}=2vt_{j-i}+a_{j-i+1}-a_{j-i-1}\leqw(i,j)+w(i+1,j+1)\)</span></p><p>得证</p><p>那么直接分治即可</p><p>code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-11</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-type">const</span> ll N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br>ll n,m;<br>vector&lt;ll&gt; vt[<span class="hljs-number">310</span>];<br>ll dp[N],pp[N];<br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll id,ll x,ll mod,ll res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> pp[id*mod+res]+vt[mod][x-id<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(ll a,ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a&gt;b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Solve</span><span class="hljs-params">(ll l,ll r,ll pl,ll pr,ll mod,ll res)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span>;<br>    ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    ll pos=mid;<br>    dp[mid*mod+res]=pp[mid*mod+res];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-built_in">min</span>(mid<span class="hljs-number">-1</span>,pr);i&gt;=pl;--i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(mid-i&gt;(<span class="hljs-type">int</span>)vt[mod].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gt</span>(i,mid,mod,res)&gt;dp[mid*mod+res]) dp[mid*mod+res]=<span class="hljs-built_in">gt</span>(pos=i,mid,mod,res);<br>    &#125;<br>    <span class="hljs-built_in">Solve</span>(l,mid<span class="hljs-number">-1</span>,pl,pos,mod,res);<br>    <span class="hljs-built_in">Solve</span>(mid+<span class="hljs-number">1</span>,r,pos,pr,mod,res);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        ll a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        vt[a].<span class="hljs-built_in">push_back</span>(b);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">300</span>;++i)<br>    &#123;<br>        <span class="hljs-built_in">sort</span>(vt[i].<span class="hljs-built_in">begin</span>(),vt[i].<span class="hljs-built_in">end</span>(),cmp);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;(<span class="hljs-type">int</span>)vt[i].<span class="hljs-built_in">size</span>();++j) vt[i][j]+=vt[i][j<span class="hljs-number">-1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">300</span>;++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!vt[i].<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//枚举物品体积的类别</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;++j)<br>        &#123;<br>            <span class="hljs-comment">//枚举%i=j的体积</span><br>            <span class="hljs-built_in">Solve</span>(<span class="hljs-number">0</span>,(m-j)/i,<span class="hljs-number">0</span>,(m-j)/i,i,j);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) dp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j<span class="hljs-number">-1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;++j) pp[j]=<span class="hljs-built_in">max</span>(dp[j],dp[j<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i) cout&lt;&lt;pp[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>本来想用SMAWK写的，但是一直MLE，不懂，求懂的佬教教</p><p>当然这题的决策单调性也是分组才有的，很抽象，感觉本人是不可能看出来的（哭</p><p>总结：</p><p>大工程，希望对自己&amp;大家有用:heartpulse:</p><p>参考文章</p><p><a href="https://oi-wiki.org/">OIWIKI</a></p><p><a href="https://www.osti.gov/biblio/10146169">Bein, W W, Larmore, LL, and Park, J K. <em>The d-edge shortest-path problem for a Mongegraph</em>. United States: N. p., 1992. Web.</a></p><p><a href="https://www.osti.gov/biblio/10175042">Bein, W W, Brucker, P,and Park, J K. <em>Applications of an algebraic Monge property</em>.United States: N. p., 1993. Web.</a></p><p><ahref="https://www.luogu.com.cn/blog/command-block/dp-di-jue-ce-dan-diao-xing-you-hua-zong-jie">DP的决策单调性优化总结</a></p><p><ahref="https://cp-algorithms.com/dynamic_programming/divide-and-conquer-dp.html">Divideand Conquer DP</a></p><p><ahref="https://www.luogu.com.cn/blog/MCAdam/jue-ce-dan-diao-xing">决策单调性- MCAdam</a></p><p><ahref="https://www.luogu.com.cn/blog/flashblog/solution-p1912">关于决策单调性与图像的结合</a></p><p>彭思进 《决策单调性与四边形不等式》</p><p>[CF802 O] (https://www.luogu.com.cn/problem/CF802O)Wqs二分+反悔贪心</p>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划 Math 学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斜率优化dp总结</title>
    <link href="/2023/12/19/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp%E6%80%BB%E7%BB%93/"/>
    <url>/2023/12/19/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="斜率优化dp">斜率优化dp</h2><h3 id="前言">前言：</h3><p>我们学过不少优化类的算法了，大部分都是基于凸函数的性质给出的优化，比如SlopeTrick，Wqs二分，又比如今天的斜率优化（不知道什么时候会有空把SlopeTrick写掉）</p><h3 id="正文">正文：</h3><p>我们考虑一类比较常见的dp方程：<spanclass="math inline">\(dp_i=min/max_{j}(a_i*b_j+c_j+d_i)\)</span>,其中<strong><spanclass="math inline">\(b_j是单调增的\)</span></strong><spanclass="math inline">\(（事实上b_j\)</span>不单调增也可以用斜率优化处理，但是这里我们为了简化先考虑这样一种特殊情况）。同时，为了方便，接下来我们先以min为讨论对象，实际上max是同理的，读者可以自己对应手推一遍</p><p>一般的暴力递推，复杂度是<spanclass="math inline">\(O(N^2)\)</span>的。</p><p>我们考虑改变一下式子的形式：<spanclass="math inline">\(dp_i=min_{j}\{a_i*b_j+c_j\}+d_i\)</span>,此时对于固定的<spanclass="math inline">\(i\)</span>,外面的<spanclass="math inline">\(d_i\)</span>是固定的，所以我们真正要考虑的其实是<spanclass="math inline">\(a_i*b_j+c_j\)</span>这样一个式子的最小值，它其实就是一个一次函数<spanclass="math inline">\(kx+b\)</span>的形式，其中<spanclass="math inline">\(k=b_j,b=c_j\)</span>。我们不妨记<spanclass="math inline">\(f_{i,j}=a_i*b_j+c_j\)</span></p><h4 id="凸包">凸包</h4><p>我们不妨来看一下，如果两个点<spanclass="math inline">\(x&lt;y\)</span>，对于某一个i满足<spanclass="math inline">\(f(i,y)\leq f(i,x)\)</span>,也就是说<spanclass="math inline">\(y\)</span>是比<spanclass="math inline">\(x\)</span>更加优的一个决策点，它们之间会有什么关系</p><p><span class="math inline">\(f(i,y)=a_i*b_y+c_y\leqf(i,x)=a_i*b_x+c_x\)</span></p><p>即：<span class="math inline">\(\large \frac{c_y-c_x}{b_y-b_x}\leq-a_i\)</span>(注意之前我们假定<spanclass="math inline">\(b_i\)</span>是单增的)</p><blockquote><p>这里是在做一个参变分离，注意这里我们其实是将x,y的信息视为已知量，而将i作为变量</p></blockquote><p>放到二维坐标系下考虑，就是<spanclass="math inline">\((b_x,c_x),(b_y,c_y)\)</span>两个点的连线的斜率<spanclass="math inline">\(\leq -a_i\)</span></p><p><img src="https://s2.loli.net/2023/12/19/Y2egrsEdxcBw9U8.png" alt="image-20230901175709520" style="zoom:100%;" /></p><p>换句话说，这里如果x是y之前的比较优的一个点，在y出现之后它就被淘汰了，判断的条件我们记为<spanclass="math inline">\(k_{xy}&lt;=K(X)\)</span>,其中<spanclass="math inline">\(K(X)=-a_i\)</span>。</p><p>接着我们将考虑的点数扩大到三个点<span class="math inline">\(x\leq y\leq z\)</span>,这里我们不妨先限定<span class="math inline">\(K_{yz}\leqK_{xy}\)</span></p><p><img src="https://s2.loli.net/2023/12/19/KeSIpcrOGB5f2hJ.png" alt="image-20230901175709520" style="zoom:100%;" /></p><p>边界条件还是<span class="math inline">\(K(X)=-a_i\)</span></p><blockquote><p>按照之前的讨论，对于两个点<spanclass="math inline">\(x,y\)</span>,若<spanclass="math inline">\(k_{x,y}\leq K(x)\)</span>,则点<spanclass="math inline">\(y优于x\)</span>,否则<spanclass="math inline">\(点x优于y\)</span></p></blockquote><p>那么我们有如下几种情况：</p><ul><li>$K_{yz}&lt;K_{xy} K(X) <spanclass="math inline">\(,则\)</span>点z优于点x,y$</li><li><span class="math inline">\(K_{yz}\leqK(X)&lt;K_{xy}\)</span>,则点<spanclass="math inline">\(x,z\)</span>优于<spanclass="math inline">\(点y\)</span></li><li><span class="math inline">\(K(X)\leqK_{yz}&lt;K_{zy}\)</span>,则点x优于点<spanclass="math inline">\(y,z\)</span></li></ul><p>此时我们惊奇地发现，不管是哪一种情况，点<spanclass="math inline">\(y\)</span>都不可能作为最优解。按照之前所说，我们其实是对于这样一系列固定的点，对于不同的i，考察最优决策点的变化。也就是说，如果我们提前处理好了这样若干个点，那么我们就已经知道点y永远不会成为最优决策点了（在三个点都能选择的情况下）</p><blockquote><p>讲回我们在这部分讨论前做的假设<span class="math inline">\(K_{yz}\leqK_{x,y}\)</span>,读者可以自行验证，当三点不满足该关系的时候，我们并不能得到类似或者什么更优的结论。</p></blockquote><p>那么我们对于一个固定的点i，将所有能进行决策的点进行这样一个预处理过程的话（大部分情况下对于固定的点i，我们只能够在<spanclass="math inline">\([1,i-1]\)</span>内决策，这里直接取该情况，其它情况其实同理），<spanclass="math inline">\(\forall 1\leq x&lt;y&lt;z&lt; i\)</span>,若<spanclass="math inline">\(K_{yz}\leqK_{x,y}\)</span>,则将点y删除（因为它永远不会成为一个最优）,那么将留下来的点两两按横坐标顺序前后链接，斜率是<strong>单调不降的</strong>，换句话说，留下来的点就形成了一个<strong>下凸包</strong>，如下图所示，其中绿色连接部分就是一个凸包，红色点是在处理过程中被删除的点</p><p><img src="https://s2.loli.net/2023/12/19/1IxmWoDGw9PSRen.png" alt="image-20230901175709520" style="zoom:100%;" /></p><h4 id="最优决策点的快速寻找">最优决策点的快速寻找</h4><p>一旦要维护的东西变成了一个凸包，那么我们的手段就可以很骚了，因为此时它的斜率具有单调性，我们就可以上二分等手段了:)</p><p>对于一个固定的i，我们有<spanclass="math inline">\(K(X)=-a_i\)</span>,由于下凸包的斜率是单增的，所以将斜率从左到右一一写出来的话，我们会得到如下关系</p><p><span class="math inline">\(K_1&lt;K_2&lt;...&lt;K_s\leqK(X)&lt;K_{s+1}...K_{m}\)</span></p><p>那么我们要找的点显然就是s，也就是最后一个与前面的点连线的斜率<spanclass="math inline">\(\leq K(X)\)</span>的点</p><p>那么我们维护好这个凸包之后，直接用二分线段即可，最后一个斜率<spanclass="math inline">\(\leq K(X)\)</span>的线段的右端点就是答案了</p><blockquote><p>考虑凸包的一个特殊情况：多个点处于一条线段上，就如上图的第二条线段，但是该情况对我们的选择并没有影响，因为我们取的是每一个线段的最右端点</p></blockquote><p>这样每次去寻找最优决策点的复杂度是<spanclass="math inline">\(O(log)\)</span>的，再加上维护凸包的复杂度<spanclass="math inline">\(O(N)\)</span>,时间复杂度就是<spanclass="math inline">\(O(NlogN)\)</span>的</p><p>具体流程:</p><ul><li><p>A 在凸包上二分找到最优决策点x</p></li><li><p>B 用x的值更新<span class="math inline">\(dp_i\)</span></p></li><li><p>C在将i加入凸包之前，我们要先将队尾一部分一定没有i优的点踢掉，然后再将i加入凸包</p></li></ul><p>对步骤C的解释：这里将i直接加入凸包的话，有可能我们维护的就不再是一个凸包了，如下图情况</p><p><img src="https://s2.loli.net/2023/12/19/OCarLxQ3tYJR1SE.png" alt="image-20230901175709520" style="zoom:100%;" /></p><p>不难发现，此时<spanclass="math inline">\(x,y,i\)</span>三点形成的就是之前讨论过的三个点的情形，所以y是一定不会成为最优决策点的。同理，踢掉y之后，如果<spanclass="math inline">\(z,x,i\)</span>也是一个情况的话，x也会被踢掉，直到最后不再有这样的点为止</p><h4 id="再优化">再优化</h4><p>注意到上面的复杂度还是有点高，我们考虑dp过程中常见的决策单调性情况</p><p>决策单调性：在dp过程中，设<spanclass="math inline">\(S_i表示dp_i\)</span>的最优决策点，如果<spanclass="math inline">\(\forall i&lt;j,S_i\leqS_j\)</span>则称该dp过程满足决策单调性，也就是说随着dp过程的进行，最优决策点是单调不降的</p><p>关于决策单调性的证明，常见的就是四边形不等式，这里暂且不提，后面有空再说:)</p><p>决策单调性在这里意味着什么？意味着之前已经被淘汰的点是不会再作为最优决策点出现的。所以我们就可以考虑用单调队列来维护。</p><p>具体流程：</p><ul><li>A <strong>将队列首部斜率<span class="math inline">\(\leqK(X)\)</span>的线段的左端点不断踢出，最后剩下的队首元素x就是最优决策点。（正确性显然）</strong></li><li>B 用x的值更新<span class="math inline">\(dp_i\)</span></li><li>C在将i加入凸包之前，我们要先将队尾一部分一定没有i优的点踢掉，然后再将i加入凸包</li></ul><p>与直接二分的区别就在于步骤A</p><blockquote><p>同时我们注意到，如果<spanclass="math inline">\(K(X)\)</span>是单调的，其自然满足决策点的单调性。（在横坐标单调的前提下）</p></blockquote><p><img src="https://s2.loli.net/2023/12/19/lvNPTIB4QUHjGx6.png" alt="image-20230901175709520" style="zoom:100%;" /></p><h4 id="类型总结单调队列维护凸包">类型总结（单调队列维护凸包）</h4><p>当dp式子满足<span class="math inline">\(\large\frac{c_y-c_x}{b_y-b_x}\leq-a_i\)</span>的时候，我们要维护的是一个下凸包</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>que[++tl]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>    <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[hd],que[hd+<span class="hljs-number">1</span>])&lt;=k[x]) hd++;<span class="hljs-comment">//这里k[x]表示K(X)</span><br>    dp[i]=...<span class="hljs-comment">//用que[hd]来更新dp[i]即可</span><br>    <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[tl<span class="hljs-number">-1</span>],que[tl])&gt;=<span class="hljs-built_in">Slope</span>(que[tl],i)) tl--;<br>    que[++tl]=i;<span class="hljs-comment">//插入凸包</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当dp式子满足<span class="math inline">\(\large\frac{c_y-c_x}{b_y-b_x}\geq-a_i\)</span>的时候，同理就是维护一个上凸包</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>que[++tl]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>&#123;<br>    <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[hd],que[hd+<span class="hljs-number">1</span>])&gt;=k[x]) hd++;<span class="hljs-comment">//这里k[x]表示K(X)</span><br>    dp[i]=...<span class="hljs-comment">//用que[hd]来更新dp[i]即可</span><br>    <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[tl<span class="hljs-number">-1</span>],que[tl])&lt;=<span class="hljs-built_in">Slope</span>(que[tl],i)) tl--;<br>    que[++tl]=i;<span class="hljs-comment">//插入凸包</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="tip">Tip</h4><ul><li>当两个点的横坐标相等的时候，实际上不存在斜率，这里我们要特判，取为inf</li><li>到底维护的是上凸包还是下凸包不要弄混，仔细推导一遍最好</li><li>一般是直接用double类型来计算斜率并进行比较，但是有时候出题人不讲武德卡精度，那就要转成乘式类型来比较了，这时候要注意一下负号改变方向的情况</li><li>队列一开始要放进去一个0，毕竟也不一定非有上一个转移点</li><li>有时候dp值会需要预处理，要小心</li><li>比较斜率的时候最好使用<spanclass="math inline">\(\leq,\geq\)</span></li></ul><h4 id="一些特殊情况">一些特殊情况</h4><ul><li><spanclass="math inline">\(b_j\)</span>是单调减的：实际与之前的情况同理。在一开始的推导中我们假定<spanclass="math inline">\(x&lt;y\)</span>，本质上就是为了保证<spanclass="math inline">\(b_j\)</span>是单增的，如果此时它是单减的，我们只要在原本的式子中在对应位置取负，再改变前面符号，重新推导即可。此时<spanclass="math inline">\(-b_j\)</span>就是单增的了</li><li><spanclass="math inline">\(b_j\)</span>不具备单调性：此时我们不能直接通过单调队列来维护凸包，因为新加入的点的横坐标并不是单调的，可能会插入在凸包的中间的位置。此时需要采用cdq分治</li><li>不具备决策单调性：那就只能二分了，不能强行弹出点，因为它可能在后面会成为最优决策点</li><li>不具备决策单调性&amp;横坐标不单调：cdq分治 后面会讲</li></ul><h3 id="例子">例子</h3><p><a href="https://www.luogu.com.cn/problem/P2120">仓库建设</a></p><p>大意：</p><p><span class="math inline">\(n\)</span>个工厂，由高到低分布在一座山上，工厂 <spanclass="math inline">\(1\)</span> 在山顶，工厂 <spanclass="math inline">\(n\)</span> 在山脚。第 <spanclass="math inline">\(i\)</span> 个工厂目前已有成品 <spanclass="math inline">\(p_i\)</span> 件，在第 <spanclass="math inline">\(i\)</span> 个工厂位置建立仓库的费用是 <spanclass="math inline">\(c_i\)</span>。对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，产品只能往山下运（即<strong>只能运往编号更大的工厂的仓库</strong>），一件产品运送一个单位距离的费用是<span class="math inline">\(1\)</span>。</p><ul><li>工厂 <span class="math inline">\(i\)</span> 距离工厂 <spanclass="math inline">\(1\)</span> 的距离 <spanclass="math inline">\(x_i\)</span>（其中 <spanclass="math inline">\(x_1=0\)</span>）。</li><li>工厂 <span class="math inline">\(i\)</span> 目前已有成品数量 <spanclass="math inline">\(p_i\)</span>。</li><li>在工厂 <span class="math inline">\(i\)</span> 建立仓库的费用 <spanclass="math inline">\(c_i\)</span>。</li></ul><p>问修建仓库的最小代价</p><p>思路：</p><p>设<spanclass="math inline">\(dp_i\)</span>表示前i个工厂的最小代价，写出dp式子的过程还是比较套路的，</p><p><span class="math inline">\(dp_i=min_{j\leqi}\{dp_j+x_i\sum_{k=j+1}^{i}(p_k)-\sum_{k=j+1}^{i}(x_kp_k)\}+c_i\)</span></p><p>转化得到</p><p><span class="math inline">\(dp_i=min_{j\leqi}\{dp_j+x_i(sum_i-sum_j)-(xsum_i-xsum_j)\}+c_i\)</span></p><p>其中<spanclass="math inline">\(sum_i=\sum_{k=1}^{i}p_k,xsum_i=\sum_{k=1}^{i}p_k*x_k\)</span></p><p>所以<span class="math inline">\(dp_i=min_{j\leqi}\{-sum_jx_i+(dp_j+xsum_j)\}+x_isum_i-xsum_i+c_i\)</span></p><p>这里<span class="math inline">\(sum_j\)</span>是单调增的</p><p>考虑<span class="math inline">\(a&lt;yb\)</span>,且b优于a:</p><p>令<span class="math inline">\(f_j=dp_j+xsum_j\)</span></p><p><span class="math inline">\(-sum_bx_i+f_b\leq-sum_ax_i+f_a\)</span></p><p><span class="math inline">\(\frac{f_b-f_a}{sum_b-sum_a}\leqx_i\)</span>,这里我们要维护的就是一个下凸包了，并且斜率<spanclass="math inline">\(K(X)=x_i\)</span>是单调增的</p><p>因此直接套板子即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ty</span><br>&#123;<br>    ll x,p,c;<br>&#125;mas[N];<br>ll sum[N];<br>ll xsum[N];<br>ll n;<br>ll dp[N];<br>ll que[N];<br><span class="hljs-function">ll <span class="hljs-title">gt</span><span class="hljs-params">(ll l,ll r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> mas[r].x*(sum[r]-sum[l])-(xsum[r]-xsum[l]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Slope</span><span class="hljs-params">(ll a,ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(sum[a]==sum[b]) <span class="hljs-keyword">return</span> inf;<br>    <span class="hljs-type">double</span> x=(dp[a]+xsum[a]-dp[b]-xsum[b])*<span class="hljs-number">1.0</span>;<br>    <span class="hljs-type">double</span> y=(sum[a]-sum[b])*<span class="hljs-number">1.0</span>;<br>    <span class="hljs-keyword">return</span> x/y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) cin&gt;&gt;mas[i].x&gt;&gt;mas[i].p&gt;&gt;mas[i].c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) sum[i]=sum[i<span class="hljs-number">-1</span>]+mas[i].p,xsum[i]=xsum[i<span class="hljs-number">-1</span>]+mas[i].x*mas[i].p;<br>    ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>    que[++tl]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[hd],que[hd+<span class="hljs-number">1</span>])&lt;mas[i].x) hd++;<br>        dp[i]=dp[que[hd]]+<span class="hljs-built_in">gt</span>(que[hd],i)+mas[i].c;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[tl<span class="hljs-number">-1</span>],que[tl])&gt;<span class="hljs-built_in">Slope</span>(que[tl],i)) tl--;<br>        que[++tl]=i;<br>    &#125;<br>    ll pos=n;<br>    <span class="hljs-keyword">while</span>(mas[pos].p==<span class="hljs-number">0</span>) pos--;<br>    ll ans=inf;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=pos;i&lt;=n;++i) ans=<span class="hljs-built_in">min</span>(ans,dp[i]);<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>PS:此题有其它坑点，读者自己小心~</p><p><a href="https://www.luogu.com.cn/problem/P2900">[USACO08MAR] LandAcquisition G</a></p><p>大意：</p><p>将<spanclass="math inline">\(n\)</span>块土地分组，每组的价格是这组土地中最大的长宽乘积，问买下所有土地的最小花费。</p><p>思路：</p><p>个人感觉一开始的思路还是有点妙的</p><p>不妨按照长升序排序，如果长相同就宽升序</p><p>从前往后遍历的时候，考虑<spanclass="math inline">\(i&lt;j\)</span>，显然如果<spanclass="math inline">\(i,j\)</span>放一组，长一定是取<spanclass="math inline">\(j\)</span>的，那么如果<spanclass="math inline">\(j\)</span>的宽也大于<spanclass="math inline">\(i\)</span>的话，那么<spanclass="math inline">\(i\)</span>就没有任何贡献。所以我们可以用一个栈来维护，把没用的东西踢掉。显然在最优决策下，每一组的土地会是连续的一段</p><p>考虑<spanclass="math inline">\(dp_i\)</span>表示排序弹出处理之后前i个土地的最小值：</p><p><span class="math inline">\(dp_i=min_{j\leqi}\{dp_j+b_{j+1}a_i\}\)</span>,其中<spanclass="math inline">\(a\)</span>表示长，<spanclass="math inline">\(b\)</span>表示宽</p><p>这里<spanclass="math inline">\(b_j\)</span>在处理之后是降序的，我们可以转化成<spanclass="math inline">\(dp_i=min_{j\leqi}\{dp_j-b&#39;_{j+1}a_i\},b&#39;_j=-b_j\)</span></p><p>考虑<span class="math inline">\(x&lt;y\)</span>,且y优于x</p><p><span class="math inline">\(-b&#39;_ya_i+dp_j\leq-b&#39;_xa_i+dp_x\)</span></p><p><span class="math inline">\(\frac{dp_x-dp_y}{b&#39;_x-b&#39;_y}\leqa_i\)</span>，还是维护一个下凸包，并且斜率<spanclass="math inline">\(a_i\)</span>是单增的，所以也是直接套板子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ty</span><br>&#123;<br>    ll a,b;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> ty &amp; B) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(a==B.a) <span class="hljs-keyword">return</span> b&lt;B.b;<br>        <span class="hljs-keyword">return</span> a&lt;B.a;<br>    &#125;<br>&#125;mas[N];<br>ll n;<br>ll que[N];<br>ll dp[N];<br>ty st[N];<br>ll top=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Slope</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(st[x+<span class="hljs-number">1</span>].b==st[y+<span class="hljs-number">1</span>].b) <span class="hljs-keyword">return</span> inf;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>*((dp[y]-dp[x])/(-st[y+<span class="hljs-number">1</span>].b+st[x+<span class="hljs-number">1</span>].b));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;mas[i].a&gt;&gt;mas[i].b;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(mas+<span class="hljs-number">1</span>,mas+<span class="hljs-number">1</span>+n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(top)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(mas[i].b&gt;=st[top].b) top--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        st[++top]=mas[i];<br>    &#125;<br>    ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>    que[++tl]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=top;++i)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[hd],que[hd+<span class="hljs-number">1</span>])&lt;st[i].a) hd++;<br>        <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;que[hd]&lt;&lt;endl;</span><br>        dp[i]=dp[que[hd]]+st[que[hd]+<span class="hljs-number">1</span>].b*st[i].a;<br>        <span class="hljs-keyword">while</span>(hd&lt;tl&amp;&amp;<span class="hljs-built_in">Slope</span>(que[tl<span class="hljs-number">-1</span>],que[tl])&gt;<span class="hljs-built_in">Slope</span>(que[tl],i)) tl--;<br>        que[++tl]=i;<br>    &#125;<br>    cout&lt;&lt;dp[top]&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><ahref="https://www.luogu.com.cn/problem/P4027">[ZJOI2007]仓库建设</a></p><p>大意：</p><p><del>本人太懒。。。</del></p><p>思路：</p><p>这题就是需要cdq分治的题了</p><p>考虑<spanclass="math inline">\(f_i\)</span>表示第i天能够获得的最大钱数，<spanclass="math inline">\(g_i\)</span>表示第i天最多能买多少张B券</p><p>则<span class="math inline">\(\largeg_i=\frac{f_i}{r_ia_i+b_i}\)</span></p><p>故<span class="math inline">\(f_i=max\{max_{j\leqi-1}\{g_j\frac{b_i}{a_i}+r_jg_j\}*a_i,f_{i-1}\}\)</span></p><p>外层的max我们可以直接特判，内层的max就是一个典型的斜率优化dp了。</p><p>考虑<spanclass="math inline">\(g_x&lt;g_y\)</span>,且y优于x（这里<spanclass="math inline">\(g\)</span>不是单调的，我们不能直接假设<spanclass="math inline">\(x&lt;y\)</span>）,l令<spanclass="math inline">\(F_j=r_jg_j\)</span></p><p><span class="math inline">\(g_x\frac{b_i}{a_i}+F_x\geqg_y\frac{b_i}{a_i}+F_y\)</span></p><p>即<span class="math inline">\(\large \frac{F_x-F_y}{g_x-g_y}\leq-\frac{b_i}{a_i}\)</span></p><p>实际还是一个下凸包。这里横坐标是<spanclass="math inline">\(g_j\)</span>,纵坐标是<spanclass="math inline">\(F_j\)</span>,斜率是<spanclass="math inline">\(-\frac{b_i}{a_i}\)</span></p><p>横坐标不是单调的，斜率也不是单调的，看起来不是能用普通凸包来维护的样子。所以我们可以使用cdq分治</p><p>想要用单调队列维护凸包的话，我们实际上有三维偏序：</p><ul><li>对于每一个i，它的决策点是<spanclass="math inline">\(\{j|j&lt;i\}\)</span>，也就是id较小的点才可以更新id较大的点</li><li>维护凸包的时候，如果x先于y加入凸包，要满足<spanclass="math inline">\(g_x&lt;g_y\)</span></li><li>凸包查询最优决策点的时候，如果x先于y查询，要满足<spanclass="math inline">\(K(x)&lt;K(y)\)</span>，因为我们要利用决策点不降的性质来加速选择最优点的过程</li></ul><p>显然，三维偏序正是cdq分治的拿手好戏~</p><ul><li>第一关键字：首先将点按照斜率升序排序，能够保证查询的斜率递增，从而能用单调队列维护</li><li>第二关键字：分治时按照id分成左右两个部分。这样保证最后递归到叶子节点的时候是符合原本顺序的，且斜率查询的时候保证都是维护的点的id都是在自己之前的（其实就是一个归并排序）</li><li>第三关键字：x每次分治结束之后内部不再有贡献，所以我们可以直接按照横坐标升序排序方便后面维护凸包</li></ul><p>我们会发现这样处理之后就能够实现三维偏序了。</p><p>cdq分治的灵魂是用前半部分的信息来统计对后半部分的贡献，当一段区间分治结束之后，这段区间内的信息就全部处理完了，换句话说，区间内部的点之间是不会再产生贡献了，因此我们才可以随意更改该区间内部的点的顺序。将其按照横坐标排序，我们才能进行凸包的维护。同时，以横坐标为关键字的排序我们可以直接sort，但是也可以采用归并排序</p><p>最后，求出<span class="math inline">\(f_i\)</span>之后，再与<spanclass="math inline">\(f_{i-1}取max\)</span>，并更新<spanclass="math inline">\(g_i\)</span></p><p>具体流程：</p><ul><li>if(l==r) 更新，退出</li><li>按照id分成左右两部分<spanclass="math inline">\([l,mid],(mid,r]\)</span></li><li>cdq(l,mid)</li><li>此时<spanclass="math inline">\([l,mid]\)</span>已经处理好了，所以用单调队列对<spanclass="math inline">\([l,mid]\)</span>建凸包</li><li><span class="math inline">\((mid,r]\)</span>区间此时是以<spanclass="math inline">\(\frac{-b_i}{a_i}\)</span>升序,所以按顺序更新即可，并更新凸包</li><li>cdq(mid+1,r)</li><li>按照横坐标对<spanclass="math inline">\([l,r]\)</span>进行归并，因为该区间内部不会再有互相的贡献了</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> il inline</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> double long double</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps =<span class="hljs-number">1e-8</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e17</span>;<br>ll n;<br><span class="hljs-type">double</span> s;<br><span class="hljs-type">double</span> A[N],B[N],R[N];<br><span class="hljs-type">double</span> f[N],X[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ty</span><br>&#123;<br>    ll id;<br>    <span class="hljs-type">double</span> slope;<br>    <span class="hljs-type">double</span> a,b,k;<br>    <span class="hljs-comment">//第一关键字：斜率 按照斜率升序能够保证查询的斜率递增，从而能用单调队列维护</span><br>    <span class="hljs-comment">//第二关键字：id 分治时按照id分成左右两个部分。这样保证最后递归到叶子节点的时候是符合原本顺序的</span><br>    <span class="hljs-comment">//且斜率查询的时候保证都是维护的点的id都是在自己之前的</span><br>    <span class="hljs-comment">//第三关键字：x 每次分治结束之后内部不再有贡献，则按照x升序排方便后面维护凸包</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> ty &amp; b) <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(slope==b.slope) <span class="hljs-keyword">return</span> id&lt;b.id;<br>        <span class="hljs-keyword">return</span> slope&gt;b.slope;<span class="hljs-comment">//斜率递减</span><br>    &#125;<br>&#125;mas[N],tmp[N];<br>ll que[N];<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Slope</span><span class="hljs-params">(ll x,ll y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(X[mas[x].id]==X[mas[y].id])<br>    &#123;<br>        <span class="hljs-keyword">return</span> inf;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (X[mas[y].id]*mas[y].k-X[mas[x].id]*mas[x].k)/(X[mas[y].id]-X[mas[x].id]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upd</span><span class="hljs-params">(<span class="hljs-type">int</span> id,<span class="hljs-type">double</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[mas[id].id]&lt;val)<br>    &#123;<br>        f[mas[id].id]=val;<br>        X[mas[id].id]=f[mas[id].id]/(mas[id].k*mas[id].a+mas[id].b);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cdq</span><span class="hljs-params">(ll l,ll r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l==r)<br>    &#123;<br>        f[mas[l].id] = <span class="hljs-built_in">max</span>(f[mas[l].id],f[mas[l].id<span class="hljs-number">-1</span>]);<span class="hljs-comment">//这里的f_&#123;i-1&#125;是所有排序前的i-1，所以要稍微绕一下，注意别弄错</span><br>        X[mas[l].id]=f[mas[l].id]/(mas[l].k*mas[l].a+mas[l].b);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ll mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>    ll posl=l,posr=mid+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(mas[i].id&lt;=mid) tmp[posl++]=mas[i];<br>        <span class="hljs-keyword">else</span> tmp[posr++]=mas[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;++i) mas[i]=tmp[i];<br>    <span class="hljs-comment">//按照id处理好了</span><br>    <span class="hljs-built_in">cdq</span>(l,mid);<br>    <span class="hljs-comment">//先处理前一个部分，保证此时前半部分的x是升序的</span><br>    ll hd=<span class="hljs-number">1</span>,tl=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=mid;++i)<span class="hljs-comment">//维护凸包</span><br>    &#123;<br>        <span class="hljs-keyword">while</span>(tl&gt;hd&amp;&amp;<span class="hljs-built_in">Slope</span>(que[tl<span class="hljs-number">-1</span>],que[tl])&lt;<span class="hljs-built_in">Slope</span>(que[tl],i)+eps) tl--;<br>        que[++tl]=i;<br>    &#125;<br>    ll id;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=mid+<span class="hljs-number">1</span>;i&lt;=r;++i)<span class="hljs-comment">//计算两边产生的贡献</span><br>    &#123;<br>        <span class="hljs-keyword">while</span>(tl&gt;hd&amp;&amp;<span class="hljs-built_in">Slope</span>(que[hd],que[hd+<span class="hljs-number">1</span>])&gt;mas[i].slope) hd++;<br>        <span class="hljs-built_in">upd</span>(i,X[mas[que[hd]].id]*(mas[que[hd]].k-mas[i].slope)*mas[i].a);<br>    &#125;<br>    <span class="hljs-built_in">cdq</span>(mid+<span class="hljs-number">1</span>,r);<br><br>    posl=l,posr=mid+<span class="hljs-number">1</span>;<br>    ll tot=l<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(posl&lt;=mid&amp;&amp;posr&lt;=r)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(X[mas[posl].id]&lt;X[mas[posr].id]) tmp[++tot]=mas[posl++];<br>        <span class="hljs-keyword">else</span> tmp[++tot]=mas[posr++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(posl&lt;=mid) tmp[++tot]=mas[posl++];<br>    <span class="hljs-keyword">while</span>(posr&lt;=r) tmp[++tot]=mas[posr++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l;i&lt;=r;++i) mas[i]=tmp[i];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)<br>    &#123;<br>        cin&gt;&gt;A[i]&gt;&gt;B[i]&gt;&gt;R[i];<br>        mas[i].id=i;<br>        mas[i].a=A[i];mas[i].b=B[i];mas[i].k=R[i];<br>        mas[i].slope=-B[i]/A[i];<br>        <span class="hljs-comment">// if(i&gt;1) continue;</span><br>        X[mas[i].id]=s/(R[i]*A[i]+B[i]);<br>        <span class="hljs-comment">// mas[i].y=R[i]*mas[i].x;</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) f[i]=s;<br>    <span class="hljs-built_in">sort</span>(mas+<span class="hljs-number">1</span>,mas+<span class="hljs-number">1</span>+n);<br>    <span class="hljs-built_in">cdq</span>(<span class="hljs-number">1</span>,n);<br>    cout&lt;&lt;fixed&lt;&lt;<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">4</span>)&lt;&lt;f[n]&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// freopen(&quot;1.out&quot;,&quot;w&quot;,stdout);</span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="后记">后记</h3><p>斜率优化dp在大部分情况下都是结合决策单调性进行的（<strong>大部分</strong>），所以也比较套路</p><p>另外还有结合Wqs二分来处理前n个数限定分m段的情况等的套路，个人感觉决策单调性优化的水还是有点深的，有空会试试写一期总结</p><p>加油~</p>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划 Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>群作用</title>
    <link href="/2023/12/19/%E7%BE%A4%E4%BD%9C%E7%94%A8/"/>
    <url>/2023/12/19/%E7%BE%A4%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="群作用轨道-稳定化子定理">群作用，轨道-稳定化子定理</h1><p>不妨通过一个简单的例子来引入群作用的概念，恕我直言这个东西真的很神奇</p><h2 id="引入">引入</h2><blockquote><p>令<spanclass="math inline">\(S\)</span>是一个非空集合，我们考虑所有<spanclass="math inline">\(S \rightarrow S\)</span>的双射<spanclass="math inline">\(f\)</span>所组成的集合，记为<spanclass="math inline">\(Perm(S)\)</span>，事实上它关于映射的复合作成一个群，即<span class="math inline">\(S\)</span>上的置换群，即<spanclass="math inline">\((Perm(s),\circ)\)</span></p></blockquote><p>接下来考虑群<spanclass="math inline">\(G\)</span>上，对于一个特定的元素<spanclass="math inline">\(x\in G\)</span>的映射： <spanclass="math inline">\(\phi_x: G\rightarrow G,a\mapstoxa\)</span>,事实上它是一个双射，对于这一点我们只需证明<spanclass="math inline">\(\phi_x\)</span>存在逆映射即可。显然<spanclass="math inline">\(\phi_x\)</span>的逆映射就是<spanclass="math inline">\(\phi_{x^{-1}}: G\rightarrow G,a\mapstox^{-1}a\)</span>，</p><p><font color='orange'><strong>证明： </strong></font> <spanclass="math display">\[(\phi_x\circ\phi_{x^{-1}})(a)=\phi_x((\phi_{x^{-1}}(a)))=\phi_x(x^{-1}a)=xx^{-1}a=a=Id(a)\\(\phi_{x^{-1}}\circ\phi_{x})(a)=\phi_{x^{-1}}((\phi_{x}(a)))=\phi_{x^{-1}}(xa)=x^{-1}xa=a=Id(a)\\\]</span> 其中<span class="math inline">\(Id\)</span>就表示<spanclass="math inline">\(S\rightarrow S\)</span>的恒等映射</p><p>那么此时就有<spanclass="math inline">\((\phi_x)^{-1}=\phi_{x^{-1}}\)</span> ，故<spanclass="math inline">\(\phi_x\)</span>是<spanclass="math inline">\(G到G\)</span>的一个双射 <spanclass="math inline">\(\square\)</span></p><hr /><p>我们很快就注意到<strong><span class="math inline">\(\phi_x\inPerm(G)\)</span></strong> 。将目光从<spanclass="math inline">\(\phi_x\)</span>上再抽象出来一层，我们定义映射<spanclass="math inline">\(\phi:(G,\cdot)\rightarrow (Perm(G),\circ),x\mapsto\phi_x\)</span>。这里有点抽象，前者是一个群<spanclass="math inline">\(G\)</span>，后者也是一个群，但是它是从一个<strong>集合</strong><spanclass="math inline">\(G\)</span>当中得到的，在这个集合里我们忽略了<spanclass="math inline">\(G\)</span>的运算的结构，只考虑它作为集合的结构，从而得到所有在其上的双射组成的<spanclass="math inline">\((Perm(G),\circ)\)</span></p><p>映射的两个对象都是群，令人惊奇的是，事实上<spanclass="math inline">\(\phi\)</span>也是一个群同态：</p><p><font color='orange'><strong>证明：</strong></font></p><p><span class="math inline">\(\phi是良定义的:这一点显然\\\)</span></p><p><span class="math inline">\(\forall x,y\in G，z\in G\)</span> <spanclass="math display">\[(\phi_x\circ\phi_y)(z)=x(yz)=(xy)z=\phi_{xy}(z)\]</span> 对于所有的<spanclass="math inline">\(z\)</span>都满足该性质，故 <spanclass="math display">\[\phi_x\circ \phi_y=\phi_{xy}\]</span> 故 <span class="math display">\[\phi(x\cdot y)=\phi(x)\circ \phi(y)\]</span> <strong>故<span class="math inline">\(\phi\)</span>是<spanclass="math inline">\(G\rightarrow Perm(G)\)</span>的一个群同态</strong> <span class="math inline">\(\square\)</span></p><p>这样的一个神奇的<spanclass="math inline">\(\phi\)</span>就是一个群作用。现在我们给出定义如下</p><h2 id="定义1">定义1</h2><blockquote><p>令<span class="math inline">\(G\)</span>是一个群，<spanclass="math inline">\(S\)</span>是一个非空集合，若<spanclass="math inline">\(\phi:G\rightarrowPerm(S)\)</span>是一个<strong>群同态</strong>，那么称<spanclass="math inline">\(\phi\)</span>是<strong>群</strong><spanclass="math inline">\(G\)</span>在<strong>集合</strong><spanclass="math inline">\(S\)</span>上的一个群作用</p></blockquote><p>在上例中集合<span class="math inline">\(S\)</span>恰好就是<spanclass="math inline">\(G\)</span>本身，但是我们也强调过在<spanclass="math inline">\((Perm(G),\circ)\)</span>中我们已经忽略了<spanclass="math inline">\(G\)</span>作为群的运算结构而只考虑其集合的结构</p><p>从这个定义中我们可以很清晰地看到<spanclass="math inline">\(\phi\)</span>作为一个群同态的优美性质，但是实际上还有另外一种等价的定义，它能帮助我们更好地判断一个映射是否为群作用</p><h2 id="定义2">定义2</h2><blockquote><p>令<span class="math inline">\(G\)</span>是一个群，<spanclass="math inline">\(S\)</span>是一个非空集合，如果映射 <spanclass="math display">\[\sigma: G\cross S\rightarrow S\\\forall a\in G,x\in S,(a,x)\mapstoa\cdot x\\我们记为a作用在x上\]</span> 满足： <span class="math display">\[e\cdot x=x,\forall x\in S\\(ab)\cdot x=a\cdot(b\cdot x),\forall a,b \inG,x\in S\]</span> 那么称群<span class="math inline">\(G\)</span>在集合<spanclass="math inline">\(S\)</span>上<strong>有一个作用</strong> <spanclass="math inline">\((a,x)\mapsto a\cdot x\)</span></p></blockquote><p>仔细观察定义1，<spanclass="math inline">\(\phi\)</span>是我们的群作用，是一个<spanclass="math inline">\(G\rightarrowPerm(s)\)</span>的映射，现在我们取出一个<spanclass="math inline">\(x\)</span>，得到一个<spanclass="math inline">\(\phi_x\inPerm(S)\)</span>,它又是一个映射（事实上是双射），它作用在<spanclass="math inline">\(s\in S\)</span>,会得到<spanclass="math inline">\(\phi_x(s)\in S\)</span>。整个过程实际上就是在<spanclass="math inline">\(G\)</span>中取出一个元素x，在<spanclass="math inline">\(S\)</span>中取出一个元素<spanclass="math inline">\(s\)</span>,也就是对应<spanclass="math inline">\(G\cross S\)</span>,得到一个<spanclass="math inline">\(S\)</span>中的元素，这一过程解释了在定义2中<spanclass="math inline">\(\sigma\)</span>为什么是<spanclass="math inline">\(G\cross S\rightarrow S\)</span>的映射。</p><h2 id="两个定义的联系">两个定义的联系</h2><p>下面我们来证明两个定义其实是等价的：</p><p><font color='orange'><strong>证明:</strong></font></p><p>定义1$$定义2：</p><p>首先<span class="math inline">\(\phi\)</span>确实是<spanclass="math inline">\(G\cross S\rightarrowS\)</span>的映射，我们定义双射 <span class="math display">\[\phi_a: S\rightarrow S\\(a,x)\mapsto a\cdot x,a\in G,x\in S\\\]</span> 则： <span class="math display">\[\forall x\in S,e\cdot x=\phi_e(x)=Id(x)=x,故第一条得证\\\forall a,b\inG,(ab)\cdot x=\phi_{ab}(x)=(\phi_a\circ\phi_b)(x)=\phi_a(\phi_b(x))=\phi_a(b\cdot x)=a\cdot(b\cdotx)\\从而第二条得证\]</span> 定义2<spanclass="math inline">\(\rightarrow\)</span>定义1：</p><p>还是定义 <span class="math display">\[\phi: G\rightarrow Perm(S)\\x\mapsto\phi_x\\其中\phi_x: S\rightarrow S\\s\mapsto x\cdot s,s\in S\]</span> 首先证明<spanclass="math inline">\(\phi_x\)</span>确实是一个双射： <spanclass="math display">\[x\cdot(x^{-1}\cdot s)=(xx^{-1})\cdot s=e\cdot s= s\\x^{-1}\cdot(x\cdots)=(x^{-1}x)\cdot s=e\cdot s= s\]</span> 故<spanclass="math inline">\((\phi_x)^{-1}=\phi_{x^{-1}}\)</span>,所以它确实是一个双射。这一结论是由性质1保证的，因为<spanclass="math inline">\(e\cdot s=s\)</span></p><p>而由性质2，我们知道<spanclass="math inline">\(\phi\)</span>保持运算，所以<spanclass="math inline">\(\phi\)</span>是一个<spanclass="math inline">\(G\rightarrow Perm(S)\)</span>的群同态，所以<spanclass="math inline">\(\phi\)</span>就是群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(S\)</span>上的作用 <spanclass="math inline">\(\square\)</span></p><p>所以第一条性质是为了保证良定义，第二条性质是为了保证群同态，两者合在一起就是对群作用的定义</p><p>这样我们对一个映射就有了判断的条件了，也认识到了其优美的同态性质</p><blockquote><p>同时，如果我们认识到了群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(S\)</span>上有一个群作用 <spanclass="math display">\[(a,x)\mapsto a\cdot x,a\in G,x\in S\]</span> 那么 <span class="math display">\[\phi:G\rightarrow Perm(S)\\x\mapsto a\cdot x\]</span> 就一定是群<span class="math inline">\(G\)</span>到集合<spanclass="math inline">\(S\)</span>的群同态，以及 <spanclass="math display">\[\forall a\in G,\phi_a是S\rightarrow S的双射\]</span> <font color='red'>（当然<spanclass="math inline">\(\phi_a\)</span>不一定是群同态）</font></p></blockquote><h2 id="群作用的核">群作用的核</h2><p>群作用的核定义为定义1中同态<spanclass="math inline">\(\phi\)</span>的核，即<spanclass="math inline">\(Ker\phi\)</span></p><p>故 <span class="math display">\[a\in G是群作用的核\\\Leftrightarrow \phi_a=Id\\ \Leftrightarrow\phi_a(x)=x,\forall x\in S \\\Leftrightarrow a\cdot x=x,\forall x\in S\]</span></p><h2 id="群作用的例子">群作用的例子</h2><p>我们重新审视一下开头讲的例子</p><h3 id="群g在集合g上的左平移">群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(G\)</span>上的左平移</h3><p>令 <span class="math display">\[G\cross G\rightarrow G\\x\mapsto ax      (1)\]</span> 显然有 <span class="math display">\[ex=x,\forall x\in G\\(ab)x=a(bx),\forall a,b\in G,\forall x\in G\]</span> 所以<spanclass="math inline">\((1)\)</span>式给出了一个群作用。这里我们用定义2重新证明了这是一个群作用。</p><p>我们考察一下这个群作用的核 <span class="math display">\[a\in G属于群作用的核\\\Leftrightarrow ax=x,\forall x\inG\\\Leftrightarrow a=e\]</span> 故群作用的核为<spanclass="math inline">\(\{e\}\)</span>,所以<spanclass="math inline">\(\phi:G\rightarrowPerm(G)\)</span>是一个单同态。那么显然<span class="math inline">\(G\congIm\phi\)</span>。又<spanclass="math inline">\(Im\phi&lt;Perm(G)\)</span>,所以群<spanclass="math inline">\(G\)</span>与集合<spanclass="math inline">\(G\)</span>上的一个变换群同构！</p><p>如此我们很轻松地就证明了<spanclass="math inline">\(Cayley\)</span>定理：任意一个群都同构于某一个集合上的变换群</p><p>推论：<font color='blue'>任意一个<strong>有限群</strong>都同构于一个<strong>置换群</strong></font></p><hr /><h3 id="群g在集合g上的共轭作用">群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(G\)</span>上的共轭作用</h3><p>令 <span class="math display">\[G\cross G\rightarrow G\\x\mapsto axa^{-1}      (2)\]</span> 显然有 <span class="math display">\[exe^{-1}=x,\forall x\in G\\(ab)\cdot x=abxb^{-1}a^{-1}=a\cdot(bxb^{-1})=a\cdot(b\cdot x)\]</span> 故<spanclass="math inline">\((2)\)</span>式同样给出了一个群作用，叫做群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(G\)</span>上的共轭作用</p><p>考察该作用的核 <span class="math display">\[a\in G属于群作用的核\\\Leftrightarrow axa^{-1}=x\\\Leftrightarrowax=xa\\ \Leftrightarrowa\in \{b\in G|bx=xb,\forall x\in G\}=Z(G)\]</span> 这里<span class="math inline">\(Z(G)\)</span>称为群<spanclass="math inline">\(G\)</span>的中心。得到<spanclass="math inline">\(Ker\phi=Z(G)\)</span>。</p><p>这里共轭作用比左乘作用的性质要更好一些，因为实际上对于一个作用来说，根据我们之前所说，<span class="math display">\[\phi_a: G\rightarrow G\\x\mapsto axa^{-1}(3)\]</span></p><p>一定是双射，但是却未必是群同态，而共轭作用的每一个<spanclass="math inline">\(\phi_x\)</span><font color='red'>都是一个群同态</font>，从而<font color='red'>都是群同构</font></p><p><strong><font color='orange'>证明：</font></strong></p><p>因为<spanclass="math inline">\(\phi_a\)</span>都是双射，我们只需证明它是群同态即可（不是说<spanclass="math inline">\(\phi\)</span>是群同态，而是对每一个<spanclass="math inline">\(\phi_a\)</span>都是群同态） <spanclass="math display">\[\forall y,z\inG,\phi_a(yz)=a(yz)a^{-1}=aya^{-1}aza^{-1}=\phi_a(y)\phi_a(z)\]</span> 这就证明了共轭作用下每一个<spanclass="math inline">\(\phi_a\)</span>都是<strong>群<spanclass="math inline">\(G\)</span>到自身</strong>的群同构 <spanclass="math inline">\(\square\)</span></p><p>我们称群<spanclass="math inline">\(G\)</span>到自身的同构映射为自同构(automorphism),而由<spanclass="math inline">\((3)\)</span>式定义的同构称为内自同构(innerautomorphism) <span class="math display">\[f是群G的内自同构\Leftrightarrow f是G的共轭作用给出的一个自同构\]</span></p><p>然后我们来研究一些更加深入的东西</p><h2 id="轨道-稳定化子定理">轨道-稳定化子定理</h2><h3 id="轨道">轨道</h3><p>令 <span class="math display">\[\phi:G\rightarrow Perm(s)\\\phi_a(x)=a\cdot x\]</span> 是一个群作用</p><p>那么定义<span class="math inline">\(s\in S\)</span>的轨道<spanclass="math inline">\(Orb(s)\)</span>为 <span class="math display">\[Orb(s)=\{s&#39;\in S|\exist x\in G,xs&#39;=s\}=\{xs|x\in G\}\]</span> 也就是<span class="math inline">\(s\)</span>在所有<spanclass="math inline">\(x\)</span>的作用下能到达的点的集合。我们很快就能看到这个定义有什么用</p><blockquote><p>所有元素<span class="math inline">\(s\)</span>的轨道是集合<spanclass="math inline">\(S\)</span>的一个划分，即</p></blockquote><p><strong><font color='orange'>证明：</font></strong></p><p>定义集合<span class="math inline">\(S\)</span>上的一个二元关系 <spanclass="math display">\[y\sim x\Leftrightarrow \exist a\in G,y=a\cdot x\]</span> 不难验证<spanclass="math inline">\(\sim\)</span>是一个等价关系。所以它给出<spanclass="math inline">\(S\)</span>上的一个划分 <spanclass="math display">\[\begin{flalign}\forall x\in S,\bar{x}&amp;=\{y\in S|y\sim x\}\\&amp;=\{y\in S|\exista\in G,y=a\cdot x\}\\&amp;=\{a\cdot x|a\in G\}\\&amp;=Orb(x)\end{flalign}\\\]</span> <span class="math inline">\(\square\)</span></p><h3 id="一些杂谈">一些杂谈</h3><p>我们先来看看<span class="math inline">\(T\cross X\rightarrowX\)</span>的映射<spanclass="math inline">\(\phi\)</span>,当然它不一定满足群作用的性质，但是这个结构本身有很多值得研究的东西</p><p>不过我们不妨还是定义<span class="math inline">\((t,x)\mapsto t\cdotx\)</span></p><ul><li><p>令<span class="math inline">\(t\in T\)</span>，则集合 <spanclass="math display">\[\{x\in X|t\cdot x=x\}\]</span> 表示的是在变换t下不变的元素</p></li><li><p>令<span class="math inline">\(K\subset T\)</span>，则集合 <spanclass="math display">\[\{x\in X|\forall t\in K,t\cdot x=x\}\]</span> 表示的是在<spanclass="math inline">\(K\)</span>中所有变换<spanclass="math inline">\(t\)</span>下都保持不变的x的集合</p></li></ul><p>相对应的，我们以<spanclass="math inline">\(x\)</span>为主视角看看</p><ul><li><p>令<span class="math inline">\(x\in X\)</span>,则集合 <spanclass="math display">\[\{t\in T|t\cdot x=x\}\]</span> 表示的是固定了<spanclass="math inline">\(x\)</span>的所有变换t</p></li><li><p>令<span class="math inline">\(A\subset X\)</span>,则集合 <spanclass="math display">\[\{t\in T|\forall x\in A,t\cdot x=x\}\]</span> 表示的是固定了A中所有元素<spanclass="math inline">\(x\)</span>的t的集合</p></li></ul><p>事实上，只要给定了形如<span class="math inline">\(T\crossX\rightarrowX\)</span>的映射，我们都能很清晰地指出以上四个集合的内容</p><p>现在再回过头来看稳定化子。</p><h3 id="稳定化子">稳定化子</h3><p>定义<span class="math inline">\(s\in S\)</span>的稳定化子<spanclass="math inline">\(Stab(s)\)</span>为 <span class="math display">\[Stab(s)=\{x\in G|xs=s\}\]</span> 也就是固定了元素<spanclass="math inline">\(s\)</span>的所有<spanclass="math inline">\(x\)</span>,实际上也就是上文的第三个集合</p><blockquote><p>Stab(s)&lt;G</p></blockquote><p><strong><font color='orange'>证明：</font></strong></p><p><span class="math inline">\(\forall x,y\in Stab(s)\)</span>,有 <spanclass="math display">\[x\cdot s=y\cdot s=s\]</span> 从而<span class="math inline">\(x^{-1}\cdot s=x^{-1}\cdot(x\cdot s)=(x^{-1}x)\cdot s=e\cdot s=s\)</span>（关键步骤）</p><p>所以 <span class="math display">\[(yx^{-1})\cdot s=y(x^{-1}\cdot s)=y\cdot s=s\]</span> 故 <span class="math display">\[yx^{-1}\in Stab(s)\]</span> 从而<span class="math inline">\(Stab(s)&lt;G\)</span> <spanclass="math inline">\(\square\)</span></p><p><font color='red'>稍微总结一下我们就能看到一个很眼熟的东西</font></p><h4 id="引理1">引理1</h4><blockquote><p>令<span class="math inline">\(\phi:G\rightarrowPerm(S)\)</span>是一个群作用，则 <span class="math inline">\(\forallx,y\in G,s\in S,x\cdot s=y\cdot s\Leftrightarrow xy^{-1}\inStab(s)\)</span></p></blockquote><p>这与</p><blockquote><p>H&lt;G,则<span class="math inline">\(\forall x,y\inG,xH=yH\Leftrightarrow xy^{-1}\in H\)</span></p></blockquote><p>是很像的</p><p>现在我们知道<spanclass="math inline">\(Stab(s)\)</span>里的元素保持<spanclass="math inline">\(s\)</span>不变，我们还可以再探究一下其同一个陪集的元素对<spanclass="math inline">\(s\)</span>的作用</p><h4 id="引理2">引理2</h4><p><span class="math display">\[\begin{flalign}&amp;aStab(s)=bStab(s)\\&amp;\Leftrightarrow b^{-1}a\in Stab(s)\\&amp;由引理\\&amp;\Leftrightarrow a\cdot s=b\cdot s\end{flalign}\]</span></p><p>所以同一个陪集里的元素对<spanclass="math inline">\(s\)</span>的作用是一样的</p><p>从而我们令 <span class="math display">\[\phi:(G/Stab(s))_l\rightarrow Orb(s)\\ aStab(s)\mapsto a\cdot s\]</span> 那么从而我们可以通过引理2的正向推和逆向推得到<spanclass="math inline">\(\phi\)</span>的合理性以及单射的性质，又由于<spanclass="math inline">\(\phi\)</span>显然是一个满射，从而<spanclass="math inline">\(\phi\)</span>是一个<font color='red'><strong>双射！</strong></font></p><p>如次我们就证得了</p><h3 id="轨道-稳定化子定理-1">轨道-稳定化子定理</h3><blockquote><p>令<span class="math inline">\(\phi:G\rightarrowPerm(S)\)</span>是一个群作用，则<span class="math inline">\(\forall s\inS\)</span>,存在<span class="math inline">\((G/Stab(s))_l\)</span>到<spanclass="math inline">\(Orb(s)\)</span>的双射</p><p>从而<span class="math inline">\(|Orb(s)|=[G:Stab(s)]\)</span></p><p>若<span class="math inline">\(G\)</span>为有限群，则有<strong><spanclass="math inline">\(|G|=|Orb(s)|*|Stab(s)|\)</span></strong></p></blockquote><p>举一个形象的例子</p><p>二面体群 <spanclass="math inline">\(D_{2n}\)</span>，它是由所有正<spanclass="math inline">\(n\)</span>边形到自身的对称变换所构成的。对称变换,就是把<strong>自身映到自身</strong>，而且是保距的。保距指的是，原先距离相同的点，变换后距离仍然相同</p><blockquote><p><span class="math inline">\(|D_{2n}|=2n\)</span></p></blockquote><p><font color='orange'><strong>证明：</strong></font></p><p>首先正n边形有n个旋转变换，以及n个对称变换（绕n个对称轴分别翻转），这样就有<spanclass="math inline">\(2n\)</span>个元素了，我们要证明只有这些元素</p><p>任取正n边形的一个顶点<spanclass="math inline">\(s\)</span>,考虑其轨道<spanclass="math inline">\(Orb(s)\)</span>,最多只能到达n个顶点，而n个旋转变换就恰好可以让s到达n个不同顶点，所以<spanclass="math inline">\(|Orb(s)|=n\)</span></p><p>然后考虑<span class="math inline">\(Stab(s)\)</span>,我们要保持<spanclass="math inline">\(s\)</span>不变，不难发现只有两种变换满足要求，一个是恒等变换，另一个是绕s的对称轴翻转的变换，从而<spanclass="math inline">\(Stab(s)=2\)</span></p><p>所以<spanclass="math inline">\(|D_{2n}|=|Orb(s)|*|Stab(s)|=2n\)</span> <spanclass="math inline">\(\square\)</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Burnside引理</title>
    <link href="/2023/12/18/Burnside/"/>
    <url>/2023/12/18/Burnside/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
