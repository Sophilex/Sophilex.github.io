<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>群作用</title>
    <link href="/2023/12/19/%E7%BE%A4%E4%BD%9C%E7%94%A8-1/"/>
    <url>/2023/12/19/%E7%BE%A4%E4%BD%9C%E7%94%A8-1/</url>
    
    <content type="html"><![CDATA[<h1 id="群作用轨道-稳定化子定理">群作用，轨道-稳定化子定理</h1><p>不妨通过一个简单的例子来引入群作用的概念，恕我直言这个东西真的很神奇</p><h2 id="引入">引入</h2><blockquote><p>令<spanclass="math inline">\(S\)</span>是一个非空集合，我们考虑所有<spanclass="math inline">\(S \rightarrow S\)</span>的双射<spanclass="math inline">\(f\)</span>所组成的集合，记为<spanclass="math inline">\(Perm(S)\)</span>，事实上它关于映射的复合作成一个群，即<span class="math inline">\(S\)</span>上的置换群，即<spanclass="math inline">\((Perm(s),\circ)\)</span></p></blockquote><p>接下来考虑群<spanclass="math inline">\(G\)</span>上，对于一个特定的元素<spanclass="math inline">\(x\in G\)</span>的映射： <spanclass="math inline">\(\phi_x: G\rightarrow G,a\mapstoxa\)</span>,事实上它是一个双射，对于这一点我们只需证明<spanclass="math inline">\(\phi_x\)</span>存在逆映射即可。显然<spanclass="math inline">\(\phi_x\)</span>的逆映射就是<spanclass="math inline">\(\phi_{x^{-1}}: G\rightarrow G,a\mapstox^{-1}a\)</span>，</p><p><font color='orange'><strong>证明： </strong></font> <spanclass="math display">\[(\phi_x\circ\phi_{x^{-1}})(a)=\phi_x((\phi_{x^{-1}}(a)))=\phi_x(x^{-1}a)=xx^{-1}a=a=Id(a)\\(\phi_{x^{-1}}\circ\phi_{x})(a)=\phi_{x^{-1}}((\phi_{x}(a)))=\phi_{x^{-1}}(xa)=x^{-1}xa=a=Id(a)\\\]</span> 其中<span class="math inline">\(Id\)</span>就表示<spanclass="math inline">\(S\rightarrow S\)</span>的恒等映射</p><p>那么此时就有<spanclass="math inline">\((\phi_x)^{-1}=\phi_{x^{-1}}\)</span> ，故<spanclass="math inline">\(\phi_x\)</span>是<spanclass="math inline">\(G到G\)</span>的一个双射 <spanclass="math inline">\(\square\)</span></p><hr /><p>我们很快就注意到<strong><span class="math inline">\(\phi_x\inPerm(G)\)</span></strong> 。将目光从<spanclass="math inline">\(\phi_x\)</span>上再抽象出来一层，我们定义映射<spanclass="math inline">\(\phi:(G,\cdot)\rightarrow (Perm(G),\circ),x\mapsto\phi_x\)</span>。这里有点抽象，前者是一个群<spanclass="math inline">\(G\)</span>，后者也是一个群，但是它是从一个<strong>集合</strong><spanclass="math inline">\(G\)</span>当中得到的，在这个集合里我们忽略了<spanclass="math inline">\(G\)</span>的运算的结构，只考虑它作为集合的结构，从而得到所有在其上的双射组成的<spanclass="math inline">\((Perm(G),\circ)\)</span></p><p>映射的两个对象都是群，令人惊奇的是，事实上<spanclass="math inline">\(\phi\)</span>也是一个群同态：</p><p><font color='orange'><strong>证明：</strong></font></p><p><span class="math inline">\(\phi是良定义的:这一点显然\\\)</span></p><p><span class="math inline">\(\forall x,y\in G，z\in G\)</span> <spanclass="math display">\[(\phi_x\circ\phi_y)(z)=x(yz)=(xy)z=\phi_{xy}(z)\]</span> 对于所有的<spanclass="math inline">\(z\)</span>都满足该性质，故 <spanclass="math display">\[\phi_x\circ \phi_y=\phi_{xy}\]</span> 故 <span class="math display">\[\phi(x\cdot y)=\phi(x)\circ \phi(y)\]</span> <strong>故<span class="math inline">\(\phi\)</span>是<spanclass="math inline">\(G\rightarrow Perm(G)\)</span>的一个群同态</strong> <span class="math inline">\(\square\)</span></p><p>这样的一个神奇的<spanclass="math inline">\(\phi\)</span>就是一个群作用。现在我们给出定义如下</p><h2 id="定义1">定义1</h2><blockquote><p>令<span class="math inline">\(G\)</span>是一个群，<spanclass="math inline">\(S\)</span>是一个非空集合，若<spanclass="math inline">\(\phi:G\rightarrowPerm(S)\)</span>是一个<strong>群同态</strong>，那么称<spanclass="math inline">\(\phi\)</span>是<strong>群</strong><spanclass="math inline">\(G\)</span>在<strong>集合</strong><spanclass="math inline">\(S\)</span>上的一个群作用</p></blockquote><p>在上例中集合<span class="math inline">\(S\)</span>恰好就是<spanclass="math inline">\(G\)</span>本身，但是我们也强调过在<spanclass="math inline">\((Perm(G),\circ)\)</span>中我们已经忽略了<spanclass="math inline">\(G\)</span>作为群的运算结构而只考虑其集合的结构</p><p>从这个定义中我们可以很清晰地看到<spanclass="math inline">\(\phi\)</span>作为一个群同态的优美性质，但是实际上还有另外一种等价的定义，它能帮助我们更好地判断一个映射是否为群作用</p><h2 id="定义2">定义2</h2><blockquote><p>令<span class="math inline">\(G\)</span>是一个群，<spanclass="math inline">\(S\)</span>是一个非空集合，如果映射 <spanclass="math display">\[\sigma: G\cross S\rightarrow S\\\forall a\in G,x\in S,(a,x)\mapstoa\cdot x\\我们记为a作用在x上\]</span> 满足： <span class="math display">\[e\cdot x=x,\forall x\in S\\(ab)\cdot x=a\cdot(b\cdot x),\forall a,b \inG,x\in S\]</span> 那么称群<span class="math inline">\(G\)</span>在集合<spanclass="math inline">\(S\)</span>上<strong>有一个作用</strong> <spanclass="math inline">\((a,x)\mapsto a\cdot x\)</span></p></blockquote><p>仔细观察定义1，<spanclass="math inline">\(\phi\)</span>是我们的群作用，是一个<spanclass="math inline">\(G\rightarrowPerm(s)\)</span>的映射，现在我们取出一个<spanclass="math inline">\(x\)</span>，得到一个<spanclass="math inline">\(\phi_x\inPerm(S)\)</span>,它又是一个映射（事实上是双射），它作用在<spanclass="math inline">\(s\in S\)</span>,会得到<spanclass="math inline">\(\phi_x(s)\in S\)</span>。整个过程实际上就是在<spanclass="math inline">\(G\)</span>中取出一个元素x，在<spanclass="math inline">\(S\)</span>中取出一个元素<spanclass="math inline">\(s\)</span>,也就是对应<spanclass="math inline">\(G\cross S\)</span>,得到一个<spanclass="math inline">\(S\)</span>中的元素，这一过程解释了在定义2中<spanclass="math inline">\(\sigma\)</span>为什么是<spanclass="math inline">\(G\cross S\rightarrow S\)</span>的映射。</p><h2 id="两个定义的联系">两个定义的联系</h2><p>下面我们来证明两个定义其实是等价的：</p><p><font color='orange'><strong>证明:</strong></font></p><p>定义1$$定义2：</p><p>首先<span class="math inline">\(\phi\)</span>确实是<spanclass="math inline">\(G\cross S\rightarrowS\)</span>的映射，我们定义双射 <span class="math display">\[\phi_a: S\rightarrow S\\(a,x)\mapsto a\cdot x,a\in G,x\in S\\\]</span> 则： <span class="math display">\[\forall x\in S,e\cdot x=\phi_e(x)=Id(x)=x,故第一条得证\\\forall a,b\inG,(ab)\cdot x=\phi_{ab}(x)=(\phi_a\circ\phi_b)(x)=\phi_a(\phi_b(x))=\phi_a(b\cdot x)=a\cdot(b\cdotx)\\从而第二条得证\]</span> 定义2<spanclass="math inline">\(\rightarrow\)</span>定义1：</p><p>还是定义 <span class="math display">\[\phi: G\rightarrow Perm(S)\\x\mapsto\phi_x\\其中\phi_x: S\rightarrow S\\s\mapsto x\cdot s,s\in S\]</span> 首先证明<spanclass="math inline">\(\phi_x\)</span>确实是一个双射： <spanclass="math display">\[x\cdot(x^{-1}\cdot s)=(xx^{-1})\cdot s=e\cdot s= s\\x^{-1}\cdot(x\cdots)=(x^{-1}x)\cdot s=e\cdot s= s\]</span> 故<spanclass="math inline">\((\phi_x)^{-1}=\phi_{x^{-1}}\)</span>,所以它确实是一个双射。这一结论是由性质1保证的，因为<spanclass="math inline">\(e\cdot s=s\)</span></p><p>而由性质2，我们知道<spanclass="math inline">\(\phi\)</span>保持运算，所以<spanclass="math inline">\(\phi\)</span>是一个<spanclass="math inline">\(G\rightarrow Perm(S)\)</span>的群同态，所以<spanclass="math inline">\(\phi\)</span>就是群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(S\)</span>上的作用 <spanclass="math inline">\(\square\)</span></p><p>所以第一条性质是为了保证良定义，第二条性质是为了保证群同态，两者合在一起就是对群作用的定义</p><p>这样我们对一个映射就有了判断的条件了，也认识到了其优美的同态性质</p><blockquote><p>同时，如果我们认识到了群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(S\)</span>上有一个群作用 <spanclass="math display">\[(a,x)\mapsto a\cdot x,a\in G,x\in S\]</span> 那么 <span class="math display">\[\phi:G\rightarrow Perm(S)\\x\mapsto a\cdot x\]</span> 就一定是群<span class="math inline">\(G\)</span>到集合<spanclass="math inline">\(S\)</span>的群同态，以及 <spanclass="math display">\[\forall a\in G,\phi_a是S\rightarrow S的双射\]</span> <font color='red'>（当然<spanclass="math inline">\(\phi_a\)</span>不一定是群同态）</font></p></blockquote><h2 id="群作用的核">群作用的核</h2><p>群作用的核定义为定义1中同态<spanclass="math inline">\(\phi\)</span>的核，即<spanclass="math inline">\(Ker\phi\)</span></p><p>故 <span class="math display">\[a\in G是群作用的核\\\Leftrightarrow \phi_a=Id\\ \Leftrightarrow\phi_a(x)=x,\forall x\in S \\\Leftrightarrow a\cdot x=x,\forall x\in S\]</span></p><h2 id="群作用的例子">群作用的例子</h2><p>我们重新审视一下开头讲的例子</p><h3 id="群g在集合g上的左平移">群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(G\)</span>上的左平移</h3><p>令 <span class="math display">\[G\cross G\rightarrow G\\x\mapsto ax      (1)\]</span> 显然有 <span class="math display">\[ex=x,\forall x\in G\\(ab)x=a(bx),\forall a,b\in G,\forall x\in G\]</span> 所以<spanclass="math inline">\((1)\)</span>式给出了一个群作用。这里我们用定义2重新证明了这是一个群作用。</p><p>我们考察一下这个群作用的核 <span class="math display">\[a\in G属于群作用的核\\\Leftrightarrow ax=x,\forall x\inG\\\Leftrightarrow a=e\]</span> 故群作用的核为<spanclass="math inline">\(\{e\}\)</span>,所以<spanclass="math inline">\(\phi:G\rightarrowPerm(G)\)</span>是一个单同态。那么显然<span class="math inline">\(G\congIm\phi\)</span>。又<spanclass="math inline">\(Im\phi&lt;Perm(G)\)</span>,所以群<spanclass="math inline">\(G\)</span>与集合<spanclass="math inline">\(G\)</span>上的一个变换群同构！</p><p>如此我们很轻松地就证明了<spanclass="math inline">\(Cayley\)</span>定理：任意一个群都同构于某一个集合上的变换群</p><p>推论：<font color='blue'>任意一个<strong>有限群</strong>都同构于一个<strong>置换群</strong></font></p><hr /><h3 id="群g在集合g上的共轭作用">群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(G\)</span>上的共轭作用</h3><p>令 <span class="math display">\[G\cross G\rightarrow G\\x\mapsto axa^{-1}      (2)\]</span> 显然有 <span class="math display">\[exe^{-1}=x,\forall x\in G\\(ab)\cdot x=abxb^{-1}a^{-1}=a\cdot(bxb^{-1})=a\cdot(b\cdot x)\]</span> 故<spanclass="math inline">\((2)\)</span>式同样给出了一个群作用，叫做群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(G\)</span>上的共轭作用</p><p>考察该作用的核 <span class="math display">\[a\in G属于群作用的核\\\Leftrightarrow axa^{-1}=x\\\Leftrightarrowax=xa\\ \Leftrightarrowa\in \{b\in G|bx=xb,\forall x\in G\}=Z(G)\]</span> 这里<span class="math inline">\(Z(G)\)</span>称为群<spanclass="math inline">\(G\)</span>的中心。得到<spanclass="math inline">\(Ker\phi=Z(G)\)</span>。</p><p>这里共轭作用比左乘作用的性质要更好一些，因为实际上对于一个作用来说，根据我们之前所说，<span class="math display">\[\phi_a: G\rightarrow G\\x\mapsto axa^{-1}(3)\]</span></p><p>一定是双射，但是却未必是群同态，而共轭作用的每一个<spanclass="math inline">\(\phi_x\)</span><font color='red'>都是一个群同态</font>，从而<font color='red'>都是群同构</font></p><p><strong><font color='orange'>证明：</font></strong></p><p>因为<spanclass="math inline">\(\phi_a\)</span>都是双射，我们只需证明它是群同态即可（不是说<spanclass="math inline">\(\phi\)</span>是群同态，而是对每一个<spanclass="math inline">\(\phi_a\)</span>都是群同态） <spanclass="math display">\[\forall y,z\inG,\phi_a(yz)=a(yz)a^{-1}=aya^{-1}aza^{-1}=\phi_a(y)\phi_a(z)\]</span> 这就证明了共轭作用下每一个<spanclass="math inline">\(\phi_a\)</span>都是<strong>群<spanclass="math inline">\(G\)</span>到自身</strong>的群同构 <spanclass="math inline">\(\square\)</span></p><p>我们称群<spanclass="math inline">\(G\)</span>到自身的同构映射为自同构(automorphism),而由<spanclass="math inline">\((3)\)</span>式定义的同构称为内自同构(innerautomorphism) <span class="math display">\[f是群G的内自同构\Leftrightarrow f是G的共轭作用给出的一个自同构\]</span></p><p>然后我们来研究一些更加深入的东西</p><h2 id="轨道-稳定化子定理">轨道-稳定化子定理</h2><h3 id="轨道">轨道</h3><p>令 <span class="math display">\[\phi:G\rightarrow Perm(s)\\\phi_a(x)=a\cdot x\]</span> 是一个群作用</p><p>那么定义<span class="math inline">\(s\in S\)</span>的轨道<spanclass="math inline">\(Orb(s)\)</span>为 <span class="math display">\[Orb(s)=\{s&#39;\in S|\exist x\in G,xs&#39;=s\}=\{xs|x\in G\}\]</span> 也就是<span class="math inline">\(s\)</span>在所有<spanclass="math inline">\(x\)</span>的作用下能到达的点的集合。我们很快就能看到这个定义有什么用</p><blockquote><p>所有元素<span class="math inline">\(s\)</span>的轨道是集合<spanclass="math inline">\(S\)</span>的一个划分，即</p></blockquote><p><strong><font color='orange'>证明：</font></strong></p><p>定义集合<span class="math inline">\(S\)</span>上的一个二元关系 <spanclass="math display">\[y\sim x\Leftrightarrow \exist a\in G,y=a\cdot x\]</span> 不难验证<spanclass="math inline">\(\sim\)</span>是一个等价关系。所以它给出<spanclass="math inline">\(S\)</span>上的一个划分 <spanclass="math display">\[\begin{flalign}\forall x\in S,\bar{x}&amp;=\{y\in S|y\sim x\}\\&amp;=\{y\in S|\exista\in G,y=a\cdot x\}\\&amp;=\{a\cdot x|a\in G\}\\&amp;=Orb(x)\end{flalign}\\\]</span> <span class="math inline">\(\square\)</span></p><h3 id="一些杂谈">一些杂谈</h3><p>我们先来看看<span class="math inline">\(T\cross X\rightarrowX\)</span>的映射<spanclass="math inline">\(\phi\)</span>,当然它不一定满足群作用的性质，但是这个结构本身有很多值得研究的东西</p><p>不过我们不妨还是定义<span class="math inline">\((t,x)\mapsto t\cdotx\)</span></p><ul><li><p>令<span class="math inline">\(t\in T\)</span>，则集合 <spanclass="math display">\[\{x\in X|t\cdot x=x\}\]</span> 表示的是在变换t下不变的元素</p></li><li><p>令<span class="math inline">\(K\subset T\)</span>，则集合 <spanclass="math display">\[\{x\in X|\forall t\in K,t\cdot x=x\}\]</span> 表示的是在<spanclass="math inline">\(K\)</span>中所有变换<spanclass="math inline">\(t\)</span>下都保持不变的x的集合</p></li></ul><p>相对应的，我们以<spanclass="math inline">\(x\)</span>为主视角看看</p><ul><li><p>令<span class="math inline">\(x\in X\)</span>,则集合 <spanclass="math display">\[\{t\in T|t\cdot x=x\}\]</span> 表示的是固定了<spanclass="math inline">\(x\)</span>的所有变换t</p></li><li><p>令<span class="math inline">\(A\subset X\)</span>,则集合 <spanclass="math display">\[\{t\in T|\forall x\in A,t\cdot x=x\}\]</span> 表示的是固定了A中所有元素<spanclass="math inline">\(x\)</span>的t的集合</p></li></ul><p>事实上，只要给定了形如<span class="math inline">\(T\crossX\rightarrowX\)</span>的映射，我们都能很清晰地指出以上四个集合的内容</p><p>现在再回过头来看稳定化子。</p><h3 id="稳定化子">稳定化子</h3><p>定义<span class="math inline">\(s\in S\)</span>的稳定化子<spanclass="math inline">\(Stab(s)\)</span>为 <span class="math display">\[Stab(s)=\{x\in G|xs=s\}\]</span> 也就是固定了元素<spanclass="math inline">\(s\)</span>的所有<spanclass="math inline">\(x\)</span>,实际上也就是上文的第三个集合</p><blockquote><p>Stab(s)&lt;G</p></blockquote><p><strong><font color='orange'>证明：</font></strong></p><p><span class="math inline">\(\forall x,y\in Stab(s)\)</span>,有 <spanclass="math display">\[x\cdot s=y\cdot s=s\]</span> 从而<span class="math inline">\(x^{-1}\cdot s=x^{-1}\cdot(x\cdot s)=(x^{-1}x)\cdot s=e\cdot s=s\)</span>（关键步骤）</p><p>所以 <span class="math display">\[(yx^{-1})\cdot s=y(x^{-1}\cdot s)=y\cdot s=s\]</span> 故 <span class="math display">\[yx^{-1}\in Stab(s)\]</span> 从而<span class="math inline">\(Stab(s)&lt;G\)</span> <spanclass="math inline">\(\square\)</span></p><p><font color='red'>稍微总结一下我们就能看到一个很眼熟的东西</font></p><h4 id="引理1">引理1</h4><blockquote><p>令<span class="math inline">\(\phi:G\rightarrowPerm(S)\)</span>是一个群作用，则 <span class="math inline">\(\forallx,y\in G,s\in S,x\cdot s=y\cdot s\Leftrightarrow xy^{-1}\inStab(s)\)</span></p></blockquote><p>这与</p><blockquote><p>H&lt;G,则<span class="math inline">\(\forall x,y\inG,xH=yH\Leftrightarrow xy^{-1}\in H\)</span></p></blockquote><p>是很像的</p><p>现在我们知道<spanclass="math inline">\(Stab(s)\)</span>里的元素保持<spanclass="math inline">\(s\)</span>不变，我们还可以再探究一下其同一个陪集的元素对<spanclass="math inline">\(s\)</span>的作用</p><h4 id="引理2">引理2</h4><p><span class="math display">\[\begin{flalign}&amp;aStab(s)=bStab(s)\\&amp;\Leftrightarrow b^{-1}a\in Stab(s)\\&amp;由引理\\&amp;\Leftrightarrow a\cdot s=b\cdot s\end{flalign}\]</span></p><p>所以同一个陪集里的元素对<spanclass="math inline">\(s\)</span>的作用是一样的</p><p>从而我们令 <span class="math display">\[\phi:(G/Stab(s))_l\rightarrow Orb(s)\\ aStab(s)\mapsto a\cdot s\]</span> 那么从而我们可以通过引理2的正向推和逆向推得到<spanclass="math inline">\(\phi\)</span>的合理性以及单射的性质，又由于<spanclass="math inline">\(\phi\)</span>显然是一个满射，从而<spanclass="math inline">\(\phi\)</span>是一个<font color='red'><strong>双射！</strong></font></p><p>如次我们就证得了</p><h3 id="轨道-稳定化子定理-1">轨道-稳定化子定理</h3><blockquote><p>令<span class="math inline">\(\phi:G\rightarrowPerm(S)\)</span>是一个群作用，则<span class="math inline">\(\forall s\inS\)</span>,存在<span class="math inline">\((G/Stab(s))_l\)</span>到<spanclass="math inline">\(Orb(s)\)</span>的双射</p><p>从而<span class="math inline">\(|Orb(s)|=[G:Stab(s)]\)</span></p><p>若<span class="math inline">\(G\)</span>为有限群，则有<strong><spanclass="math inline">\(|G|=|Orb(s)|*|Stab(s)|\)</span></strong></p></blockquote><p>举一个形象的例子</p><p>二面体群 <spanclass="math inline">\(D_{2n}\)</span>，它是由所有正<spanclass="math inline">\(n\)</span>边形到自身的对称变换所构成的。对称变换,就是把<strong>自身映到自身</strong>，而且是保距的。保距指的是，原先距离相同的点，变换后距离仍然相同</p><blockquote><p><span class="math inline">\(|D_{2n}|=2n\)</span></p></blockquote><p><font color='orange'><strong>证明：</strong></font></p><p>首先正n边形有n个旋转变换，以及n个对称变换（绕n个对称轴分别翻转），这样就有<spanclass="math inline">\(2n\)</span>个元素了，我们要证明只有这些元素</p><p>任取正n边形的一个顶点<spanclass="math inline">\(s\)</span>,考虑其轨道<spanclass="math inline">\(Orb(s)\)</span>,最多只能到达n个顶点，而n个旋转变换就恰好可以让s到达n个不同顶点，所以<spanclass="math inline">\(|Orb(s)|=n\)</span></p><p>然后考虑<span class="math inline">\(Stab(s)\)</span>,我们要保持<spanclass="math inline">\(s\)</span>不变，不难发现只有两种变换满足要求，一个是恒等变换，另一个是绕s的对称轴翻转的变换，从而<spanclass="math inline">\(Stab(s)=2\)</span></p><p>所以<spanclass="math inline">\(|D_{2n}|=|Orb(s)|*|Stab(s)|=2n\)</span> <spanclass="math inline">\(\square\)</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/18/Burnside%E5%BC%95%E7%90%86%EF%BC%8CPolya%E5%AE%9A%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <url>/2023/12/18/Burnside%E5%BC%95%E7%90%86%EF%BC%8CPolya%E5%AE%9A%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<hr /><p>title: Burnside引理，Polya定理及其应用 date: 2023-12-18 19:02:08tags: Math mathjax: true</p><h2 id="burnside引理">Burnside引理</h2><p>书接上回，继续深入研究在群作用下集合的轨道与稳定子群的相关性质</p><p>现在我们想要研究这样一个问题： <span class="math display">\[有限群G在有限集合S上面有一个作用，那么S的G-轨道条数是多少\]</span> 也就是在有限群<spanclass="math inline">\(G\)</span>作用下集合<spanclass="math inline">\(S\)</span>的等价类的数量</p><p>不妨设<span class="math inline">\(S\)</span>有<spanclass="math inline">\(r\)</span>条<spanclass="math inline">\(G\)</span>-轨道条数，那么就有 <spanclass="math display">\[S=\bigcup_{i=1}^{r}Orb(x_i)\]</span> 其中<spanclass="math inline">\(x_i\)</span>就是每一条轨道的代表元。注意到任意两条轨道交集为空，所以<span class="math display">\[|S|=\bigcup_{i=1}^{r}|Orb(x_i)|=\bigcup_{i=1}^{r}\frac{|G|}{|Stab(x_i)|}\]</span>这里有点怪，它似乎暗示我们<strong>同一个轨道的元素的不变子群的阶都是一样的</strong>。我们再仔细研究一下</p><p><span class="math inline">\(\forall x,y\in S\)</span>,且<spanclass="math inline">\(x\)</span>,<spanclass="math inline">\(y\)</span>在同一条轨道里面，<spanclass="math inline">\(\exist a\in G,a\cdot x=y\)</span>。则 <spanclass="math display">\[\begin{flalign}&amp;h\in Stab(y)\Leftrightarrow h\cdot y=y\\ &amp;\Leftrightarrow h\cdot(a\cdot x)=a\cdot x\\ &amp;\Leftrightarrow (ha)\cdot x=a\cdot x\\ &amp;\Leftrightarrow a^{-1}\cdot ((ha)\cdot x)=(a^{-1}\cdot (a\cdotx))\\ &amp;\Leftrightarrow (a^{-1}ha)\cdot x=x\\ &amp;\Leftrightarrow a^{-1}ha\in Stab(x)\\ &amp;\Leftrightarrow h\in a^{-1}Stab(x)a\end{flalign}\]</span></p><p>注意到上述过程都是等价的，所以我们很快得到 <spanclass="math display">\[Stab(y)=a^{-1}Stab(x)a\]</span> <font color='green'>于是我们得到如下命题</font></p><blockquote><p>设有限群<span class="math inline">\(G\)</span>在有限集合<spanclass="math inline">\(S\)</span>上面有一个作用，那么同一个<spanclass="math inline">\(G\)</span>-轨道的点的稳定子群彼此共轭，从而它们彼此同构</p></blockquote><p>同构的群之间显然阶数相等，这也解答了我们刚刚的疑惑。</p><p>现在再来重新审视一个轨道<spanclass="math inline">\(Orb(x_i)\)</span>,其内部所有元素的稳定子群的阶是相同的，那么内部所有元素的稳定子群的阶数之和就会等于<span class="math display">\[\sum |Stab(x_i)|=|Stab(x_i)||Orb(x_i|=|G|\]</span>那么<font color='red'>集合内部所有元素的稳定子群的阶之和就会等于</font><span class="math display">\[\sum_{x\in S}|Stab(x)|=\sum_{i=1}^{r}|G|=r|G|\quad\quad\quad\quad\quad\quad(1)\]</span> 这启发我们用另一种方法来计算<spanclass="math inline">\(r\)</span>.只要能够得到<spanclass="math inline">\(\sum_{x\in S}|Stab(x)|\)</span>,再除以<spanclass="math inline">\(|G|\)</span>，就能得到<spanclass="math inline">\(r\)</span></p><p>​---</p><p>我们考虑<span class="math inline">\(G\cross S\)</span>的一个子集<spanclass="math inline">\(K=\{(a,x)|a\cdot x=x\}\)</span>,</p><p>对于一个给定的<span class="math inline">\(x\in S\)</span>,以<spanclass="math inline">\(x\)</span>作为第二个值的有序对<spanclass="math inline">\((a,x)\)</span>的数量显然就是<spanclass="math inline">\(|Stab(x)|\)</span>,所以 <spanclass="math display">\[|K|=\sum_{x\in S}|Stab(x)|\]</span> 问题又转化成了求<spanclass="math inline">\(|K|\)</span>,不过我们离成功已经很近了。</p><p>事实上将问题转化成求<spanclass="math inline">\(|K|\)</span>是很有好处的，因为我们可以以<spanclass="math inline">\(x\)</span>为关键字来看待它，当然也可以以<spanclass="math inline">\(a\)</span>为关键字来看。如此，对于一个给定的<spanclass="math inline">\(a\in G\)</span>,所有以<spanclass="math inline">\(a\)</span>为第一个值的有序对对应的x组成一个集合<spanclass="math inline">\(F_a=\{x|a\cdot x=x\}\)</span>,我们记其为<spanclass="math inline">\(a\)</span>的不动点集</p><p>那么 <span class="math display">\[\sum_{x\in S}|Stab(x)|=|K|=\sum_{a\in G}|F_a|\]</span> 从而由<span class="math inline">\((1)\)</span>式可知 <spanclass="math display">\[r=\frac{\sum_{x\in S}|Stab(x)|}{|G|}=\frac{1}{|G|}\sum_{a\in G}|F_a|\]</span> <font color='green'>于是我们得到<spanclass="math inline">\(Burnside\)</span>引理如下：</font></p><blockquote><p>设有限群<span class="math inline">\(G\)</span>在有限集合<spanclass="math inline">\(S\)</span>上有一个群作用，那么<spanclass="math inline">\(S\)</span>的<spanclass="math inline">\(G\)</span>-轨道条数<spanclass="math inline">\(r\)</span>为 <span class="math display">\[r=\frac{1}{|G|}\sum_{a\in G}|F_a|\]</span></p></blockquote><p>这个引理的意义在于，原本单纯只跟集合<spanclass="math inline">\(S\)</span>有关的问题，我们可以借用群<spanclass="math inline">\(G\)</span>来解决了，而群<spanclass="math inline">\(G\)</span>在一些特定情况下有良好的性质能够帮助我们快速计算<spanclass="math inline">\(\sum_{a\in G}|F_a|\)</span></p><h3 id="应用">应用</h3><p>来个具体的例子</p><blockquote><p>给定一个大小为n的环，环上每一个点有m种染色方案。问总共可以染出多少个本质不同的环。这里环本质不同定义为无法通过旋转得到</p></blockquote><p>不妨记环上点的集合为<spanclass="math inline">\(B=\{b_1,b_2,...b_n\}\)</span>,染色方案集合为<spanclass="math inline">\(C=\{c_1,c_2,...c_m\}\)</span>,考虑集合 <spanclass="math display">\[S=B^C=\{X_i\},其中X_i=&lt;c_{i_1},c_{i_2},...c_{i_n}&gt;,1\leq i_j\leq m\]</span> <spanclass="math inline">\(S\)</span>的实际含义就是所有给<spanclass="math inline">\(B\)</span>中元素染色的方案的集合,每一个方案用一个n元排列表示,显然<spanclass="math inline">\(|S|=m^n\)</span></p><p>现在考虑在集合<span class="math inline">\(B\)</span>上的置换群<spanclass="math inline">\(Perm(B)\)</span>的子群<spanclass="math inline">\(G=\{\bigl(\begin{smallmatrix} 1 &amp; 2 &amp; ...&amp; n-1 &amp; n\\ 2 &amp; 3 &amp; ...&amp; n &amp; 1\end{smallmatrix}\bigr),\bigl(\begin{smallmatrix}  1&amp; 2 &amp; 3&amp; ... &amp; n-1 &amp; n\\ 3 &amp; 4&amp; ...&amp; n &amp; 1 &amp; 2\end{smallmatrix}\bigr),...,(1)\}\)</span>,其中<spanclass="math inline">\(G_i=\bigl(\begin{smallmatrix}  1&amp;2 &amp;3&amp;4&amp;... &amp; n-1 &amp; n\\  i+1&amp; i+2 &amp; ... &amp; n&amp; 1 &amp;...&amp;i \end{smallmatrix}\bigr)\)</span>。显然<spanclass="math inline">\(|G|=n\)</span>。此外不难证明<spanclass="math inline">\(G\)</span>确实是一个群，这里就不证了。</p><p><font color='red'><strong>至于为什么要这样定义，是因为<spanclass="math inline">\(G\)</span>中元素实际上代表的就是一个环的旋转（这一点不难发现）与题目给出的本质不同的定义相吻合。整个<spanclass="math inline">\(G\)</span>就恰好代表了环上的所有旋转操作，如果我们能证明有限群<spanclass="math inline">\(G\)</span>在集合<spanclass="math inline">\(S\)</span>上有一个作用,那么本质不同的环的数量不就是<spanclass="math inline">\(S\)</span>的<spanclass="math inline">\(G\)</span>-轨道条数了吗，从而可以用<spanclass="math inline">\(Burnside\)</span>引理求解</strong></font></p><p>我们来证明有限群<span class="math inline">\(G\)</span>确实在集合<spanclass="math inline">\(S\)</span>上有一个作用</p><p><strong><font color='orange'>证明：</font></strong></p><p>考虑 <span class="math display">\[\phi:G\cross S\rightarrow S\\ (a,x)\mapsto a\cdot x\]</span> 这里<span class="math inline">\(a\)</span>是一个置换，<spanclass="math inline">\(x\)</span>是一个大小为<spanclass="math inline">\(n\)</span>的排列，那么此时<spanclass="math inline">\(a\cdot x\)</span>就是一个普通的置换在排列上的作用了，这样定义显然是合理的。</p><p>要证明<span class="math inline">\(G\)</span>在<spanclass="math inline">\(S\)</span>上有群作用，我们只需要证明 <spanclass="math display">\[e\cdot x=x,\forall x\in S\\ (a\circ b)\cdot x=a\cdot (b\cdot x)\]</span> 第一点非常显然，<spanclass="math inline">\(G\)</span>中的<spanclass="math inline">\(e\)</span>就是恒等变换，它作用在一个排列上显然保持不变</p><p>第二点其实就是置换的复合性质的描述，我们当然知道它是成立的</p><p>从而<span class="math inline">\(G\)</span>确实在<spanclass="math inline">\(S\)</span>上有一个群作用，那么我们就可以用<spanclass="math inline">\(Burnside\)</span>引理来处理这个问题了。 <spanclass="math inline">\(\square\)</span></p><p>我们要求本质不同的环的数量，也就是求<spanclass="math inline">\(S\)</span>的<spanclass="math inline">\(G\)</span>-轨道条数<spanclass="math inline">\(r\)</span>,从而 <span class="math display">\[r=\frac{1}{|G|}\sum_{a\in G}|F_a|=\frac{1}{n}\sum_{a\in G}|F_a|\]</span> 此时问题变成对于<spanclass="math inline">\(G\)</span>内的每一个置换，求其不动点集的阶</p><p>​---</p><p>不妨来看个简单版本，我们就令<spanclass="math inline">\(n=4\)</span>。此时总共有4个置换，</p><ul><li><span class="math inline">\(a_1=\bigl(\begin{smallmatrix} 1 &amp; 2&amp; 3 &amp; 4 \\ 2 &amp; 3 &amp;4 &amp; 1\end{smallmatrix}\bigr)\)</span>,此时显然需要<spanclass="math inline">\(x_i\)</span>内所有<spanclass="math inline">\(c_{i_j}\)</span>都相等，从而<spanclass="math inline">\(|F_{a_1}|=m\)</span></li><li><span class="math inline">\(a_2=\bigl(\begin{smallmatrix} 1 &amp; 2&amp; 3 &amp; 4 \\ 3 &amp; 4 &amp; 1 &amp; 2\end{smallmatrix}\bigr)\)</span>,<spanclass="math inline">\(1,3\)</span>是一组，<spanclass="math inline">\(2,4\)</span>是一组，所以<spanclass="math inline">\(|F_{a_2}|=m^2\)</span></li><li>同理可得<span class="math inline">\(|F_{a_3}|=m\)</span></li><li><span class="math inline">\(a_4=(1)\)</span>,每一个排列在<spanclass="math inline">\(a_4\)</span>作用下都保持不变，元素对应的颜色自然也不变，从而<spanclass="math inline">\(|F_{a_4}|=|S|=m^n\)</span></li></ul><p>从而<spanclass="math inline">\(r=\frac{1}{n}(m^n+2m+m^2)\)</span></p><p>​---</p><p>但是当<spanclass="math inline">\(n\)</span>逐渐变大的时候,这种暴力枚举的方法将会变的寸步难行。这里再引入一个概念</p><h3 id="置换群的轮换指标">置换群的轮换指标</h3><p>置换型：如果<span class="math inline">\(n\)</span>元置换<spanclass="math inline">\(g\)</span>中有<spanclass="math inline">\(b_i\)</span>个长度为<spanclass="math inline">\(i\)</span>的轮换，那么<spanclass="math inline">\(g\)</span>的置换型为<spanclass="math inline">\({x_1}^{b_1}{x_2}^{b_2}...{x_n}^{b_n}\)</span>，其中<spanclass="math inline">\(\sum i*b_i=n\)</span>显然成立。这里<spanclass="math inline">\(x_i\)</span>只是一个形式</p><blockquote><p>设<span class="math inline">\((G,\circ)\)</span>是一个<spanclass="math inline">\(n\)</span>元置换群，那么它的轮换指标定义为 <spanclass="math display">\[P_G(x_1,x_2,...x_n)=\frac{1}{|G|}\sum_{g\inG}x_1^{b_1}x_2^{b_2}...x_{n}^{b_n}\]</span></p></blockquote><p><span class="math inline">\({x_i}^{b_i}\)</span>就表示在一个置换<spanclass="math inline">\(g\)</span>内有<spanclass="math inline">\(b_i\)</span>个<spanclass="math inline">\(i\)</span>-轮换，而对于一个轮换，其内所有点都是可以互相到达的，所以轮换内部的点的颜色一定得相同，从而这个轮换的染色方案就是<spanclass="math inline">\(m\)</span>,从而,对于置换<spanclass="math inline">\(g\)</span>,<spanclass="math inline">\(|F_g|=m^{b_1}m^{b_2}...m^{b_n}\)</span></p><p>从而 <span class="math display">\[r=\frac{1}{|G|}\sum_{a\in G}|F_a|=\frac{1}{|G|}\sum_{a\inG}x_1^{b_1}x_2^{b_2}...x_{n}^{b_n}=P_G(x_1,x_2,...x_n)\]</span> 现在问题就变成了求置换群<spanclass="math inline">\(G\)</span>的轮换指标</p><p>这里给出一些结论</p><h4 id="正n边形的旋转群的轮换指标">正n边形的旋转群的轮换指标</h4><p><span class="math display">\[P_G=\frac{1}{n}\sum_{d|n}\phi_d{x_d}^{\frac{n}{d}}\]</span></p><p>这其实就是我们刚刚在研究的问题</p><p>注意到正n边形的旋转群<span class="math inline">\(G\)</span>中，<spanclass="math inline">\(G_i\)</span>就表示旋转步长为<spanclass="math inline">\(i\)</span>的置换组成，我们有如下结论： <spanclass="math display">\[|F_{G_i}|=(n,i)\]</span> <strong><font color='orange'>证明：</font></strong></p><ul><li><span class="math inline">\(i|n\)</span>,每次走i步，<spanclass="math inline">\(n/i\)</span>次后回到原点，所以该置换可以拆成i个轮换，每一个轮换的阶为<spanclass="math inline">\(n/i\)</span>。显然有<spanclass="math inline">\(|F_{G_i}|=i=(n,i)\)</span></li><li><span class="math inline">\(i\nmid n\)</span>,每次走<spanclass="math inline">\(i\)</span>步，回到原点需要<spanclass="math inline">\(lcm(n,i)\)</span>次，从而每一个轮换的阶为<spanclass="math inline">\(lcm(n,i)/i\)</span>,那么<spanclass="math inline">\(|F_{G_i}|=n/(lcm(n,i)/i)=ni/lcm(n,i)=(n,i)\)</span></li></ul><p><span class="math inline">\(\square\)</span></p><p>未完待续</p><p>不妨记环上点的集合为<spanclass="math inline">\(B=\{b_1,b_2,...b_n\}\)</span>,染色方案集合为<spanclass="math inline">\(C=\{c_1,c_2,...c_m\}\)</span>,考虑集合</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Burnside引理</title>
    <link href="/2023/12/18/Burnside/"/>
    <url>/2023/12/18/Burnside/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
